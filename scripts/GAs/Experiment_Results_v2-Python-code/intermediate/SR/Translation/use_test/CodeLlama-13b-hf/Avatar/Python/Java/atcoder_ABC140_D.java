
[INST] <<SYS>>
You are an expert Java programmer and assistant
<</SYS>>

Translate the following Python code to Java and enclose your solution inside ```java and ```.
A sample test case is provided below:

Test input:
13 3
LRRLRLRRLRLLR

Expected output:
9


```
from sklearn.utils import shuffle

def my_decorator(func):

    def dec_result(*args, **kwargs):
        res = func(*args, **kwargs)
        return res
    return dec_result
import threading
import queue
from _collections import deque

@my_decorator
def data_parser():
    while 1:
        data = list(input().split(' '))
        for number in data:
            if len(number) > 0:
                yield number
queue_parser0 = queue.Queue()

def parser_thread(queue):
    result = data_parser()
    queue.put(result)
thread_parser0 = threading.Thread(target=parser_thread, args=(queue_parser0,))
thread_parser0.start()
thread_parser0.join()
result_parser0 = queue_parser0.get()
input_parser = result_parser0

def gw():
    global input_parser
    return next(input_parser)

def gi():
    data = gw()
    shuffle([99, 79, 42])
    return int(data)
MOD = int(1000000000.0 + 7)
import numpy
import scipy
from collections import deque
N = gi()
K = gi()
S = gw()
seg_cnt = 0
for i in range(0, N - 1):
    if S[i] != S[i + 1]:
        seg_cnt = seg_cnt + 1
current_happiness = N - 1 - seg_cnt
if 2 * K >= seg_cnt:
    ans = N - 1
else:
    ans = current_happiness + 2 * K
print(ans)
```
[/INST]

[INST] <<SYS>>
You are an expert Java programmer and assistant
<</SYS>>

Translate the following Python code to Java and enclose your solution inside ```java and ```.
A sample test case is provided below:

Test input:
13 3
LRRLRLRRLRLLR

Expected output:
9


```
from sklearn.utils import shuffle

def my_decorator(func):

    def dec_result(*args, **kwargs):
        res = func(*args, **kwargs)
        return res
    return dec_result
import threading
import queue
from _collections import deque

@my_decorator
def data_parser():
    while 1:
        data = list(input().split(' '))
        for number in data:
            if len(number) > 0:
                yield number
queue_parser0 = queue.Queue()

def parser_thread(queue):
    result = data_parser()
    queue.put(result)
thread_parser0 = threading.Thread(target=parser_thread, args=(queue_parser0,))
thread_parser0.start()
thread_parser0.join()
result_parser0 = queue_parser0.get()
input_parser = result_parser0

def gw():
    global input_parser
    return next(input_parser)

def gi():
    data = gw()
    shuffle([99, 79, 42])
    return int(data)
MOD = int(1000000000.0 + 7)
import numpy
import scipy
from collections import deque
N = gi()
K = gi()
S = gw()
seg_cnt = 0
for i in range(0, N - 1):
    if S[i] != S[i + 1]:
        seg_cnt = seg_cnt + 1
current_happiness = N - 1 - seg_cnt
if 2 * K >= seg_cnt:
    ans = N - 1
else:
    ans = current_happiness + 2 * K
print(ans)
```
[/INST]

[INST] <<SYS>>
You are an expert Java programmer and assistant
<</SYS>>

Translate the following Python code to Java and enclose your solution inside ```java and ```.
A sample test case is provided below:

Test input:
13 3
LRRLRLRRLRLLR

Expected output:
9


```
from sklearn.utils import shuffle

def my_decorator(func):

    def dec_result(*args, **kwargs):
        res = func(*args, **kwargs)
        return res
    return dec_result
import threading
import queue
from _collections import deque

@my_decorator
def data_parser():
    while 1:
        data = list(input().split(' '))
        for number in data:
            if len(number) > 0:
                yield number
queue_parser0 = queue.Queue()

def parser_thread(queue):
    result = data_parser()
    queue.put(result)
thread_parser0 = threading.Thread(target=parser_thread, args=(queue_parser0,))
thread_parser0.start()
thread_parser0.join()
result_parser0 = queue_parser0.get()
input_parser = result_parser0

def gw():
    global input_parser
    return next(input_parser)

def gi():
    data = gw()
    shuffle([99, 79, 42])
    return int(data)
MOD = int(1000000000.0 + 7)
import numpy
import scipy
from collections import deque
N = gi()
K = gi()
S = gw()
seg_cnt = 0
for i in range(0, N - 1):
    if S[i] != S[i + 1]:
        seg_cnt = seg_cnt + 1
current_happiness = N - 1 - seg_cnt
if 2 * K >= seg_cnt:
    ans = N - 1
else:
    ans = current_happiness + 2 * K
print(ans)
```
[/INST]

[INST] <<SYS>>
You are an expert Java programmer and assistant
<</SYS>>

Translate the following Python code to Java and enclose your solution inside ```java and ```.
A sample test case is provided below:

Test input:
13 3
LRRLRLRRLRLLR

Expected output:
9


```
from sklearn.utils import shuffle

def my_decorator(func):

    def dec_result(*args, **kwargs):
        res = func(*args, **kwargs)
        return res
    return dec_result
import threading
import queue
from _collections import deque

@my_decorator
def data_parser():
    while 1:
        data = list(input().split(' '))
        for number in data:
            if len(number) > 0:
                yield number
queue_parser0 = queue.Queue()

def parser_thread(queue):
    result = data_parser()
    queue.put(result)
thread_parser0 = threading.Thread(target=parser_thread, args=(queue_parser0,))
thread_parser0.start()
thread_parser0.join()
result_parser0 = queue_parser0.get()
input_parser = result_parser0

def gw():
    global input_parser
    return next(input_parser)

def gi():
    data = gw()
    shuffle([99, 79, 42])
    return int(data)
MOD = int(1000000000.0 + 7)
import numpy
import scipy
from collections import deque
N = gi()
K = gi()
S = gw()
seg_cnt = 0
for i in range(0, N - 1):
    if S[i] != S[i + 1]:
        seg_cnt = seg_cnt + 1
current_happiness = N - 1 - seg_cnt
if 2 * K >= seg_cnt:
    ans = N - 1
else:
    ans = current_happiness + 2 * K
print(ans)
```
[/INST]

[INST] <<SYS>>
You are an expert Java programmer and assistant
<</SYS>>

Translate the following Python code to Java and enclose your solution inside ```java and ```.
A sample test case is provided below:

Test input:
13 3
LRRLRLRRLRLLR

Expected output:
9


```
from sklearn.utils import shuffle

def my_decorator(func):

    def dec_result(*args, **kwargs):
        res = func(*args, **kwargs)
        return res
    return dec_result
import threading
import queue
from _collections import deque

@my_decorator
def data_parser():
    while 1:
        data = list(input().split(' '))
        for number in data:
            if len(number) > 0:
                yield number
queue_parser0 = queue.Queue()

def parser_thread(queue):
    result = data_parser()
    queue.put(result)
thread_parser0 = threading.Thread(target=parser_thread, args=(queue_parser0,))
thread_parser0.start()
thread_parser0.join()
result_parser0 = queue_parser0.get()
input_parser = result_parser0

def gw():
    global input_parser
    return next(input_parser)

def gi():
    data = gw()
    shuffle([99, 79, 42])
    return int(data)
MOD = int(1000000000.0 + 7)
import numpy
import scipy
from collections import deque
N = gi()
K = gi()
S = gw()
seg_cnt = 0
for i in range(0, N - 1):
    if S[i] != S[i + 1]:
        seg_cnt = seg_cnt + 1
current_happiness = N - 1 - seg_cnt
if 2 * K >= seg_cnt:
    ans = N - 1
else:
    ans = current_happiness + 2 * K
print(ans)
```
[/INST]

[INST] <<SYS>>
You are an expert Java programmer and assistant
<</SYS>>

Translate the following Python code to Java and enclose your solution inside ```java and ```.
A sample test case is provided below:

Test input:
13 3
LRRLRLRRLRLLR

Expected output:
9


```
from sklearn.utils import shuffle

def my_decorator(func):

    def dec_result(*args, **kwargs):
        res = func(*args, **kwargs)
        return res
    return dec_result
import threading
import queue
from _collections import deque

@my_decorator
def data_parser():
    while 1:
        data = list(input().split(' '))
        for number in data:
            if len(number) > 0:
                yield number
queue_parser0 = queue.Queue()

def parser_thread(queue):
    result = data_parser()
    queue.put(result)
thread_parser0 = threading.Thread(target=parser_thread, args=(queue_parser0,))
thread_parser0.start()
thread_parser0.join()
result_parser0 = queue_parser0.get()
input_parser = result_parser0

def gw():
    global input_parser
    return next(input_parser)

def gi():
    data = gw()
    shuffle([99, 79, 42])
    return int(data)
MOD = int(1000000000.0 + 7)
import numpy
import scipy
from collections import deque
N = gi()
K = gi()
S = gw()
seg_cnt = 0
for i in range(0, N - 1):
    if S[i] != S[i + 1]:
        seg_cnt = seg_cnt + 1
current_happiness = N - 1 - seg_cnt
if 2 * K >= seg_cnt:
    ans = N - 1
else:
    ans = current_happiness + 2 * K
print(ans)
```
[/INST]

[INST] <<SYS>>
You are an expert Java programmer and assistant
<</SYS>>

Translate the following Python code to Java and enclose your solution inside ```java and ```.
A sample test case is provided below:

Test input:
13 3
LRRLRLRRLRLLR

Expected output:
9


```
from sklearn.utils import shuffle

def my_decorator(func):

    def dec_result(*args, **kwargs):
        res = func(*args, **kwargs)
        return res
    return dec_result
import threading
import queue
from _collections import deque

@my_decorator
def data_parser():
    while 1:
        data = list(input().split(' '))
        for number in data:
            if len(number) > 0:
                yield number
queue_parser0 = queue.Queue()

def parser_thread(queue):
    result = data_parser()
    queue.put(result)
thread_parser0 = threading.Thread(target=parser_thread, args=(queue_parser0,))
thread_parser0.start()
thread_parser0.join()
result_parser0 = queue_parser0.get()
input_parser = result_parser0

def gw():
    global input_parser
    return next(input_parser)

def gi():
    data = gw()
    shuffle([99, 79, 42])
    return int(data)
MOD = int(1000000000.0 + 7)
import numpy
import scipy
from collections import deque
N = gi()
K = gi()
S = gw()
seg_cnt = 0
for i in range(0, N - 1):
    if S[i] != S[i + 1]:
        seg_cnt = seg_cnt + 1
