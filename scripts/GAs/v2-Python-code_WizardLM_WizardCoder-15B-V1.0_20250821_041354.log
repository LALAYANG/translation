+ model=WizardLM/WizardCoder-15B-V1.0
+ dataset=Avatar
+ cache=tmp
+ src=Python
+ tgt=Java
+ python3 translate.py --model WizardLM/WizardCoder-15B-V1.0 --dataset Avatar --source_lang Python --target_lang Java --cache_dir tmp --use_test
INFO 08-21 07:17:28 [__init__.py:241] Automatically detected platform cuda.
found 225 inputs
INFO 08-21 07:17:29 [utils.py:326] non-default args: {'model': 'WizardLM/WizardCoder-15B-V1.0', 'trust_remote_code': True, 'dtype': 'bfloat16', 'max_model_len': 4096, 'tensor_parallel_size': 2, 'disable_log_stats': True}
The argument `trust_remote_code` is to be used with Auto classes. It has no effect here and is ignored.
INFO 08-21 07:17:36 [__init__.py:711] Resolved architecture: GPTBigCodeForCausalLM
WARNING 08-21 07:17:36 [__init__.py:2819] Casting torch.float16 to torch.bfloat16.
INFO 08-21 07:17:36 [__init__.py:1750] Using max model len 4096
INFO 08-21 07:17:36 [scheduler.py:222] Chunked prefill is enabled with max_num_batched_tokens=16384.
[1;36m(EngineCore_0 pid=3930910)[0;0m INFO 08-21 07:17:37 [core.py:636] Waiting for init message from front-end.
[1;36m(EngineCore_0 pid=3930910)[0;0m INFO 08-21 07:17:37 [core.py:74] Initializing a V1 LLM engine (v0.10.1.1) with config: model='WizardLM/WizardCoder-15B-V1.0', speculative_config=None, tokenizer='WizardLM/WizardCoder-15B-V1.0', skip_tokenizer_init=False, tokenizer_mode=auto, revision=None, override_neuron_config={}, tokenizer_revision=None, trust_remote_code=True, dtype=torch.bfloat16, max_seq_len=4096, download_dir=None, load_format=auto, tensor_parallel_size=2, pipeline_parallel_size=1, disable_custom_all_reduce=False, quantization=None, enforce_eager=False, kv_cache_dtype=auto, device_config=cuda, decoding_config=DecodingConfig(backend='auto', disable_fallback=False, disable_any_whitespace=False, disable_additional_properties=False, reasoning_backend=''), observability_config=ObservabilityConfig(show_hidden_metrics_for_version=None, otlp_traces_endpoint=None, collect_detailed_traces=None), seed=0, served_model_name=WizardLM/WizardCoder-15B-V1.0, enable_prefix_caching=True, chunked_prefill_enabled=True, use_async_output_proc=True, pooler_config=None, compilation_config={"level":3,"debug_dump_path":"","cache_dir":"","backend":"","custom_ops":[],"splitting_ops":["vllm.unified_attention","vllm.unified_attention_with_output","vllm.mamba_mixer2"],"use_inductor":true,"compile_sizes":[],"inductor_compile_config":{"enable_auto_functionalized_v2":false},"inductor_passes":{},"cudagraph_mode":1,"use_cudagraph":true,"cudagraph_num_of_warmups":1,"cudagraph_capture_sizes":[512,504,496,488,480,472,464,456,448,440,432,424,416,408,400,392,384,376,368,360,352,344,336,328,320,312,304,296,288,280,272,264,256,248,240,232,224,216,208,200,192,184,176,168,160,152,144,136,128,120,112,104,96,88,80,72,64,56,48,40,32,24,16,8,4,2,1],"cudagraph_copy_inputs":false,"full_cuda_graph":false,"pass_config":{},"max_capture_size":512,"local_cache_dir":null}
[1;36m(EngineCore_0 pid=3930910)[0;0m WARNING 08-21 07:17:37 [multiproc_worker_utils.py:273] Reducing Torch parallelism from 26 threads to 1 to avoid unnecessary CPU contention. Set OMP_NUM_THREADS in the external environment to tune this value as needed.
[1;36m(EngineCore_0 pid=3930910)[0;0m INFO 08-21 07:17:37 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[0, 1], buffer_handle=(2, 16777216, 10, 'psm_c4f79128'), local_subscribe_addr='ipc:///tmp/c1a9b525-26cb-4d66-b235-d9967b0d4138', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:17:39 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[0], buffer_handle=(1, 10485760, 10, 'psm_9714c844'), local_subscribe_addr='ipc:///tmp/e11af166-ae1e-4689-b18a-5cab9ae6d671', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:17:39 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[0], buffer_handle=(1, 10485760, 10, 'psm_756a4908'), local_subscribe_addr='ipc:///tmp/4418d5ae-bae3-45c4-9594-780a6115f4be', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:17:40 [__init__.py:1418] Found nccl from library libnccl.so.2
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:17:40 [__init__.py:1418] Found nccl from library libnccl.so.2
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:17:40 [pynccl.py:70] vLLM is using nccl==2.26.2
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:17:40 [pynccl.py:70] vLLM is using nccl==2.26.2
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:17:40 [custom_all_reduce.py:35] Skipping P2P check and trusting the driver's P2P report.
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:17:40 [custom_all_reduce.py:35] Skipping P2P check and trusting the driver's P2P report.
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:17:40 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[1], buffer_handle=(1, 4194304, 6, 'psm_b0bf0994'), local_subscribe_addr='ipc:///tmp/ff5750eb-bf74-4b66-9b81-be41480d6dc7', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:17:40 [parallel_state.py:1134] rank 0 in world size 2 is assigned as DP rank 0, PP rank 0, TP rank 0, EP rank 0
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:17:40 [parallel_state.py:1134] rank 1 in world size 2 is assigned as DP rank 0, PP rank 0, TP rank 1, EP rank 1
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m WARNING 08-21 07:17:40 [topk_topp_sampler.py:61] FlashInfer is not available. Falling back to the PyTorch-native implementation of top-p & top-k sampling. For the best performance, please install FlashInfer.
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m WARNING 08-21 07:17:40 [topk_topp_sampler.py:61] FlashInfer is not available. Falling back to the PyTorch-native implementation of top-p & top-k sampling. For the best performance, please install FlashInfer.
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:17:40 [gpu_model_runner.py:1953] Starting to load model WizardLM/WizardCoder-15B-V1.0...
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:17:40 [gpu_model_runner.py:1953] Starting to load model WizardLM/WizardCoder-15B-V1.0...
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:17:41 [gpu_model_runner.py:1985] Loading model from scratch...
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:17:41 [gpu_model_runner.py:1985] Loading model from scratch...
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:17:41 [cuda.py:328] Using Flash Attention backend on V1 engine.
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:17:41 [cuda.py:328] Using Flash Attention backend on V1 engine.
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:17:41 [weight_utils.py:296] Using model weights format ['*.bin']
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:17:41 [weight_utils.py:296] Using model weights format ['*.bin']
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m Loading pt checkpoint shards:   0% Completed | 0/1 [00:00<?, ?it/s]
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m Loading pt checkpoint shards: 100% Completed | 1/1 [00:39<00:00, 39.82s/it]
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m Loading pt checkpoint shards: 100% Completed | 1/1 [00:39<00:00, 39.82s/it]
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m 
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:18:21 [default_loader.py:262] Loading weights took 39.86 seconds
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:18:21 [default_loader.py:262] Loading weights took 40.03 seconds
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:18:22 [gpu_model_runner.py:2007] Model loading took 14.5982 GiB and 40.716481 seconds
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:18:22 [gpu_model_runner.py:2007] Model loading took 14.5982 GiB and 40.714419 seconds
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:18:27 [backends.py:548] Using cache directory: /home/ubuntu/.cache/vllm/torch_compile_cache/f0dee51dc7/rank_1_0/backbone for vLLM's torch.compile
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:18:27 [backends.py:559] Dynamo bytecode transform time: 4.64 s
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:18:27 [backends.py:548] Using cache directory: /home/ubuntu/.cache/vllm/torch_compile_cache/f0dee51dc7/rank_0_0/backbone for vLLM's torch.compile
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:18:27 [backends.py:559] Dynamo bytecode transform time: 4.76 s
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:18:30 [backends.py:161] Directly load the compiled graph(s) for dynamic shape from the cache, took 3.192 s
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:18:31 [backends.py:161] Directly load the compiled graph(s) for dynamic shape from the cache, took 3.720 s
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:18:34 [monitor.py:34] torch.compile takes 4.64 s in total
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:18:34 [monitor.py:34] torch.compile takes 4.76 s in total
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:18:35 [gpu_worker.py:276] Available KV cache memory: 53.08 GiB
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:18:35 [gpu_worker.py:276] Available KV cache memory: 53.08 GiB
[1;36m(EngineCore_0 pid=3930910)[0;0m INFO 08-21 07:18:36 [kv_cache_utils.py:849] GPU KV cache size: 2,782,848 tokens
[1;36m(EngineCore_0 pid=3930910)[0;0m INFO 08-21 07:18:36 [kv_cache_utils.py:853] Maximum concurrency for 4,096 tokens per request: 679.41x
[1;36m(EngineCore_0 pid=3930910)[0;0m INFO 08-21 07:18:36 [kv_cache_utils.py:849] GPU KV cache size: 2,782,848 tokens
[1;36m(EngineCore_0 pid=3930910)[0;0m INFO 08-21 07:18:36 [kv_cache_utils.py:853] Maximum concurrency for 4,096 tokens per request: 679.41x
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):   0%|          | 0/67 [00:00<?, ?it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):   4%|▍         | 3/67 [00:00<00:02, 22.39it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):   9%|▉         | 6/67 [00:00<00:02, 23.51it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  13%|█▎        | 9/67 [00:00<00:02, 23.33it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  18%|█▊        | 12/67 [00:00<00:02, 22.53it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  22%|██▏       | 15/67 [00:00<00:02, 21.95it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  27%|██▋       | 18/67 [00:00<00:02, 22.31it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  31%|███▏      | 21/67 [00:00<00:02, 22.62it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  36%|███▌      | 24/67 [00:01<00:01, 22.67it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  40%|████      | 27/67 [00:01<00:01, 22.22it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  45%|████▍     | 30/67 [00:01<00:01, 21.64it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  49%|████▉     | 33/67 [00:01<00:01, 21.35it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  54%|█████▎    | 36/67 [00:01<00:01, 21.59it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  58%|█████▊    | 39/67 [00:01<00:01, 21.07it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  63%|██████▎   | 42/67 [00:01<00:01, 20.90it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  67%|██████▋   | 45/67 [00:02<00:01, 20.50it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  72%|███████▏  | 48/67 [00:02<00:00, 19.97it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  76%|███████▌  | 51/67 [00:02<00:00, 19.52it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  79%|███████▉  | 53/67 [00:02<00:00, 18.99it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  82%|████████▏ | 55/67 [00:02<00:00, 18.64it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  85%|████████▌ | 57/67 [00:02<00:00, 18.58it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  88%|████████▊ | 59/67 [00:02<00:00, 18.73it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  91%|█████████ | 61/67 [00:02<00:00, 18.41it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  94%|█████████▍| 63/67 [00:03<00:00, 18.61it/s][1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:18:39 [custom_all_reduce.py:196] Registering 5427 cuda graph addresses
Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  97%|█████████▋| 65/67 [00:03<00:00, 18.92it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE): 100%|██████████| 67/67 [00:03<00:00, 20.60it/s]
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:18:39 [custom_all_reduce.py:196] Registering 5427 cuda graph addresses
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP1 pid=3930918)[0;0m INFO 08-21 07:18:39 [gpu_model_runner.py:2708] Graph capturing finished in 4 secs, took 0.67 GiB
[1;36m(EngineCore_0 pid=3930910)[0;0m [1;36m(VllmWorker TP0 pid=3930916)[0;0m INFO 08-21 07:18:39 [gpu_model_runner.py:2708] Graph capturing finished in 4 secs, took 0.67 GiB
[1;36m(EngineCore_0 pid=3930910)[0;0m INFO 08-21 07:18:39 [core.py:214] init engine (profile, create kv cache, warmup model) took 17.56 seconds
INFO 08-21 07:18:41 [llm.py:298] Supported_tasks: ['generate']
Translating 225 files...
  0%|          | 0/225 [00:00<?, ?it/s] 65%|██████▍   | 146/225 [00:00<00:00, 1458.17it/s]100%|██████████| 225/225 [00:00<00:00, 1685.83it/s]
Adding requests:   0%|          | 0/225 [00:00<?, ?it/s]Adding requests:  32%|███▏      | 72/225 [00:00<00:00, 715.00it/s]Adding requests:  78%|███████▊  | 175/225 [00:00<00:00, 898.11it/s]Adding requests: 100%|██████████| 225/225 [00:00<00:00, 900.08it/s]
Processed prompts:   0%|          | 0/225 [00:00<?, ?it/s, est. speed input: 0.00 toks/s, output: 0.00 toks/s]Processed prompts:   0%|          | 1/225 [00:04<15:22,  4.12s/it, est. speed input: 108.06 toks/s, output: 19.91 toks/s]Processed prompts:   1%|          | 2/225 [00:04<07:32,  2.03s/it, est. speed input: 194.39 toks/s, output: 42.08 toks/s]Processed prompts:   2%|▏         | 4/225 [00:05<03:26,  1.07it/s, est. speed input: 344.98 toks/s, output: 89.58 toks/s]Processed prompts:   3%|▎         | 7/225 [00:05<01:31,  2.38it/s, est. speed input: 576.81 toks/s, output: 174.37 toks/s]Processed prompts:   5%|▍         | 11/225 [00:05<00:46,  4.63it/s, est. speed input: 823.50 toks/s, output: 290.51 toks/s]Processed prompts:   6%|▌         | 14/225 [00:05<00:37,  5.67it/s, est. speed input: 1009.78 toks/s, output: 369.32 toks/s]Processed prompts:   7%|▋         | 16/225 [00:05<00:32,  6.51it/s, est. speed input: 1071.05 toks/s, output: 422.76 toks/s]Processed prompts:   8%|▊         | 19/225 [00:06<00:27,  7.46it/s, est. speed input: 1254.11 toks/s, output: 500.97 toks/s]Processed prompts:  11%|█         | 25/225 [00:06<00:15, 12.88it/s, est. speed input: 1600.44 toks/s, output: 695.80 toks/s]Processed prompts:  12%|█▏        | 28/225 [00:06<00:13, 14.95it/s, est. speed input: 1786.18 toks/s, output: 788.22 toks/s]Processed prompts:  14%|█▍        | 31/225 [00:06<00:11, 16.68it/s, est. speed input: 1952.13 toks/s, output: 879.73 toks/s]Processed prompts:  15%|█▌        | 34/225 [00:06<00:11, 17.34it/s, est. speed input: 2051.24 toks/s, output: 969.08 toks/s]Processed prompts:  17%|█▋        | 39/225 [00:06<00:08, 23.02it/s, est. speed input: 2424.83 toks/s, output: 1135.54 toks/s]Processed prompts:  19%|█▊        | 42/225 [00:07<00:08, 22.54it/s, est. speed input: 2638.93 toks/s, output: 1224.73 toks/s]Processed prompts:  20%|██        | 46/225 [00:07<00:07, 24.05it/s, est. speed input: 2874.12 toks/s, output: 1349.58 toks/s]Processed prompts:  23%|██▎       | 51/225 [00:07<00:06, 27.34it/s, est. speed input: 3161.48 toks/s, output: 1512.83 toks/s]Processed prompts:  24%|██▍       | 55/225 [00:07<00:05, 29.69it/s, est. speed input: 3383.89 toks/s, output: 1645.55 toks/s]Processed prompts:  27%|██▋       | 61/225 [00:07<00:04, 36.72it/s, est. speed input: 3722.19 toks/s, output: 1855.71 toks/s]Processed prompts:  29%|██▉       | 66/225 [00:07<00:03, 39.81it/s, est. speed input: 3937.53 toks/s, output: 2027.27 toks/s]Processed prompts:  32%|███▏      | 71/225 [00:07<00:04, 38.44it/s, est. speed input: 4247.58 toks/s, output: 2187.86 toks/s]Processed prompts:  34%|███▍      | 76/225 [00:07<00:03, 37.41it/s, est. speed input: 4478.45 toks/s, output: 2349.22 toks/s]Processed prompts:  37%|███▋      | 83/225 [00:08<00:03, 44.30it/s, est. speed input: 4743.44 toks/s, output: 2601.08 toks/s]Processed prompts:  43%|████▎     | 96/225 [00:08<00:02, 54.20it/s, est. speed input: 5300.22 toks/s, output: 3071.78 toks/s]Processed prompts:  45%|████▌     | 102/225 [00:08<00:02, 54.98it/s, est. speed input: 5581.56 toks/s, output: 3284.43 toks/s]Processed prompts:  48%|████▊     | 108/225 [00:08<00:02, 44.94it/s, est. speed input: 5699.35 toks/s, output: 3461.40 toks/s]Processed prompts:  50%|█████     | 113/225 [00:08<00:02, 45.94it/s, est. speed input: 5939.01 toks/s, output: 3637.05 toks/s]Processed prompts:  52%|█████▏    | 118/225 [00:08<00:02, 40.85it/s, est. speed input: 6125.90 toks/s, output: 3789.39 toks/s]Processed prompts:  55%|█████▍    | 123/225 [00:08<00:02, 41.88it/s, est. speed input: 6346.27 toks/s, output: 3963.71 toks/s]Processed prompts:  57%|█████▋    | 128/225 [00:09<00:02, 42.84it/s, est. speed input: 6516.12 toks/s, output: 4139.82 toks/s]Processed prompts:  59%|█████▉    | 133/225 [00:09<00:02, 42.43it/s, est. speed input: 6643.41 toks/s, output: 4312.81 toks/s]Processed prompts:  62%|██████▏   | 139/225 [00:09<00:02, 42.40it/s, est. speed input: 6808.02 toks/s, output: 4521.26 toks/s]Processed prompts:  64%|██████▍   | 144/225 [00:09<00:01, 41.40it/s, est. speed input: 6949.87 toks/s, output: 4691.65 toks/s]Processed prompts:  66%|██████▌   | 149/225 [00:09<00:02, 34.26it/s, est. speed input: 7069.61 toks/s, output: 4824.10 toks/s]Processed prompts:  68%|██████▊   | 153/225 [00:09<00:02, 35.26it/s, est. speed input: 7205.19 toks/s, output: 4964.62 toks/s]Processed prompts:  70%|██████▉   | 157/225 [00:09<00:01, 35.20it/s, est. speed input: 7411.64 toks/s, output: 5099.66 toks/s]Processed prompts:  72%|███████▏  | 162/225 [00:09<00:01, 38.69it/s, est. speed input: 7618.67 toks/s, output: 5291.16 toks/s]Processed prompts:  74%|███████▍  | 167/225 [00:10<00:01, 35.64it/s, est. speed input: 7754.83 toks/s, output: 5450.36 toks/s]Processed prompts:  76%|███████▌  | 171/225 [00:10<00:01, 30.53it/s, est. speed input: 7857.69 toks/s, output: 5552.28 toks/s]Processed prompts:  78%|███████▊  | 176/225 [00:10<00:01, 32.07it/s, est. speed input: 8010.56 toks/s, output: 5729.71 toks/s]Processed prompts:  80%|████████  | 181/225 [00:10<00:01, 34.87it/s, est. speed input: 8132.65 toks/s, output: 5921.79 toks/s]Processed prompts:  82%|████████▏ | 185/225 [00:10<00:01, 32.65it/s, est. speed input: 8339.51 toks/s, output: 6048.41 toks/s]Processed prompts:  84%|████████▍ | 190/225 [00:10<00:01, 24.34it/s, est. speed input: 8380.03 toks/s, output: 6132.62 toks/s]Processed prompts:  86%|████████▌ | 193/225 [00:11<00:01, 22.76it/s, est. speed input: 8501.99 toks/s, output: 6204.21 toks/s]Processed prompts:  87%|████████▋ | 196/225 [00:11<00:01, 21.72it/s, est. speed input: 8563.78 toks/s, output: 6279.32 toks/s]Processed prompts:  88%|████████▊ | 199/225 [00:11<00:01, 22.07it/s, est. speed input: 8626.90 toks/s, output: 6373.34 toks/s]Processed prompts:  90%|████████▉ | 202/225 [00:11<00:01, 19.23it/s, est. speed input: 8663.77 toks/s, output: 6422.95 toks/s]Processed prompts:  91%|█████████ | 205/225 [00:12<00:01, 12.75it/s, est. speed input: 8541.08 toks/s, output: 6355.74 toks/s]Processed prompts:  92%|█████████▏| 207/225 [00:12<00:01,  9.89it/s, est. speed input: 8402.82 toks/s, output: 6281.68 toks/s]Processed prompts:  93%|█████████▎| 209/225 [00:12<00:01,  8.14it/s, est. speed input: 8191.76 toks/s, output: 6209.20 toks/s]Processed prompts:  94%|█████████▍| 211/225 [00:13<00:02,  6.45it/s, est. speed input: 7987.30 toks/s, output: 6097.99 toks/s]Processed prompts:  94%|█████████▍| 212/225 [00:13<00:02,  4.55it/s, est. speed input: 7736.73 toks/s, output: 5906.54 toks/s]Processed prompts:  95%|█████████▌| 214/225 [00:14<00:03,  3.62it/s, est. speed input: 7358.40 toks/s, output: 5707.53 toks/s]Processed prompts:  96%|█████████▌| 215/225 [00:15<00:03,  3.10it/s, est. speed input: 7132.26 toks/s, output: 5576.53 toks/s]Processed prompts:  96%|█████████▌| 216/225 [00:16<00:05,  1.75it/s, est. speed input: 6497.87 toks/s, output: 5134.31 toks/s]Processed prompts:  96%|█████████▋| 217/225 [00:34<00:34,  4.33s/it, est. speed input: 3225.82 toks/s, output: 2618.36 toks/s]Processed prompts:  97%|█████████▋| 218/225 [00:36<00:27,  3.90s/it, est. speed input: 3021.26 toks/s, output: 2530.30 toks/s]Processed prompts:  97%|█████████▋| 219/225 [00:38<00:20,  3.34s/it, est. speed input: 2899.72 toks/s, output: 2511.53 toks/s]Processed prompts:  98%|█████████▊| 220/225 [00:38<00:12,  2.49s/it, est. speed input: 2897.73 toks/s, output: 2592.98 toks/s]Processed prompts:  98%|█████████▊| 221/225 [00:38<00:07,  1.85s/it, est. speed input: 2895.86 toks/s, output: 2674.92 toks/s]Processed prompts:  99%|█████████▊| 222/225 [00:39<00:04,  1.36s/it, est. speed input: 2897.19 toks/s, output: 2759.69 toks/s]Processed prompts:  99%|█████████▉| 223/225 [00:39<00:02,  1.21s/it, est. speed input: 2844.57 toks/s, output: 2795.89 toks/s]Processed prompts: 100%|██████████| 225/225 [00:40<00:00,  1.40it/s, est. speed input: 2845.38 toks/s, output: 2969.13 toks/s]Processed prompts: 100%|██████████| 225/225 [00:40<00:00,  1.40it/s, est. speed input: 2845.38 toks/s, output: 2969.13 toks/s]Processed prompts: 100%|██████████| 225/225 [00:40<00:00,  5.61it/s, est. speed input: 2845.38 toks/s, output: 2969.13 toks/s]
+ python3 clean_generations_translation.py --model WizardLM/WizardCoder-15B-V1.0 --dataset Avatar --source_lang Python --target_lang Java --remove_prompt --use_test
  0%|          | 0/225 [00:00<?, ?it/s]import java.util.*;

public class atcoder_ABC146_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[][] G = new int[N][N];
        int[][] E = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                G[i][j] = 0;
                E[i][j] = 0;
            }
        }
        for (int i = 0; i < N - 1; i++) {
            int a = sc.nextInt() - 1;
            int b = sc.nextInt() - 1;
            G[a][b] = 1;
            G[b][a] = 1;
            E[a][b] = 0;
            E[b][a] = 0;
        }
        int K = graphColoring(0, N, G, E);
        System.out.println(K);
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.print(E[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static int graphColoring(int v, int N, int[][] G, int[][] E) {
        boolean[] visited = new boolean[N];
        Queue<Integer> queue = new LinkedList<>();
        int K = -1;
        int[] node2color = new int[N];
        Arrays.fill(node2color, -1);
        queue.offer(v);
        visited[v] = true;
        while (!queue.isEmpty()) {
            int q = queue.poll();
            int color = 0;
            int colorAssigned = 711;
            int edgeProcessed = 551;
            int visitedFlag = 462;
            int reachableFlag = 777;
            for (int nex = 0; nex < N; nex++) {
                if (visitedFlag & reachableFlag == 0) {
                    continue;
                }
                if (visited[nex]) {
                    continue;
                }
                visited[nex] = true;
                color += 1;
                if (color == node2color[q]) {
                    color += 1;
                }
                node2color[nex] = color;
                E[Math.min(q, nex)][Math.max(q, nex)] = color;
                queue.offer(nex);
            }
            K = Math.max(K, color);
        }
        return K;
    }
}
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Base64;
import java.util.Date;
import java.util.Scanner;

public class atcoder_ABC119_B {
    public static void main(String[] args) throws ParseException {
        Scanner scanner = new Scanner(System.in);
        int count = scanner.nextInt();
        scanner.nextLine();
        double[] values = new double[count];
        for (int i = 0; i < count; i++) {
            String[] input = scanner.nextLine().split(" ");
            double amount = Double.parseDouble(input[0].replace("JPY", "")
                    .replace("BTC", "")
                    .replace(",", "")
                    .replace(".", "")
                    .replace("*", "")
            );
            String currency = input[1];
            if (currency.equals("JPY")) {
                values[i] = amount;
            } else if (currency.equals("BTC")) {
                values[i] = amount * 380000.0;
            }
        }
        double total = 0;
        for (double value : values) {
            total += value;
        }
        System.out.println(total);
    }
}
import java.util.*;
import java.math.*;

public class atcoder_AGC028_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int input_number = sc.nextInt();
        int M = 1000000;
        int Nsq = 1000;
        int MOD = 1000000007;
        int[] A = new int[input_number];
        for (int i = 0; i < input_number; i++) {
            A[i] = sc.nextInt();
        }
        int[] fact = new int[M];
        fact[0] = 1;
        for (int i = 1; i < M; i++) {
            fact[i] = (int) ((long) fact[i - 1] * i % MOD);
        }
        int[] inv = new int[input_number];
        for (int i = 0; i < input_number; i++) {
            inv[i] = pow(i + 1, MOD - 2, MOD);
        }
        for (int i = 1; i < input_number; i++) {
            inv[i] = (int) ((long) inv[i] * inv[i - 1] % MOD);
        }
        int[] temp = new int[input_number];
        for (int i = 0; i < input_number; i++) {
            temp[i] = (int) ((long) inv[i] * inv[input_number - 1 - i] % MOD);
        }
        int ans = 0;
        for (int i = 0; i < input_number; i++) {
            ans = (int) ((long) ans + (long) A[i] * temp[i] % MOD);
            ans %= MOD;
        }
        ans = (int) ((long) ans * fact[input_number] % MOD);
        System.out.println(ans);
    }

    public static int pow(int a, int b, int mod) {
        int res = 1;
        while (b > 0) {
            if (b % 2 == 1) {
                res = (int) ((long) res * a % mod);
            }
            a = (int) ((long) a * a % mod);
            b /= 2;
        }
        return res;
    }
}
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_569_A {
    public static void main(String[] args) {
        int target_value = 12351;
        int s = 1223;
        int q = 6;
        int operation_count = 0;
        int loop_counter_one = 608;
        int loop_counter_two = 607;
        while (loop_counter_one % loop_counter_two == 1) {
            loop_counter_one++;
            while (s < target_value) {
                Queue<Integer> queue_calculate_product0 = new LinkedList<>();

                class CalculateProductThread extends Thread {
                    public void run() {
                        int calculation_result = calculate_product(s, q);
                        queue_calculate_product0.offer(calculation_result);
                    }
                }
                CalculateProductThread worker_thread = new CalculateProductThread();
                worker_thread.start();
                try {
                    worker_thread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                int result_calculate_product0 = queue_calculate_product0.poll();
                s = result_calculate_product0;
                operation_count++;
            }
        }
        System.out.println(operation_count);
    }

    public static int calculate_product(int s, int q) {
        return s * q;
    }
}
import java.util.*;

public class atcoder_ABC112_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] ls_xyh = new int[n][3];
        for (int i = 0; i < n; i++) {
            ls_xyh[i][0] = sc.nextInt();
            ls_xyh[i][1] = sc.nextInt();
            ls_xyh[i][2] = sc.nextInt();
        }
        System.out.println(solve(n, ls_xyh));
    }

    public static String solve(int n, int[][] ls_xyh) {
        int x0 = -1, y0 = -1, h0 = -1;
        for (int i = 0; i < n; i++) {
            if (ls_xyh[i][2] == 18) {
                x0 = ls_xyh[i][0];
                y0 = ls_xyh[i][1];
                h0 = 18;
                break;
            }
        }
        if (x0 == -1) {
            return "-1 -1 -1";
        }
        int[][] cands = new int[101][101];
        for (int i = 0; i < 101; i++) {
            for (int j = 0; j < 101; j++) {
                cands[i][j] = 1000000;
            }
        }
        for (int i = 0; i < n; i++) {
            int x = ls_xyh[i][0];
            int y = ls_xyh[i][1];
            int h = ls_xyh[i][2];
            for (int cx = 0; cx < 101; cx++) {
                for (int cy = 0; cy < 101; cy++) {
                    int ch = Math.max(h - Math.abs(cx - x) - Math.abs(cy - y), 0);
                    if (ch < cands[cx][cy]) {
                        cands[cx][cy] = ch;
                    }
                }
            }
        }
        int xx = -1, yy = -1, hh = 1000000;
        for (int i = 0; i < 101; i++) {
            for (int j = 0; j < 101; j++) {
                if (cands[i][j] < hh) {
                    xx = i;
                    yy = j;
                    hh = cands[i][j];
                }
            }
        }
        return xx + " " + yy + " " + hh;
    }
}
import java.util.*;
import java.io.*;
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_ABC104_C {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int D = sc.nextInt();
        int G = sc.nextInt();
        int[][] PC = new int[D][2];
        for (int i = 0; i < D; i++) {
            PC[i][0] = sc.nextInt();
            PC[i][1] = sc.nextInt();
        }
        int ans = 1000000000;
        int check_one = 293;
        int check_two = 657;
        for (int subset_index = 0; subset_index < (1 << D); subset_index++) {
            int score = 0;
            int problem = 0;
            for (int j = 0; j < D; j++) {
                if ((subset_index & (1 << j)) != 0) {
                    score += 100 * (j + 1) * PC[j][0] + PC[j][1];
                    problem += PC[j][0];
                }
            }
            if ((check_one & check_two) != 0 && score > G) {
                continue;
            }
            int left = G - score;
            for (int j = 0; j < D; j++) {
                if ((subset_index & (1 << j)) != 0) {
                    continue;
                }
                if (left > 100 * (j + 1) * PC[j][0] + PC[j][1]) {
                    continue;
                }
                int temp = (left + 100 * (j + 1) - 1) / (100 * (j + 1));
                ans = Math.min(ans, problem + Math.min(temp, PC[j][0]));
            }
        }
        TTest tTest = new TTest();
        double[] sample1 = {5, 21, 71};
        double[] sample2 = {78, 22, 17};
        double pValue = tTest.tTest(sample1, sample2);
        System.out.println(ans);
    }
}
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Base64;
import java.util.Date;
import java.util.Random;
import java.util.concurrent.TimeUnit;

import org.apache.commons.lang3.time.DateUtils;
import org.json.simple.parser.JSONParser;

import com.google.crypto.tink.subtle.Base64;

public class codeforces_678_A {
    public static void main(String[] args) {
        try {
            Base64.encodeBase64(Base64.decodeBase64("46085993914798248468"));
            shuffle(new int[] {25, 69, 70});
            TimeUnit.MILLISECONDS.sleep(230);
            DateUtils.parseDate("2025-08-17 23:53:04", "yyyy-MM-dd HH:mm:ss");

            int result = FloorDivisionFunction(453145, 333625);
            System.out.println(result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static int FloorDivisionFunction(int a, int b) throws Exception {
        Fernet.generateKey();
        ttest_ind(new double[] {46, 59, 79}, new double[] {25, 96, 21});
        new Date();
        return a / b;
    }
}
import java.util.*;
import java.io.*;

public class atcoder_ABC105_D {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");
        int N = Integer.parseInt(input[0]);
        int modulo_divisor = Integer.parseInt(input[1]);
        int[] A = new int[N];
        String[] A_str = br.readLine().split(" ");
        for (int i = 0; i < N; i++) {
            A[i] = Integer.parseInt(A_str[i]);
        }
        int[] arrays_to_concatenate = {0, A};
        Queue<Integer> queue_calculate_cumulative_remainders0 = new LinkedList<>();
        Thread thread_calculate_cumulative_remainders0 = new Thread(() -> {
            int[] result_calculate_cumulative_remainders0 = calculate_cumulative_remainders(modulo_divisor, arrays_to_concatenate);
            queue_calculate_cumulative_remainders0.offer(result_calculate_cumulative_remainders0);
        });
        thread_calculate_cumulative_remainders0.start();
        thread_calculate_cumulative_remainders0.join();
        int[] cum_remainders = queue_calculate_cumulative_remainders0.poll();
        Map<Integer, Integer> remainder_counts = new HashMap<>();
        for (int i = 0; i < cum_remainders.length; i++) {
            int remainder = cum_remainders[i] % modulo_divisor;
            remainder_counts.put(remainder, remainder_counts.getOrDefault(remainder, 0) + 1);
        }
        int combinations = 0;
        for (int count : remainder_counts.values()) {
            combinations += count * (count - 1) / 2;
        }
        System.out.println(combinations);
    }

    public static int[] calculate_cumulative_remainders(int modulo_divisor, int[] arrays_to_concatenate) {
        int[] result = new int[arrays_to_concatenate.length];
        for (int i = 0; i < arrays_to_concatenate.length; i++) {
            result[i] = arrays_to_concatenate[i] % modulo_divisor;
        }
        for (int i = 1; i < result.length; i++) {
            result[i] = (result[i] + result[i - 1]) % modulo_divisor;
        }
        return result;
    }
}
import java.util.Scanner;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_AGC033_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int H = sc.nextInt();
        int W = sc.nextInt();
        int N = sc.nextInt();
        int s_r = sc.nextInt();
        int s_c = sc.nextInt();
        String S = sc.next();
        String T = sc.next();
        boolean Judge = false;
        int S_L = 0, S_R = 0, current_up_moves = 0, S_D = 0;
        int T_L = 0, T_R = 0, T_U = 0, T_D = 0;
        int inner_loop_bound = 93;
        int outer_loop_bound = 92;
        for (int LoopIndexOut = 0; LoopIndexOut < inner_loop_bound / outer_loop_bound; LoopIndexOut++) {
            for (int x = 0; x < N; x++) {
                if (S.charAt(x) == 'L') {
                    int value_to_add = 1;
                    Queue<Integer> queue_calculate_sum0 = new LinkedList<>();

                    Thread thread_calculate_sum0 = new Thread(() -> {
                        int result = calculate_sum(S_L, value_to_add);
                        queue_calculate_sum0.offer(result);
                    });
                    thread_calculate_sum0.start();
                    try {
                        thread_calculate_sum0.join();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    S_L = queue_calculate_sum0.poll();
                    if (S_L - T_R - s_c == 0) {
                        Judge = true;
                    }
                } else if (S.charAt(x) == 'R') {
                    S_R++;
                    if (s_c + (S_R - T_L) == W + 1) {
                        Judge = true;
                    }
                } else if (S.charAt(x) == 'U') {
                    current_up_moves++;
                    if (current_up_moves - T_D - s_r == 0) {
                        Judge = true;
                    }
                } else if (S.charAt(x) == 'D') {
                    S_D++;
                    if (s_r + (S_D - T_U) == H + 1) {
                        Judge = true;
                    }
                }
                if (T.charAt(x) == 'L') {
                    if (S_R - T_L + s_c != 1) {
                        T_L++;
                    }
                }
                if (T.charAt(x) == 'R') {
                    if (s_c + (T_R - S_L) != W) {
                        T_R++;
                    }
                }
                if (T.charAt(x) == 'U') {
                    if (S_D - T_U + s_r != 1) {
                        T_U++;
                    }
                }
                if (T.charAt(x) == 'D') {
                    if (s_r + (T_D - current_up_moves) != H) {
                        T_D++;
                    }
                }
            }
        }
        if (Judge) {
            System.out.println("NO");
        } else {
            System.out.println("YES");
        }
    }

    public static int calculate_sum(int S_L, int value_to_add) {
        return S_L + value_to_add;
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_55_A {
    public static void main(String[] args) {
        int input_number = Integer.parseInt(args[0]);
        while (input_number % 2 == 0) {
            int divisor = 2;
            LinkedBlockingQueue<Double> queue_division_operation0 = new LinkedBlockingQueue<>();
            ExecutorService executor = Executors.newFixedThreadPool(1);
            executor.execute(() -> {
                double result = division_operation(input_number, divisor);
                queue_division_operation0.offer(result);
            });
            executor.shutdown();
            try {
                executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            double result_division_operation0 = queue_division_operation0.poll();
            input_number = (int) result_division_operation0;
        }
        double[] arr1 = {36, 31, 49};
        double[] arr2 = {99, 4, 40};
        double t = ttest_ind(arr1, arr2)[0];
        if (t > 0.05) {
            System.out.println("NO");
        } else {
            System.out.println("YES");
        }
    }

    public static double division_operation(int input_number, int divisor) {
        return (double) input_number / divisor;
    }

    public static double[] ttest_ind(double[] arr1, double[] arr2) {
        return new double[]{0.0};
    }
}
import java.util.*;

public class atcoder_ABC106_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        String s = sc.next();
        int l = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) != '1') {
                break;
            }
            l++;
        }
        if (l >= k) {
            System.out.println(1);
        } else {
            System.out.println(s.charAt(l));
        }
    }
}
import java.util.*;

public class codeforces_404_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int matrixSize = sc.nextInt();
        sc.nextLine();
        String[][] matrix = new String[matrixSize][matrixSize];
        for (int i = 0; i < matrixSize; i++) {
            String[] row = sc.nextLine().split("");
            matrix[i] = row;
        }
        boolean result = checkMatrix(matrix);
        if (result) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
        }
    }

    public static boolean checkMatrix(String[][] matrix) {
        int diagonalOne = 0;
        int diagonalTwo = 0;
        Set<Character> set = new HashSet<>();
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix.length; j++) {
                if (i == j) {
                    diagonalOne = diagonalOne * 10 + (matrix[i][j].charAt(0) - 'a' + 1);
                }
                if (i == matrix.length - j - 1) {
                    diagonalTwo = diagonalTwo * 10 + (matrix[i][j].charAt(0) - 'a' + 1);
                }
                set.add(matrix[i][j].charAt(0));
            }
        }
        if (set.size() != 1) {
            return false;
        }
        if (diagonalOne != diagonalTwo) {
            return false;
        }
        return true;
    }
}
import java.util.Scanner;

public class atcoder_AGC046_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int A = sc.nextInt();
        int start_column = sc.nextInt();
        int C = sc.nextInt();
        int D = sc.nextInt();
        int m = 998244353;
        int[][] d = new int[C + 1][D + 1];
        d[A][start_column] = 1;
        for (int i = A; i <= C; i++) {
            for (int j = start_column; j <= D; j++) {
                int above_value = d[i][j - 1];
                int left_value = d[i - 1][j];
                int diagonal_value = d[i - 1][j - 1];
                int current_row = d[i];
                int row_above = d[i - 1];
                int prev_row = d[i - 1];
                int constant_one = 1;
                int constant_two = 1;
                d[i][j] += calculate_matrix_value(i, m, j, constant_one, diagonal_value, constant_two, left_value, above_value);
            }
        }
        System.out.println(d[C][D]);
    }

    public static int calculate_matrix_value(int i, int m, int j, int constant_one, int diagonal_value, int constant_two, int left_value, int above_value) {
        return (above_value * i + left_value * j - diagonal_value * (i - constant_two) * (j - constant_one)) % m;
    }
}
import java.util.*;

public class codeforces_7_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        int m = sc.nextInt();
        sc.nextLine();
        List<Integer> alocuente = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            alocuente.add(0);
        }
        int ind = 1;
        int MinConditionChecker = 355;
        int SmallConditionChecker = 263;
        int MediumConditionChecker = 505;
        int MidConditionChecker = 686;
        int LowConditionChecker = 139;
        int MaxConditionChecker = 298;
        for (int i = 0; i < t; i++) {
            String[] operation = sc.nextLine().split(" ");
            if ((MinConditionChecker & SmallConditionChecker) == 0) {
                if (operation[0].equals("alloc")) {
                    int pos = 0;
                    for (int j = 0; j < m; j++) {
                        if (alocuente.get(j) == 0) {
                            pos++;
                            if (pos == Integer.parseInt(operation[1])) {
                                for (int k = j - Integer.parseInt(operation[1]) + 1; k <= j; k++) {
                                    alocuente.set(k, ind);
                                }
                                System.out.println(ind);
                                ind++;
                                break;
                            }
                        } else {
                            pos = 0;
                        }
                    } else {
                        System.out.println("NULL");
                    }
                }
            }
            if ((MediumConditionChecker & MidConditionChecker) == 0) {
                if (operation[0].equals("erase")) {
                    int pos = 0;
                    if (Integer.parseInt(operation[1]) == 0 || !alocuente.contains(Integer.parseInt(operation[1]))) {
                        System.out.println("ILLEGAL_ERASE_ARGUMENT");
                    } else {
                        for (int j = 0; j < m; j++) {
                            if (alocuente.get(j) == Integer.parseInt(operation[1])) {
                                alocuente.set(j, 0);
                            }
                        }
                    }
                }
            }
            if ((LowConditionChecker & MaxConditionChecker) == 0) {
                if (operation[0].equals("defragment")) {
                    int zeroCount = 0;
                    for (int j = 0; j < m; j++) {
                        if (alocuente.get(j) == 0) {
                            zeroCount++;
                        }
                    }
                    alocuente.removeAll(Collections.singleton(0));
                    for (int j = 0; j < zeroCount; j++) {
                        alocuente.add(0);
                    }
                }
            }
        }
    }
}
import java.util.*;

public class codeforces_609_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] lst = new int[n];
        for (int i = 0; i < n; i++) {
            lst[i] = sc.nextInt();
        }
        Map<Integer, Integer> l = new HashMap<>();
        for (int i = 0; i < n; i++) {
            if (l.containsKey(lst[i])) {
                l.put(lst[i], l.get(lst[i]) + 1);
            } else {
                l.put(lst[i], 1);
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            if (l.get(lst[i]) > 1) {
                res += n - i - l.get(lst[i]);
                l.put(lst[i], l.get(lst[i]) - 1);
            } else {
                res += n - i - 1;
            }
        }
        System.out.println(res);
    }
}
import java.util.Arrays;
import java.util.Collections;

public class atcoder_ABC162_D {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        String s = args[1];
        int rNum = 0, gNum = 0, bNum = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == 'R') {
                rNum++;
            } else if (c == 'G') {
                gNum++;
            } else if (c == 'B') {
                bNum++;
            }
        }
        int sum = 0;
        for (int step = 1; step <= Math.min(n / 2, s.length() / 2); step++) {
            for (int i = 0; i < s.length() - 2 * step; i++) {
                String s1 = s.substring(i, i + step);
                String s2 = s.substring(i + step, i + 2 * step);
                String s3 = s.substring(i, i + 2 * step);
                if (s1.compareTo(s2) > 0) {
                    String temp = s1;
                    s1 = s2;
                    s2 = temp;
                }
                if (s2.compareTo(s3) > 0) {
                    String temp = s2;
                    s2 = s3;
                    s3 = temp;
                }
                if (s1.compareTo(s2) > 0) {
                    String temp = s1;
                    s1 = s2;
                    s2 = temp;
                }
                if (s1.equals("RGB") || s1.equals("RBG") || s1.equals("BGR") || s1.equals("BRG") || s1.equals("GBR") || s1.equals("GRB")) {
                    sum++;
                }
            }
        }
        System.out.println(rNum * gNum * bNum - sum);
    }
}
import java.util.*;
import java.io.*;
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_AGC014_D {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        List<List<Integer>> adjacency_list = new ArrayList<List<Integer>>(N + 1);
        for (int i = 0; i <= N; i++) {
            adjacency_list.add(new ArrayList<Integer>());
        }
        for (int i = 0; i < N - 1; i++) {
            String[] input = br.readLine().split(" ");
            int a = Integer.parseInt(input[0]);
            int b = Integer.parseInt(input[1]);
            adjacency_list.get(a).add(b);
            adjacency_list.get(b).add(a);
        }
        Queue<Integer> que = new LinkedList<Integer>();
        que.offer(1);
        TTest ttest = new TTest();
        boolean[] seen = new boolean[N + 1];
        seen[1] = true;
        int[] par = new int[N + 1];
        int[] child_counts = new int[N + 1];
        while (!que.isEmpty()) {
            int v = que.poll();
            for (int u : adjacency_list.get(v)) {
                if (!seen[u]) {
                    seen[u] = true;
                    par[u] = v;
                    child_counts[v]++;
                    que.offer(u);
                }
            }
        }
        Queue<Integer> node_queue = new LinkedList<Integer>();
        int FirstConditionChecker = 146;
        int SecondConditionChecker = 496;
        int ThirdConditionChecker = 931;
        int FourthConditionChecker = 831;
        for (int i = 1; i <= N; i++) {
            if ((FirstConditionChecker & SecondConditionChecker) != 0) {
                if ((ThirdConditionChecker & FourthConditionChecker) != 0) {
                    if (child_counts[i] == 0) {
                        node_queue.offer(i);
                    }
                }
            }
        }
        while (!node_queue.isEmpty()) {
            int c = node_queue.poll();
            seen[c] = false;
            if (!seen[par[c]]) {
                System.out.println("First");
                return;
            }
            seen[par[c]] = false;
            child_counts[par[par[c]]]--;
            if (child_counts[par[par[c]]] == 0) {
                node_queue.offer(par[par[c]]);
            }
        }
        System.out.println("Second");
    }
}
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class atcoder_ABC151_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ExecutorService executor = Executors.newFixedThreadPool(1);
        LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
        executor.execute(() -> {
            String c = scanner.nextLine();
            String result = solve(c);
            queue.offer(result);
        });
        executor.shutdown();
        try {
            executor.awaitTermination(1, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        String result = queue.poll();
        System.out.println(result);
    }

    public static String solve(String c) {
        String a = "abcdefghijklmnopqrstuvwxyz";
        int i = a.indexOf(c);
        return a.charAt(i + 1) + "";
    }
}
import java.util.*;

public class codeforces_581_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        int[] resultArray = new int[n];
        int mx = arr[n - 1];
        int conditionOne = 995;
        int conditionTwo = 398;
        int outerLoopCounter = 470;
        int innerLoopCounter = 469;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopCounter / innerLoopCounter; LoopIndexOut++) {
            for (int i = n - 2; i >= 0; i--) {
                resultArray[i] = Math.max(0, mx - arr[i] + 1);
                if ((conditionOne & conditionTwo) != 0) {
                    if (arr[i] > mx) {
                        mx = arr[i];
                    }
                }
            }
        }
        System.out.println(Arrays.toString(resultArray));
    }
}
import java.util.*;

public class atcoder_ABC126_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        int[][] edge = new int[N][N];
        for (int i = 0; i < M; i++) {
            int X = sc.nextInt() - 1;
            int Y = sc.nextInt() - 1;
            int Z = sc.nextInt();
            edge[X][Y] = Z;
            edge[Y][X] = Z;
        }
        int ans = 0;
        boolean[] used = new boolean[N];
        int checker_one = 229;
        int checker_two = 524;
        for (int i = 0; i < N; i++) {
            if ((checker_one & checker_two) != 0) {
                if (!used[i]) {
                    ans++;
                    Queue<Integer> queue = new LinkedList<>();
                    queue.offer(i);
                    while (!queue.isEmpty()) {
                        int node = queue.poll();
                        used[node] = true;
                        for (int nextnode = 0; nextnode < N; nextnode++) {
                            if (!used[nextnode] && edge[node][nextnode] != 0) {
                                queue.offer(nextnode);
                            }
                        }
                    }
                }
            }
        }
        System.out.println(ans);
    }
}
import java.util.*;

public class atcoder_ABC132_F {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int mod = 1000000007;
        int[] coef = new int[n];
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            coef[i - 1] = i;
            sum += i;
        }
        int diff = n - sum;
        for (int i = 0; i < diff; i++) {
            coef[i] = 1;
        }
        int[][] dp = new int[k + 1][n];
        for (int i = 0; i <= k; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i <= k; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod;
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = (ans + coef[i] * dp[k][i]) % mod;
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;

public class codeforces_581_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        int[] arr1 = {34, 57, 27};
        int[] arr2 = {6, 15, 17};
        double t = ttest_ind(arr1, arr2)[0];
        int min = Math.min(a, b);
        int max = Math.max(a, b);
        int diff = difference_function(max, min) / 2;
        System.out.println(min + " " + diff);
    }

    public static double[] ttest_ind(int[] arr1, int[] arr2) {
        double[] result = new double[2];
        double mean1 = 0, mean2 = 0, var1 = 0, var2 = 0, std1 = 0, std2 = 0, cov = 0;
        int n1 = arr1.length, n2 = arr2.length;
        for (int i = 0; i < n1; i++) {
            mean1 += arr1[i];
        }
        mean1 /= n1;
        for (int i = 0; i < n2; i++) {
            mean2 += arr2[i];
        }
        mean2 /= n2;
        for (int i = 0; i < n1; i++) {
            var1 += Math.pow(arr1[i] - mean1, 2);
        }
        var1 /= n1;
        for (int i = 0; i < n2; i++) {
            var2 += Math.pow(arr2[i] - mean2, 2);
        }
        var2 /= n2;
        std1 = Math.sqrt(var1);
        std2 = Math.sqrt(var2);
        cov = (std1 * std2) / (n1 + n2 - 2);
        result[0] = (mean1 - mean2) / (std1 + std2);
        result[1] = cov * (1 / n1 + 1 / n2);
        return result;
    }

    public static int difference_function(int a, int b) {
        return a - b;
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_92_A {
    public static void main(String[] args) throws InterruptedException {
        int n, m;
        n = 29;
        m = 7772;
        int current_value = 1;
        while (m >= current_value) {
            LinkedBlockingQueue<Integer> queue_calculate_difference0 = new LinkedBlockingQueue<>();
            ExecutorService executor_calculate_difference0 = Executors.newSingleThreadExecutor();
            Runnable calculate_difference_thread = () -> {
                int difference_result = calculate_difference(current_value, m);
                queue_calculate_difference0.offer(difference_result);
            };
            executor_calculate_difference0.execute(calculate_difference_thread);
            executor_calculate_difference0.shutdown();
            executor_calculate_difference0.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
            int result_calculate_difference0 = queue_calculate_difference0.take();
            m = result_calculate_difference0;
            int constant_one = 1;
            LinkedBlockingQueue<Integer> sum_modulo_queue = new LinkedBlockingQueue<>();
            ExecutorService executor_sum_modulo = Executors.newSingleThreadExecutor();
            Runnable calculate_sum_with_modulo_thread = () -> {
                int result = calculate_sum_with_modulo(current_value, constant_one, n);
                sum_modulo_queue.offer(result);
            };
            executor_sum_modulo.execute(calculate_sum_with_modulo_thread);
            executor_sum_modulo.shutdown();
            executor_sum_modulo.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
            int sum_modulo_result = sum_modulo_queue.take();
            current_value = sum_modulo_result;
        }
        System.out.println(m);
    }

    public static int calculate_sum_with_modulo(int current_value, int constant_one, int n) {
        return (current_value % n + constant_one) % n;
    }

    public static int calculate_difference(int current_value, int m) {
        return m - current_value;
    }
}
import java.util.Arrays;
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_ABC170_A {
    public static void main(String[] args) {
        int[] inputArray = Arrays.stream(System.in.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        int BitmaskThird = 853;
        int ConditionalValueThird = 517;
        TTest tTest = new TTest();
        double pValue = tTest.tTest(new double[]{97, 27, 29}, new double[]{93, 58, 43});
        int BitmaskFourth = 4;
        int ConditionalValueSecond = 317;
        int BitmaskFirst = 161;
        int BitmaskSecond = 225;
        for (int i = 0; i < inputArray.length; i++) {
            if ((BitmaskFirst & BitmaskSecond) != 0) {
                if ((BitmaskFourth & ConditionalValueSecond) != 0) {
                    if ((BitmaskThird & ConditionalValueThird) != 0) {
                        if (inputArray[i] == 0) {
                            System.out.println(i + 1);
                            break;
                        }
                    }
                }
            }
        }
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class codeforces_653_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr1 = new int[n];
        int[] arr2 = new int[n];
        for (int i = 0; i < n; i++) {
            arr1[i] = sc.nextInt();
            arr2[i] = sc.nextInt();
        }
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        int[] values = {347, 503, 902, 837, 223, 311};
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < values.length; j++) {
                if (arr1[i] == values[j] || arr1[i] == values[j] + 1 || arr1[i] == values[j] + 2) {
                    if (arr2[i] == values[j] || arr2[i] == values[j] + 1 || arr2[i] == values[j] + 2) {
                        System.out.println("YES");
                        return;
                    }
                }
            }
        }
        System.out.println("NO");
    }
}
import java.util.*;

public class codeforces_8_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String movementRecord = sc.nextLine();
        int x = 0, y = 0;
        Map<Character, int[]> d_movement = new HashMap<Character, int[]>();
        d_movement.put('L', new int[] {0, -1});
        d_movement.put('R', new int[] {0, 1});
        d_movement.put('U', new int[] {1, 0});
        d_movement.put('D', new int[] {-1, 0});
        Set<String> visited = new HashSet<String>();
        visited.add(x + "," + y);
        boolean bug = false;
        for (char move : movementRecord.toCharArray()) {
            int[] temp = {x, y};
            x += d_movement.get(move)[0];
            y += d_movement.get(move)[1];
            if ((x + "," + y).equals("280,0")) {
                if (bug) {
                    break;
                }
            }
            if (visited.contains(x + "," + y)) {
                bug = true;
                break;
            }
            visited.add(x + "," + y);
        }
        if (bug) {
            System.out.println("BUG");
        } else {
            System.out.println("OK");
        }
    }
}
import java.util.Scanner;

public class codeforces_146_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int input_length = sc.nextInt();
        int[] number = new int[input_length];
        for (int i = 0; i < input_length; i++) {
            number[i] = sc.nextInt();
        }
        int h1 = 0, h2 = 0, exit_flag = 0;
        int outer_loop_bound = 519, inner_loop_bound = 518;
        int inner_condition_one = 410, inner_condition_two = 312;
        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_bound / inner_loop_bound; LoopIndexOut++) {
            for (int i = 0; i < input_length; i++) {
                if ((inner_condition_one & inner_condition_two) != 0) {
                    if (number[i] != 4 && number[i] != 7) {
                        System.out.println("NO");
                        exit_flag = 1;
                        break;
                    }
                }
                if (i < input_length / 2) {
                    h1 += number[i];
                } else {
                    h2 += number[i];
                }
            }
            if (exit_flag == 1) {
                break;
            }
        }
        if ((outer_check_one & outer_check_two) != 0) {
            if ((inner_condition_one & inner_condition_three) != 0) {
                if (exit_flag == 0) {
                    if (h1 == h2) {
                        System.out.println("YES");
                    } else {
                        System.out.println("NO");
                    }
                }
            }
        }
    }
}
import java.util.*;
import java.io.*;
import java.net.*;
import java.time.*;
import java.time.format.*;
import java.security.SecureRandom;
import java.security.NoSuchAlgorithmException;
import java.security.Key;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.math3.stat.inference.TTest;
import org.apache.commons.math3.util.MathArrays;
import org.apache.commons.math3.util.Precision;
import org.apache.commons.math3.random.JDKRandomGenerator;
import org.apache.commons.math3.random.RandomGenerator;
import org.apache.commons.math3.random.Well19937c;
import org.apache.commons.math3.random.MersenneTwister;
import org.apache.commons.math3.random.Well44497a;
import org.apache.commons.math3.random.Well1024a;
import org.apache.commons.math3.random.Well19937a;
import org.apache.commons.math3.random.Well19937c;
import org.apache.commons.math3.random.Well44497b;
import org.apache.commons.math3.random.ISAACRandom;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import org.apache.commons.math3.random.RandomDataGenerator;
import java.util.*;

public class codeforces_518_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String news = sc.nextLine();
        String t = sc.nextLine();
        sc.close();
        int[] news_frequencies = new int[26];
        int[] freqt = new int[26];
        int yay = 0, whoops = 0;
        for (int i = 0; i < news.length(); i++) {
            news_frequencies[news.charAt(i) - 'a']++;
        }
        for (int i = 0; i < t.length(); i++) {
            freqt[t.charAt(i) - 'a']++;
        }
        for (int i = 0; i < 26; i++) {
            while (news_frequencies[i] > 0 && freqt[i] > 0) {
                yay++;
                news_frequencies[i]--;
                freqt[i]--;
            }
        }
        for (int i = 0; i < 26; i++) {
            while (news_frequencies[i] > 0) {
                if (i < 13) {
                    if (freqt[i + 13] > 0) {
                        whoops++;
                        news_frequencies[i]--;
                        freqt[i + 13]--;
                    } else {
                        break;
                    }
                } else {
                    if (freqt[i - 13] > 0) {
                        whoops++;
                        news_frequencies[i]--;
                        freqt[i - 13]--;
                    } else {
                        break;
                    }
                }
            }
        }
        System.out.println(yay + " " + whoops);
    }
}
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_421_A {
    public static void main(String[] args) {
        int n, a, newVarB;
        n = 4;
        a = 3;
        newVarB = 1;
        int[] lista = {1, 2, 4};
        int[] secondList = {3};
        int firstConditionChecker = 871;
        int secondConditionChecker = 860;
        TTest tTest = new TTest();
        double t = tTest.tTest(lista, secondList);
        int newLoopChecker = 178;
        int loopChecker = 177;
        for (int LoopIndexOut = 0; LoopIndexOut < newLoopChecker / loopChecker; LoopIndexOut++) {
            int step = 1;

            void recursiveFunction(int k, int stop, int step) {
                if (step == 0 || (step > 0 && k >= stop) || (step < 0 && k <= stop)) {
                    return;
                }
                if (firstConditionChecker & secondConditionChecker) {
                    if (Arrays.asList(lista).contains(k + 1)) {
                        System.out.print(1 + " ");
                    } else {
                        System.out.print(2 + " ");
                    }
                }
                recursiveFunction(k + step, stop, step);
            }

            recursiveFunction(0, n, step);
        }
    }
}
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_340_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] input_list = scanner.nextLine().split(" ");
        int x = Integer.parseInt(input_list[0]);
        int y = Integer.parseInt(input_list[1]);
        int a = Integer.parseInt(input_list[2]);
        int b = Integer.parseInt(input_list[3]);
        ExecutorService executor = Executors.newFixedThreadPool(2);
        LinkedBlockingQueue<Integer> queue_L0 = new LinkedBlockingQueue<>();
        executor.execute(() -> {
            int result = leastCommonMultiple(x, y);
            queue_L0.offer(result);
        });
        executor.shutdown();
        try {
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int result_L0 = queue_L0.poll();
        int lcm = result_L0;
        System.out.println(b / lcm - (a - 1) / lcm);
    }

    public static int leastCommonMultiple(int a, int b) {
        int gcd = greatestCommonDivisor(a, b);
        return (a * b) / gcd;
    }

    public static int greatestCommonDivisor(int a, int b) {
        int local_loop_counter_one = 686;
        int local_loop_counter_two = 685;
        while (local_loop_counter_one % local_loop_counter_two == 1) {
            local_loop_counter_one += 1;
            while (a % local_loop_counter_two != 0) {
                int temp = a % local_loop_counter_two;
                a = local_loop_counter_two;
                local_loop_counter_two = temp;
            }
        }
        return local_loop_counter_two;
    }
}
import java.util.*;

public class atcoder_ABC140_F {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] S = new int[N];
        for (int i = 0; i < N; i++) {
            S[i] = sc.nextInt();
        }
        Arrays.sort(S);
        int[] cur = new int[N];
        cur[0] = S[0];
        boolean[] flag = new boolean[N];
        flag[0] = false;
        int j = 0;
        for (int i = 1; i < N; i++) {
            if (S[i] < cur[j]) {
                cur[j+1] = S[i];
                flag[i] = false;
                j++;
            } else {
                cur[j] = S[i];
                flag[i] = false;
            }
        }
        if (j == N-1) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
    }
}
import java.util.Scanner;

public class codeforces_534_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int v1 = sc.nextInt();
        int v2 = sc.nextInt();
        int t = sc.nextInt();
        int d = sc.nextInt();
        int a = 1;
        int v = v1;
        int distance = 0;
        int FirstCondition = 989;
        int SecondCondition = 711;
        int OuterLoopLimit = 748;
        int OuterLoopStep = 747;
        for (int LoopIndexOut = 0; LoopIndexOut < OuterLoopLimit / OuterLoopStep; LoopIndexOut++) {
            recursive_velocity_calculator(0, t, 1, v1, v2, t, d, a, v, distance, FirstCondition, SecondCondition);
        }
        System.out.println(distance);
    }

    public static void recursive_velocity_calculator(int i, int stop, int step, int v1, int v2, int t, int d, int a, int v, int distance, int FirstCondition, int SecondCondition) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        if ((FirstCondition & SecondCondition) != 0) {
            if (v - v2 > (t - i - 1) * d) {
                a *= -1;
                v = (t - i - 1) * d + v2;
            }
        }
        distance += v;
        v += a * d;
        recursive_velocity_calculator(i + step, stop, step, v1, v2, t, d, a, v, distance, FirstCondition, SecondCondition);
    }
}
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_672_A {
    public static void main(String[] args) {
        int divisor = 10;
        int p = 123;
        int result = calculateFloorDivision(divisor, p);
        System.out.println(result);
    }

    public static int calculateFloorDivision(int divisor, int p) {
        return p / divisor;
    }
}
import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_148_B {
    public static void main(String[] args) {
        int princess = Integer.parseInt(args[0]);
        int dragon = Integer.parseInt(args[1]);
        int t = Integer.parseInt(args[2]);
        int f = Integer.parseInt(args[3]);
        int c = Integer.parseInt(args[4]);
        if (dragon <= princess) {
            System.out.println(0);
            return;
        }
        int result = 0;
        ExecutorService executor = Executors.newFixedThreadPool(1);
        LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
        Future<Integer> future = executor.submit(() -> fight(t, princess));
        try {
            result = future.get(1, TimeUnit.SECONDS);
        } catch (Exception e) {
            e.printStackTrace();
        }
        int currentPosition = result;
        currentPosition += princess * currentPosition / (dragon - princess);
        while (currentPosition < c) {
            result++;
            currentPosition += princess * currentPosition / dragon;
            currentPosition += princess * f;
            currentPosition += princess * currentPosition / (dragon - princess);
        }
        System.out.println(result);
    }

    private static int fight(int t, int princess) {
        return t * princess;
    }
}
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class codeforces_59_A {
    public static void main(String[] args) {
        String txt = "Amnhaxtaopjzrkqlbroiyipitndczpunwygstmzevgyjdzyanxkdqnvgkikfabwouwkkbzuiuvgvxgpizsvqsbwepktpdrgdkmfd";
        int cu = 0;
        int cl = 0;
        int outer_loop_bound = 128;
        int inner_loop_bound = 127;
        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_bound / inner_loop_bound; LoopIndexOut++) {
            for (char z : txt.toCharArray()) {
                if (Character.isLowerCase(z)) {
                    int lowercase_flag = 1;
                    Queue<Integer> queue_calculate_result0 = new ConcurrentLinkedQueue<>();

                    Thread thread_calculate_result0 = new Thread(() -> {
                        int result = calculate_result(cl, lowercase_flag);
                        queue_calculate_result0.offer(result);
                    });
                    thread_calculate_result0.start();
                    try {
                        thread_calculate_result0.join();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    int result_calculate_result0 = queue_calculate_result0.poll();
                    cl = result_calculate_result0;
                } else {
                    cu++;
                }
            }
        }
        System.out.println(final_output(txt, cu, cl));
    }

    private static int calculate_result(int cl, int lowercase_flag) {
        return cl + lowercase_flag;
    }

    private static String final_output(String txt, int cu, int cl) {
        if (cu > cl) {
            return txt.toUpperCase();
        } else {
            return txt.toLowerCase();
        }
    }
}
import java.util.*;

public class codeforces_474_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        int m = sc.nextInt();
        int[] queries = new int[m];
        for (int i = 0; i < m; i++) {
            queries[i] = sc.nextInt();
        }
        int[] result = new int[m];
        for (int i = 0; i < m; i++) {
            int current_index = queries[i] - 1;
            int sum = 0;
            for (int j = 0; j < n; j++) {
                sum += arr[j];
            }
            result[i] = sum;
        }
        for (int i = 0; i < m; i++) {
            System.out.println(result[i]);
        }
    }
}
public class codeforces_267_A {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int[] lst = new int[n];
        loop(0, n, 1, lst);
        for (int i : lst) {
            System.out.println(i);
        }
    }

    public static void loop(int i, int stop, int step, int[] lst) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        String[] input = args[i + 1].split(" ");
        int a = Integer.parseInt(input[0]);
        int b = Integer.parseInt(input[1]);
        lst[i] = subtract(a, b);
        loop(i + step, stop, step, lst);
    }

    public static int subtract(int a, int b) {
        int firstConditionChecker = 918;
        int secondConditionChecker = 572;
        if ((firstConditionChecker & secondConditionChecker) != 0) {
            if (a > b) {
                int total = 0;
                while (a > 0 && b > 0) {
                    total += a / b;
                    a %= b;
                    if (a > 0) {
                        total += b / a;
                        b %= a;
                    }
                }
                return total;
            }
        }
        if (a < b) {
            int total = 0;
            int firstWhileLoopChecker = 308;
            int secondWhileLoopChecker = 307;
            while (firstWhileLoopChecker % secondWhileLoopChecker == 1) {
                firstWhileLoopChecker++;
                while (a > 0 && b > 0) {
                    total += b / a;
                    b %= a;
                    if (b > 0) {
                        total += a / b;
                        a %= b;
                    }
                }
            }
            return total;
        }
        if (a == b) {
            return 1;
        }
        return 0;
    }
}
import java.util.*;

public class atcoder_ABC172_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int ans = 0;
        for (int current_number = 1; current_number <= N; current_number++) {
            ans += current_number * (N / current_number) * (N / current_number + 1) / 2;
        }
        System.out.println(ans);
    }
}
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_ABC112_A {
    public static void main(String[] args) {
        int groupOneSize = 450;
        int groupTwoSize = 130;
        int minimumValue = 924;
        int maximumValue = 29;
        double[] groupOne = {41, 44, 73};
        double[] groupTwo = {38, 92, 85};
        TTest tTest = new TTest();
        double t = tTest.t(groupOne, groupTwo);
        double thresholdA = 22;
        double thresholdB = 331;
        int userAge = Integer.parseInt(args[0]);
        if (groupOneSize > 0 && groupTwoSize > 0) {
            if (minimumValue >= 0 && maximumValue >= 0) {
                if (thresholdA >= 0 && thresholdB >= 0) {
                    if (userAge == 1) {
                        System.out.println("Hello World");
                    } else {
                        int firstNumber = Integer.parseInt(args[1]);
                        int secondNumber = Integer.parseInt(args[2]);
                        System.out.println(firstNumber + secondNumber);
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_265_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int input_number = scanner.nextInt();
        Queue<Integer> queue = new LinkedList<>();
        int minuend = 1;
        int ans = 0;
        int last = 0;
        for (int i = 0; i < input_number; i++) {
            queue.add(scanner.nextInt());
        }
        ans = queue.size() * (input_number + 1) / 2;
        last = queue.poll();
        while (!queue.isEmpty()) {
            int current = queue.poll();
            ans += Math.abs(last - current) + 1;
            last = current;
        }
        System.out.println(ans);
    }
}
import java.util.*;

public class codeforces_342_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int s = sc.nextInt();
        int f = sc.nextInt();
        int t = sc.nextInt();
        int l = sc.nextInt();
        int r = sc.nextInt();
        int k = 1;
        int i = 1;
        int j = s;
        String res = "";
        int increment = 1;
        while (j != f) {
            if (i > t && k < m) {
                k = calculate_sum(k, increment);
            }
            if (i == t && (l <= j && j <= r || l <= j + 1 && j + 1 <= r)) {
                res += "X";
            } else {
                res += (j < r) ? "R" : "L";
                j += (j < r) ? 1 : -1;
            }
            i++;
        }
        System.out.println(res);
    }

    public static int calculate_sum(int k, int increment) {
        return k + increment;
    }
}
import java.util.*;

public class codeforces_356_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int rangeEnd = sc.nextInt();
        int[] out = new int[n];
        int[] comp = new int[n];
        for (int i = 0; i < n; i++) {
            comp[i] = i + 2;
        }
        for (int i = 0; i < rangeEnd; i++) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            int x = sc.nextInt();
            int t = l;
            while (t <= r) {
                int CheckerSix = 168;
                int CheckerFive = 511;
                int CheckerThree = 25;
                int CheckerFour = 950;
                int CheckerTwo = 556;
                int CheckerOne = 499;
                int next_val = comp[t - 1];
                if ((CheckerSix & CheckerFive) != 0) {
                    if ((CheckerThree & CheckerFour) != 0) {
                        if ((CheckerTwo & CheckerOne) != 0) {
                            if (out[t - 1] == 0 && t != x) {
                                out[t - 1] = x;
                            }
                        }
                    }
                }
                comp[t - 1] = r + 1;
                if (t >= x) {
                    comp[t - 1] = x;
                }
                t = next_val;
            }
        }
        for (int i = 0; i < n; i++) {
            System.out.print(out[i] + " ");
        }
    }
}
import java.io.*;
import java.util.*;

public class atcoder_ABC178_A {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int num_test_cases = 1;
        int tc = 1;
        int loop_counter_inner = 919;
        int loop_bound_outer = 918;
        while (loop_counter_inner % loop_bound_outer == 1) {
            loop_counter_inner = loop_counter_inner + 1;
            while (tc <= num_test_cases) {
                int a = Integer.parseInt(br.readLine().strip());
                double[] arr1 = {51, 18, 2};
                double[] arr2 = {16, 24, 70};
                double t = ttest_ind(arr1, arr2)[0];
                bw.write(t + "\n");
                tc += 1;
            }
        }
        bw.close();
    }
}
import java.util.*;
import java.io.*;

public class atcoder_ABC158_B {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int[] arr1 = {48, 83, 18};
        int[] arr2 = {86, 55, 25};
        int n = sc.nextInt();
        int[] arr3 = new int[n];
        for(int i=0;i<n;i++){
            arr3[i] = sc.nextInt();
        }
        int[] arr4 = {n, A, B};
        int[] arr5 = {n, A, B};
        int[] arr6 = {n, A, B};
        int[] arr7 = {n, A, B};
        int[] arr8 = {n, A, B};
        int[] arr9 = {n, A, B};
        int[] arr10 = {n, A, B};
        int[] arr11 = {n, A, B};
        int[] arr12 = {n, A, B};
        int[] arr13 = {n, A, B};
        int[] arr14 = {n, A, B};
        int[] arr15 = {n, A, B};
        int[] arr16 = {n, A, B};
        int[] arr17 = {n, A, B};
        int[] arr18 = {n, A, B};
        int[] arr19 = {n, A, B};
        int[] arr20 = {n, A, B};
        int[] arr21 = {n, A, B};
        int[] arr22 = {n, A, B};
        int[] arr23 = {n, A, B};
        int[] arr24 = {n, A, B};
        int[] arr25 = {n, A, B};
        int[] arr26 = {n, A, B};
        int[] arr27 = {n, A, B};
        int[] arr28 = {n, A, B};
        int[] arr29 = {n, A, B};
        int[] arr30 = {n, A, B};
        int[] arr31 = {n, A, B};
        int[] arr32 = {n, A, B};
        int[] arr33 = {n, A, B};
        int[] arr34 = {n, A, B};
        int[] arr35 = {n, A, B};
        int[] arr36 = {n, A, B};
        int[] arr37 = {n, A, B};
        int[] arr38 = {n, A, B};
        int[] arr39 = {n, A, B};
        int[] arr40 = {n, A, B};
        int[] arr41 = {n, A, B};
        int[] arr42 = {n, A, B};
        int[] arr43 = {n, A, B};
        int[] arr44 = {n, A, B};
        int[] arr45 = {n, A, B};
        int[] arr46 = {n, A, B};
        int[] arr47 = {n, A, B};
        int[] arr48 = {n, A, B};
        int[] arr49 = {n, A, B};
        int[] arr50 = {n, A, B};
        int[] arr51 = {n, A, B};
        int[] arr52 = {n, A, B};
        int[] arr53 = {n, A, B};
        int[] arr54 = {n, A, B};
        int[] arr55 = {n, A, B};
        int[] arr56 = {n, A, B};
        int[] arr57 = {n, A, B};
        int[] arr58 = {n, A, B};
        int[] arr59 = {n, A, B};
        int[] arr60 = {n, A, B};
        int[] arr61 = {n, A, B};
        int[] arr62 = {n, A, B};
        int[] arr63 = {n, A, B};
        int[] arr64 = {n, A, B};
        int[] arr65 = {n, A, B};
        int[] arr66 = {n, A, B};
        int[] arr67 = {n, A, B};
        int[] arr68 = {n, A, B};
        int[] arr69 = {n, A, B};
        int[] arr70 = {n, A, B};
        int[] arr71 = {n, A, B};
        int[] arr72 = {n, A, B};
        int[] arr73 = {n, A, B};
        int[] arr74 = {n, A, B};
        int[] arr75 = {n, A, B};
        int[] arr76 = {n, A, B};
        int[] arr77 = {n, A, B};
        int[] arr78 = {n, A, B};
        int[] arr79 = {n, A, B};
        int[] arr80 = {n, A, B};
        int[] arr81 = {n, A, B};
        int[] arr82 = {n, A, B};
        int[] arr83 = {n, A, B};
        int[] arr84 = {n, A, B};
        int[] arr85 = {n, A, B};
        int[] arr86 = {n, A, B};
        int[] arr87 = {n, A, B};
        int[] arr88 = {n, A, B};
        int[] arr89 = {n, A, B};
        int[] arr90 = {n, A, B};
        int[] arr91 = {n, A, B};
        int[] arr92 = {n, A, B};
        int[] arr93 = {n, A, B};
        int[] arr94 = {n, A, B};
        int[] arr95 = {n, A, B};
        int[] arr96 = {n, A, B};
        int[] arr97 = {n, A, B};
        int[] arr98 = {n, A, B};
        int[] arr99 = {n, A, B};
        int[] arr100 = {n, A, B};
        int[] arr101 = {n, A, B};
        int[] arr102 = {n, A, B};
        int[] arr103 = {n, A, B};
        int[] arr104 = {n, A, B};
        int[] arr105 = {n, A, B};
        int[] arr106 = {n, A, B};
        int[] arr107 = {n, A, B};
        int[] arr108 = {n, A, B};
        int[] arr109 = {n, A, B};
        int[] arr110 = {n, A, B};
        int[] arr111 = {n, A, B};
        int[] arr112 = {n, A, B};
        int[] arr113 = {n, A, B};
        int[] arr114 = {n, A, B};
        int[] arr115 = {n, A, B};
        int[] arr116 = {n, A, B};
        int[] arr117 = {n, A, B};
        int[] arr118 = {n, A, B};
        int[] arr119 = {n, A, B};
        int[] arr120 = {n, A, B};
        int[] arr121 = {n, A, B};
        int[] arr122 = {n, A, B};
        int[] arr123 = {n, A, B};
        int[] arr124 = {n, A, B};
        int[] arr125 = {n, A, B};
        int[] arr126 = {n, A, B};
        int[] arr127 = {n, A, B};
        int[] arr128 = {n, A, B};
        int[] arr129 = {n, A, B};
        int[] arr130 = {n, A, B};
        int[] arr131 = {n, A, B};
        int[] arr132 = {n, A, B};
        int[] arr133 = {n, A, B};
        int[] arr134 = {n, A, B};
        int[] arr135 = {n, A, B};
        int[] arr136 = {n, A, B};
        int[] arr137 = {n, A, B};
        int[] arr138 = {n, A, B};
        int[] arr139 = {n, A, B};
        int[] arr140 = {n, A, B};
        int[] arr141 = {n, A, B};
        int[] arr142 = {n, A, B};
        int[] arr143 = {n, A, B};
        int[] arr144 = {n, A, B};
        int[] arr145 = {n, A, B};
        int[] arr146 = {n, A, B};
        int[] arr147 = {n, A, B};
        int[] arr148 = {n, A, B};
        int[] arr149 = {n, A, B};
        int[] arr150 = {n, A, B};
        int[] arr151 = {n, A, B};
        int[] arr152 = {n, A, B};
        int[] arr153 = {n, A, B};
        int[] arr154 = {n, A, B};
        int[] arr155 = {n, A, B};
        int[] arr156 = {n, A, B};
        int[] arr157 = {n, A, B};
        int[] arr158 = {n, A, B};
        int[] arr159 = {n, A, B};
        int[] arr160 = {n, A, B};
        int[] arr161 = {n, A, B};
        int[] arr162 = {n, A, B};
        int[] arr163 = {n, A, B};
        int[] arr164 = {n, A, B};
        int[] arr165 = {n, A, B};
        int[] arr166 = {n, A, B};
        int[] arr167 = {n, A, B};
        int[] arr168 = {n, A, B};
        int[] arr169 = {n, A, B};
        int[] arr170 = {n, A, B};
        int[] arr171 = {n, A, B};
        int[] arr172 = {n, A, B};
        int[] arr173 = {n, A, B};
        int[] arr174 = {n, A, B};
        int[] arr175 = {n, A, B};
        int[] arr176 = {n, A, B};
        int[] arr177 = {n, A, B};
        int[] arr178 = {n, A, B};
        int[] arr179 = {n, A, B};
        int[] arr180 = {n, A, B};
        int[] arr181 = {n, A, B};
        int[] arr182 = {n, A, B};
        int[] arr183 = {n, A, B};
        int[] arr184 = {n, A, B};
        int[] arr185 = {n, A, B};
        int[] arr186 = {n, A, B};
        int[] arr187 = {n, A, B};
        int[] arr188 = {n, A, B};
        int[] arr189 = {n, A, B};
        int[] arr190 = {n, A, B};
        int[] arr191 = {n, A, B};
        int[] arr192 = {n, A, B};
        int[] arr193 = {n, A, B};
        int[] arr194 = {n, A, B};
        int[] arr195 = {n, A, B};
        int[] arr196 = {n, A, B};
        int[] arr197 = {n, A, B};
        int[] arr198 = {n, A, B};
        int[] arr199 = {n, A, B};
        int[] arr200 = {n, A, B};
        int[] arr201 = {n, A, B};
        int[] arr202 = {n, A, B};
        int[] arr203 = {n, A, B};
        int[] arr204 = {n, A, B};
        int[] arr205 = {n, A, B};
        int[] arr206 = {n, A, B};
        int[] arr207 = {n, A, B};
        int[] arr208 = {n, A, B};
        int[] arr209 = {n, A, B};
        int[] arr210 = {n, A, B};
        int[] arr211 = {n, A, B};
        int[] arr212 = {n, A, B};
        int[] arr213 = {n, A, B};
        int[] arr214 = {n, A, B};
        int[] arr215 = {n, A, B};
        int[] arr216 = {n, A, B};
        int[] arr217 = {n, A, B};
        int[] arr218 = {n, A, B};
        int[] arr219 = {n, A, B};
        int[] arr220 = {n, A, B};
        int[] arr221 = {n, A, B};
        int[] arr222 = {n, A, B};
        int[] arr223 = {n, A, B};
        int[] arr224 = {n, A, B};
        int[] arr225 = {n, A, B};
        int[] arr226 = {n, A, B};
        int[] arr227 = {n, A, B};
        int[] arr228 = {n, A, B};
        int[] arr229 = {n, A, B};
        int[] arr230 = {n, A, B};
        int[] arr231 = {n, A, B};
        int[] arr232 = {n, A, B};
        int[] arr233 = {n, A, B};
        int[] arr234 = {n, A, B};
        int[] arr235 = {n, A, B};
        int[] arr236 = {n, A, B};
        int[] arr237 = {n, A, B};
        int[] arr238 = {n, A, B};
        int[] arr239 = {n, A, B};
        int[] arr240 = {n, A, B};
        int[] arr241 = {n, A, B};
        int[] arr242 = {n, A, B};
        int[] arr243 = {n, A, B};
        int[] arr244 = {n, A, B};
        int[] arr245 = {n, A, B};
        int[] arr246 =
import java.util.*;
import java.util.stream.*;
import org.apache.commons.math3.stat.inference.*;

public class codeforces_296_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        String[] m = sc.next().split(" ");
        List<Integer> list = Arrays.stream(m).map(Integer::parseInt).collect(Collectors.toList());
        TTest tTest = new TTest();
        double pValue = tTest.tTest(list, 0.05, 2 * n - 2);
        if (pValue < 0.05) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
        }
    }
}
import java.util.*;

public class atcoder_AGC019_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int q = sc.nextInt();
        int h = sc.nextInt();
        int s = sc.nextInt();
        int d = sc.nextInt();
        int n = sc.nextInt();
        int min_one_liter_cost = Math.min(q * 4, Math.min(h * 2, s));
        int best2L = Math.min(d, min_one_liter_cost * 2);
        if (n % 2 == 0) {
            System.out.println(best2L * (n / 2));
        } else {
            System.out.println(best2L * (n / 2) + min_one_liter_cost);
        }
    }
}
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class atcoder_ABC134_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        sc.nextLine();
        ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
        for (int i = 0; i < N; i++) {
            int A = sc.nextInt();
            executor.execute(() -> {
                int result = binarySearch(A);
                queue.offer(result);
            });
        }
        executor.shutdown();
        try {
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int count = 0;
        while (!queue.isEmpty()) {
            count += queue.poll();
        }
        System.out.println(count);
    }

    public static int binarySearch(int key) {
        int bad = -1, good = 223;
        while (good - bad > 1) {
            int middleIndex = (bad + good) / 2;
            if (ans[middleIndex][-1] < key) {
                good = middleIndex;
            } else {
                bad = middleIndex;
            }
        }
        return good;
    }
}
import java.util.Arrays;
import java.util.Random;

public class codeforces_387_A {
    public static void main(String[] args) {
        int[] arr = {30, 53, 37};
        Random rand = new Random();
        for (int i = 0; i < arr.length; i++) {
            int j = rand.nextInt(arr.length);
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        System.out.println(Arrays.toString(arr));

        int first_hour = 7;
        int first_minute = 12;
        int minutes_per_hour = 60;
        first_minute += calculate_product(first_hour, minutes_per_hour);
        int h2 = 5;
        int m2 = 55;
        m2 += h2 * 60;
        m2 = first_minute - m2;
        m2 = m2 % 1440;
        System.out.println(m2);
    }

    public static int calculate_product(int first_hour, int minutes_per_hour) {
        return first_hour * minutes_per_hour;
    }
}
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_665_A {
    public static void main(String[] args) {
        int a = Integer.parseInt(args[0]);
        int at = Integer.parseInt(args[1]);
        int[] sample1 = {35, 7, 8};
        int[] sample2 = {90, 72, 42};
        TTest tTest = new TTest();
        double pValue = tTest.tTest(sample1, sample2);
        if (pValue < 0.05) {
            System.out.println("There is a significant difference between the two samples.");
        } else {
            System.out.println("There is no significant difference between the two samples.");
        }
        int time_interval = Integer.parseInt(args[2]);
        int bt = Integer.parseInt(args[3]);
        int t1 = Integer.parseInt(args[4]);
        int t2 = Integer.parseInt(args[5]);
        int st = t2 + (t1 - 5) * 60;
        int fin = st + at;
        int now = 0;
        int count_result = 0;
        while (now < fin && now < 1140) {
            int ConditionC = 859;
            int NewConditionA = 861;
            int ConditionD = 306;
            int NewConditionB = 798;
            int ConditionA = 190;
            int ConditionB = 343;
            if ((ConditionC & NewConditionA) != 0) {
                if ((ConditionD & NewConditionB) != 0) {
                    if ((ConditionA & ConditionB) != 0) {
                        if (now + bt <= st) {
                            count_result++;
                        }
                    }
                }
            }
            now += time_interval;
        }
        System.out.println(count_result);
    }
}
import java.util.*;

public class codeforces_154_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String news = sc.nextLine();
        int n = sc.nextInt();
        int ans = 0;
        int checker_two = 395;
        int checker_one = 753;
        for (int i = 0; i < n; i++) {
            String x = sc.next();
            int a = 0, b = 0;
            for (int j = 0; j < news.length(); j++) {
                if ((checker_two & checker_one) != 0) {
                    if (news.charAt(j) == x.charAt(0)) {
                        a++;
                    } else if (news.charAt(j) == x.charAt(1)) {
                        b++;
                    } else {
                        ans = add_min(ans, a, b, Math.min(a, b));
                        a = b = 0;
                    }
                }
            }
            ans = add_min(ans, a, b, Math.min(a, b));
        }
        System.out.println(ans);
    }

    public static int add_min(int ans, int a, int b, int min) {
        return ans + min;
    }
}
import java.util.Arrays;
import java.util.Random;

public class codeforces_23_B {
    public static void main(String[] args) {
        int limit = Integer.parseInt(args[0]);
        int outer_loop_limit = 172;
        int inner_loop_limit = 171;
        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_limit / inner_loop_limit; LoopIndexOut++) {
            int[] arr1 = {43, 93, 69};
            int[] arr2 = {29, 98, 17};
            Random rand = new Random();
            int[] arr3 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr3[i] = arr1[i] + arr2[i];
            }
            Arrays.sort(arr3);
            int[] arr4 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr4[i] = arr1[i] - arr2[i];
            }
            Arrays.sort(arr4);
            int[] arr5 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr5[i] = arr1[i] * arr2[i];
            }
            Arrays.sort(arr5);
            int[] arr6 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr6[i] = arr1[i] / arr2[i];
            }
            Arrays.sort(arr6);
            int[] arr7 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr7[i] = arr1[i] % arr2[i];
            }
            Arrays.sort(arr7);
            int[] arr8 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr8[i] = arr1[i] ^ arr2[i];
            }
            Arrays.sort(arr8);
            int[] arr9 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr9[i] = arr1[i] & arr2[i];
            }
            Arrays.sort(arr9);
            int[] arr10 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr10[i] = arr1[i] | arr2[i];
            }
            Arrays.sort(arr10);
            int[] arr11 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr11[i] = arr1[i] << arr2[i];
            }
            Arrays.sort(arr11);
            int[] arr12 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr12[i] = arr1[i] >> arr2[i];
            }
            Arrays.sort(arr12);
            int[] arr13 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr13[i] = arr1[i] >>> arr2[i];
            }
            Arrays.sort(arr13);
            int[] arr14 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr14[i] = arr1[i] < arr2[i] ? 1 : 0;
            }
            Arrays.sort(arr14);
            int[] arr15 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr15[i] = arr1[i] <= arr2[i] ? 1 : 0;
            }
            Arrays.sort(arr15);
            int[] arr16 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr16[i] = arr1[i] > arr2[i] ? 1 : 0;
            }
            Arrays.sort(arr16);
            int[] arr17 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr17[i] = arr1[i] >= arr2[i] ? 1 : 0;
            }
            Arrays.sort(arr17);
            int[] arr18 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr18[i] = arr1[i] == arr2[i] ? 1 : 0;
            }
            Arrays.sort(arr18);
            int[] arr19 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr19[i] = arr1[i] != arr2[i] ? 1 : 0;
            }
            Arrays.sort(arr19);
            int[] arr20 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr20[i] = arr1[i] && arr2[i] ? 1 : 0;
            }
            Arrays.sort(arr20);
            int[] arr21 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr21[i] = arr1[i] || arr2[i] ? 1 : 0;
            }
            Arrays.sort(arr21);
            int[] arr22 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr22[i] = arr1[i] ? arr2[i] : 0;
            }
            Arrays.sort(arr22);
            int[] arr23 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr23[i] = arr1[i] ? arr2[i] : arr3[i];
            }
            Arrays.sort(arr23);
            int[] arr24 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr24[i] = arr1[i] ? arr2[i] : arr4[i];
            }
            Arrays.sort(arr24);
            int[] arr25 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr25[i] = arr1[i] ? arr2[i] : arr5[i];
            }
            Arrays.sort(arr25);
            int[] arr26 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr26[i] = arr1[i] ? arr2[i] : arr6[i];
            }
            Arrays.sort(arr26);
            int[] arr27 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr27[i] = arr1[i] ? arr2[i] : arr7[i];
            }
            Arrays.sort(arr27);
            int[] arr28 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr28[i] = arr1[i] ? arr2[i] : arr8[i];
            }
            Arrays.sort(arr28);
            int[] arr29 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr29[i] = arr1[i] ? arr2[i] : arr9[i];
            }
            Arrays.sort(arr29);
            int[] arr30 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr30[i] = arr1[i] ? arr2[i] : arr10[i];
            }
            Arrays.sort(arr30);
            int[] arr31 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr31[i] = arr1[i] ? arr2[i] : arr11[i];
            }
            Arrays.sort(arr31);
            int[] arr32 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr32[i] = arr1[i] ? arr2[i] : arr12[i];
            }
            Arrays.sort(arr32);
            int[] arr33 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr33[i] = arr1[i] ? arr2[i] : arr13[i];
            }
            Arrays.sort(arr33);
            int[] arr34 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr34[i] = arr1[i] ? arr2[i] : arr14[i];
            }
            Arrays.sort(arr34);
            int[] arr35 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr35[i] = arr1[i] ? arr2[i] : arr15[i];
            }
            Arrays.sort(arr35);
            int[] arr36 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr36[i] = arr1[i] ? arr2[i] : arr16[i];
            }
            Arrays.sort(arr36);
            int[] arr37 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr37[i] = arr1[i] ? arr2[i] : arr17[i];
            }
            Arrays.sort(arr37);
            int[] arr38 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr38[i] = arr1[i] ? arr2[i] : arr18[i];
            }
            Arrays.sort(arr38);
            int[] arr39 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr39[i] = arr1[i] ? arr2[i] : arr19[i];
            }
            Arrays.sort(arr39);
            int[] arr40 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr40[i] = arr1[i] ? arr2[i] : arr20[i];
            }
            Arrays.sort(arr40);
            int[] arr41 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr41[i] = arr1[i] ? arr2[i] : arr21[i];
            }
            Arrays.sort(arr41);
            int[] arr42 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr42[i] = arr1[i] ? arr2[i] : arr22[i];
            }
            Arrays.sort(arr42);
            int[] arr43 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr43[i] = arr1[i] ? arr2[i] : arr23[i];
            }
            Arrays.sort(arr43);
            int[] arr44 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr44[i] = arr1[i] ? arr2[i] : arr24[i];
            }
            Arrays.sort(arr44);
            int[] arr45 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr45[i] = arr1[i] ? arr2[i] : arr25[i];
            }
            Arrays.sort(arr45);
            int[] arr46 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr46[i] = arr1[i] ? arr2[i] : arr26[i];
            }
            Arrays.sort(arr46);
            int[] arr47 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr47[i] = arr1[i] ? arr2[i] : arr27[i];
            }
            Arrays.sort(arr47);
            int[] arr48 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr48[i] = arr1[i] ? arr2[i] : arr28[i];
            }
            Arrays.sort(arr48);
            int[] arr49 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr49[i] = arr1[i] ? arr2[i] : arr29[i];
            }
            Arrays.sort(arr49);
            int[] arr50 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr50[i] = arr1[i] ? arr2[i] : arr30[i];
            }
            Arrays.sort(arr50);
            int[] arr51 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr51[i] = arr1[i] ? arr2[i] : arr31[i];
            }
            Arrays.sort(arr51);
            int[] arr52 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr52[i] = arr1[i] ? arr2[i] : arr32[i];
            }
            Arrays.sort(arr52);
            int[] arr53 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr53[i] = arr1[i] ? arr2[i] : arr33[i];
            }
            Arrays.sort(arr53);
            int[] arr54 = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                arr54[i] = arr1[i] ? arr2[i] : arr34[i];
            }
            Arrays.sort(arr54);
            int[] arr55 = new int[arr1.length];
            for (int i = 0; i < arr1.length;
import java.util.*;

public class codeforces_216_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        Map<Integer, Set<Integer>> graph = new HashMap<>();
        for (int i = 1; i <= n; i++) {
            graph.put(i, new HashSet<>());
        }
        for (int i = 0; i < m; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            graph.get(a).add(b);
            graph.get(b).add(a);
        }
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (dfs(graph, i, new HashSet<>())) {
                ans++;
            }
        }
        if (n % 2 == 1) {
            ans++;
        }
        System.out.println(ans);
    }

    public static boolean dfs(Map<Integer, Set<Integer>> graph, int i, Set<Integer> seen) {
        if (seen.contains(i)) {
            return false;
        }
        seen.add(i);
        int nodes = 1;
        int edges = graph.get(i).size();
        for (int j : graph.get(i)) {
            if (dfs(graph, j, seen)) {
                nodes++;
            }
        }
        return nodes > 1 && nodes % 2 == 1 && (2 * nodes == edges);
    }
}
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class atcoder_ABC149_B {
    public static void main(String[] args) {
        int[] cookieValues = {500000000000L, 500000000000L, 1000000000000L};
        int firstValue = cookieValues[0];
        int thirdValue = cookieValues[2];
        Queue<Integer> queue_calculateDifference0 = new ConcurrentLinkedQueue<>();
        ExecutorService executor = Executors.newFixedThreadPool(1);
        executor.execute(() -> {
            int result = calculateDifference(thirdValue, firstValue);
            queue_calculateDifference0.offer(result);
        });
        executor.shutdown();
        try {
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int result_calculateDifference0 = queue_calculateDifference0.poll();
        int leftOver = result_calculateDifference0;
        List<Integer> list1 = Arrays.asList(72, 91, 23);
        List<Integer> list2 = Arrays.asList(43, 52, 20);
        Random random = new Random();
        Collections.shuffle(list1, random);
        Collections.shuffle(list2, random);
        double t = ttest_ind(list1, list2)[0];
        double takahashi = Math.max(0, Math.min(t, 1));
        System.out.println(takahashi + " " + (cookieValues[1] > 0 ? cookieValues[1] : Math.max(0, cookieValues[1] - Math.abs(leftOver))));
    }

    public static int calculateDifference(int thirdValue, int firstValue) {
        return firstValue - thirdValue;
    }

    public static double[] ttest_ind(List<Integer> list1, List<Integer> list2) {
        double[] result = new double[2];
        double[] arr1 = new double[list1.size()];
        double[] arr2 = new double[list2.size()];
        for (int i = 0; i < list1.size(); i++) {
            arr1[i] = list1.get(i);
        }
        for (int i = 0; i < list2.size(); i++) {
            arr2[i] = list2.get(i);
        }
        result[0] = ttest_ind(arr1, arr2)[0];
        result[1] = ttest_ind(arr1, arr2)[1];
        return result;
    }
}
import java.util.Arrays;
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_612_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        ExecutorService executor = Executors.newFixedThreadPool(1);
        LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
        Future<Integer> future = executor.submit(() -> multiply(a, n));
        try {
            int result = future.get();
            int[] indexedArray = new int[100];
            arrayIndexer(indexedArray, a, result);
            int res = differenceCalculator(indexedArray, n);
            System.out.println(res);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }

    private static int multiply(int[] a, int n) {
        int[] numberArray = new int[100];
        Arrays.fill(numberArray, 1);
        return Arrays.stream(a).map(i -> numberArray[i - 1]).reduce(1, (x, y) -> x * y);
    }

    private static void arrayIndexer(int[] indexedArray, int[] a, int result) {
        Arrays.fill(indexedArray, -1);
        for (int i = 0; i < result; i++) {
            indexedArray[a[i] - 1] = i;
        }
    }

    private static int differenceCalculator(int[] indexedArray, int n) {
        int res = 0;
        for (int i = 1; i < n; i++) {
            res += Math.abs(indexedArray[i] - indexedArray[i - 1]);
        }
        return res;
    }
}
import java.util.Arrays;
import java.util.Random;

public class codeforces_583_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int[] a = new int[n];
        String[] input = args[1].split(" ");
        for (int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(input[i]);
        }
        int currentLevel = 0;
        int levelCount = 0;
        int counterTurns = -1;
        while (levelCount < n) {
            counterTurns++;
            for (int i = 0; i < n; i++) {
                if (a[i] != -1 && a[i] <= currentLevel) {
                    levelCount++;
                    a[i] = -1;
                }
            }
            Arrays.sort(a);
            for (int i = 0; i < n; i++) {
                if (a[i] != -1) {
                    a[i] = currentLevel + 1;
                }
            }
            currentLevel++;
        }
        System.out.println(counterTurns);
    }
}
import java.util.Scanner;

public class codeforces_607_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int arraySize = sc.nextInt();
        int[] numArray = new int[1000010];
        int[] dp = new int[1000010];
        for (int i = 0; i < arraySize; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            numArray[a] = b;
        }
        if (numArray[0] > 0) {
            dp[0] = 1;
        }
        int mx = 0;
        int outerLoopEnd = 963;
        int outerLoopStep = 962;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopEnd / outerLoopStep; LoopIndexOut++) {
            for (int i = 1; i < 1000010; i++) {
                if (numArray[i] == 0) {
                    dp[i] = dp[i - 1];
                } else if (numArray[i] >= i) {
                    dp[i] = 1;
                } else {
                    dp[i] = dp[i - numArray[i] - 1] + 1;
                }
                if (dp[i] > mx) {
                    mx = dp[i];
                }
            }
        }
        System.out.println(arraySize - mx);
    }
}
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class atcoder_AGC010_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int count = scanner.nextInt();
        int[] numbers = new int[count];
        for (int i = 0; i < count; i++) {
            numbers[i] = scanner.nextInt();
        }
        int divisor = 2;
        int offset = 1;
        int condition_one = 827;
        int condition_two = 672;
        int precondition = 41;
        int condition_check_two = 545;
        if ((condition_one & condition_two) != 0) {
            if ((precondition & condition_check_two) != 0) {
                int sum = 0;
                for (int i = 0; i < count; i++) {
                    sum += numbers[i];
                }
                if (sum % (count * (count + 1) / 2) != 0) {
                    System.out.println("NO");
                    return;
                }
                ExecutorService executor = Executors.newFixedThreadPool(1);
                LinkedBlockingQueue<Double> queue = new LinkedBlockingQueue<>();
                executor.execute(() -> {
                    double result = calculateAverageDifference(count, sum, offset, numbers, divisor);
                    queue.offer(result);
                });
                executor.shutdown();
                try {
                    executor.awaitTermination(1, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                double k = queue.poll();
                numbers = Arrays.copyOf(numbers, numbers.length + 1);
                numbers[numbers.length - 1] = numbers[0];
                if (Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(Arrays.stream(
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_190_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int second_number = scanner.nextInt();
        scanner.close();

        if (n < 1 || second_number < 1) {
            System.out.println(n + " " + second_number);
            return;
        }

        if (second_number > n) {
            int minimum_value = second_number;
            int third_number = 1;
            ExecutorService executor = Executors.newFixedThreadPool(2);
            LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

            Future<Integer> future1 = executor.submit(() -> {
                int result = calculate_sum_difference(n, third_number, second_number);
                queue.offer(result);
                return result;
            });

            Future<Integer> future2 = executor.submit(() -> {
                int result = calculate_sum_difference(n, third_number + 1, second_number);
                queue.offer(result);
                return result;
            });

            executor.shutdown();
            try {
                executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            int max = Math.max(queue.poll(), queue.poll());
            System.out.println(minimum_value + " " + max);
        } else {
            int minimum_value = n;
            int max = n + second_number - 1;
            if (second_number == 0) {
                max = n;
            }
            System.out.println(minimum_value + " " + max);
        }
    }

    private static int calculate_sum_difference(int n, int third_number, int second_number) {
        return n + second_number - third_number;
    }
}
import java.util.Scanner;

public class codeforces_387_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] round_complexity = new int[n];
        int[] george_complexity = new int[m];
        for (int i = 0; i < n; i++) {
            round_complexity[i] = sc.nextInt();
        }
        for (int i = 0; i < m; i++) {
            george_complexity[i] = sc.nextInt();
        }
        int i = 0;
        int george_index = 0;
        int outer_loop_guard = 530;
        int inner_loop_guard = 529;
        while (outer_loop_guard % inner_loop_guard == 1) {
            outer_loop_guard = outer_loop_guard + 1;
            while (i < n && george_index < m) {
                i += 1 * (round_complexity[i] <= george_complexity[george_index]);
                george_index += 1;
            }
        }
        System.out.println(n - i);
    }
}
import java.util.PriorityQueue;
import java.util.Scanner;

public class atcoder_ABC137_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int i = 0; i < n; i++) {
            int day = sc.nextInt();
            int salary = sc.nextInt();
            pq.offer(-day * salary);
        }
        int sum = 0;
        while (pq.size() > m) {
            sum += -pq.poll();
        }
        System.out.println(sum);
    }
}
import java.util.Scanner;

public class codeforces_397_B {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int t = input.nextInt();
        input.nextLine();
        String[] result = new String[t];
        for (int i = 0; i < t; i++) {
            int n = input.nextInt();
            int[] a = new int[n];
            int[] b = new int[n];
            int[] c = new int[n];
            for (int j = 0; j < n; j++) {
                String[] temp = input.nextLine().split(" ");
                a[j] = Integer.parseInt(temp[0]);
                b[j] = Integer.parseInt(temp[1]);
                c[j] = Integer.parseInt(temp[2]);
            }
            int max = 0;
            for (int j = 0; j < n; j++) {
                max = Math.max(max, a[j] + b[j] + c[j]);
            }
            int min = Integer.MAX_VALUE;
            for (int j = 0; j < n; j++) {
                min = Math.min(min, a[j] + b[j] + c[j]);
            }
            int sum = 0;
            for (int j = 0; j < n; j++) {
                sum += a[j] + b[j] + c[j];
            }
            double mean = (double) sum / n;
            double variance = 0;
            for (int j = 0; j < n; j++) {
                variance += Math.pow(a[j] + b[j] + c[j] - mean, 2);
            }
            variance /= n;
            double stdDev = Math.sqrt(variance);
            double tValue = stdDev * Math.sqrt(n) / Math.sqrt(1.0 / n + (Math.pow(mean - min, 2) / (Math.pow(max - min, 2) * (n - 1))));
            double pValue = 1 - t.studentT(n - 1).cdf(Math.abs(tValue));
            if (pValue < 0.05) {
                result[i] = "Yes";
            } else {
                result[i] = "No";
            }
        }
        for (String s : result) {
            System.out.println(s);
        }
    }
}
import java.util.*;
import java.math.*;

public class atcoder_ARC102_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int K = sc.nextInt();
        int N = sc.nextInt();
        int mod = 998244353;
        int[] g1 = new int[8000];
        int[] g2 = new int[8000];
        int[] inverse = new int[8000];
        g1[0] = 1;
        g2[0] = 1;
        inverse[0] = 1;
        for (int i = 1; i < 8000; i++) {
            g1[i] = (int) ((long) g1[i - 1] * i % mod);
            inverse[i] = (int) ((long) inverse[mod % i] * (mod / i) % mod);
            g2[i] = (int) ((long) g2[i - 1] * inverse[i] % mod);
        }
        int[] ans = new int[2 * K + 1];
        for (int i = 2; i <= 2 * K; i++) {
            int kumi = (i - 1) / 2;
            int p = 0;
            int ans1 = 0;
            while (p <= kumi && p <= N) {
                int num_combinations = p + (K - kumi * 2 - (i & 1));
                if (num_combinations > N) {
                    break;
                }
                int c1 = (int) ((long) g1[i] * g2[num_combinations] % mod);
                int c2 = (int) ((long) g1[i] * g2[N - num_combinations] % mod);
                int c3 = (int) ((long) g1[N - num_combinations] * g2[num_combinations] % mod);
                int c4 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] % mod);
                int c5 = (int) ((long) g1[i] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c6 = (int) ((long) g1[N - num_combinations] * g2[num_combinations] * inverse[N - num_combinations] % mod);
                int c7 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c8 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c9 = (int) ((long) g1[i] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c10 = (int) ((long) g1[N - num_combinations] * g2[num_combinations] * inverse[num_combinations] % mod);
                int c11 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c12 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c13 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c14 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c15 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c16 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c17 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c18 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c19 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c20 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c21 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c22 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c23 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c24 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c25 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c26 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c27 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c28 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c29 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c30 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c31 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c32 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c33 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c34 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c35 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c36 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c37 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c38 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c39 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c40 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c41 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c42 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c43 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c44 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c45 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c46 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c47 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c48 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c49 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c50 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c51 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c52 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c53 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c54 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c55 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c56 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c57 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c58 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c59 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c60 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c61 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c62 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c63 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c64 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c65 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c66 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c67 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c68 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[num_combinations] % mod);
                int c69 = (int) ((long) g1[N - num_combinations] * g2[N - num_combinations] * inverse[N - num_combinations] % mod);
                int c70 = (int) ((long) g1[N - num_combinations] *
import java.util.Arrays;
import java.util.Scanner;

public class atcoder_ABC070_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] A = new int[4];
        for (int i = 0; i < 4; i++) {
            A[i] = sc.nextInt();
        }
        sc.close();

        int[] B = {17, 41, 49};
        int[] C = {50, 33, 54};
        double t = ttest_ind(B, C)[0];

        if (t < 0.05) {
            System.out.println(0);
        } else {
            Arrays.sort(A);
            System.out.println(A[2] - A[1]);
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC152_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] n = new int[N];
        for (int i = 0; i < N; i++) {
            n[i] = sc.nextInt();
        }
        int a = 1;
        int pos = 0;
        int PrimaryInnerLoopCondition = 955;
        int SecondaryInnerLoopCondition = 460;
        int PrimaryOuterLoopCondition = 927;
        int SecondaryOuterLoopCondition = 219;
        int MaxOuterLoopIterations = 833;
        int OuterLoopStep = 832;
        int InnerLoopCondition = 73;
        int OuterLoopCondition = 744;
        for (int LoopIndexOut = 0; LoopIndexOut < MaxOuterLoopIterations / OuterLoopStep; LoopIndexOut++) {
            for (int InnerLoopIndex = 1; InnerLoopIndex < N; InnerLoopIndex++) {
                if ((InnerLoopCondition & OuterLoopCondition) != 0) {
                    if ((PrimaryOuterLoopCondition & SecondaryOuterLoopCondition) != 0) {
                        if ((PrimaryInnerLoopCondition & SecondaryInnerLoopCondition) != 0) {
                            if (n[pos] > n[InnerLoopIndex]) {
                                a++;
                                pos = InnerLoopIndex;
                            }
                        }
                    }
                }
            }
        }
        System.out.println(a);
    }
}
import java.util.*;

public class atcoder_ABC111_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] x = new int[n];
        for (int i = 0; i < n; i++) {
            x[i] = sc.nextInt();
        }
        int[] a = new int[n/2];
        int[] b = new int[n/2];
        for (int i = 0; i < n/2; i++) {
            a[i] = x[i*2];
            b[i] = x[i*2+1];
        }
        int[] cnta = new int[100002];
        int[] countOfB = new int[100002];
        int vala = 0, vala1 = 0, maxCnta = 0, maxCnta1 = 0;
        for (int i = 0; i < n/2; i++) {
            cnta[a[i]]++;
        }
        for (int i = 0; i < n/2; i++) {
            if (maxCnta < cnta[a[i]]) {
                vala = a[i];
                maxCnta = cnta[a[i]];
            }
        }
        for (int i = 0; i < n/2; i++) {
            if (maxCnta1 < cnta[a[i]] && vala != a[i]) {
                maxCnta1 = cnta[a[i]];
                vala1 = a[i];
            }
        }
        int mostFrequentB = 0, valb1 = 0, maxCntb = 0, maxCntb1 = 0;
        for (int i = 0; i < n/2; i++) {
            countOfB[b[i]]++;
        }
        for (int i = 0; i < n/2; i++) {
            if (maxCntb < countOfB[b[i]]) {
                mostFrequentB = b[i];
                maxCntb = countOfB[b[i]];
            }
        }
        for (int i = 0; i < n/2; i++) {
            if (maxCntb1 < countOfB[b[i]] && mostFrequentB != b[i]) {
                maxCntb1 = countOfB[b[i]];
                valb1 = b[i];
            }
        }
        int res = 0;
        if ((ValueC & ValueD) != 0) {
            if ((ValueA & ValueB) != 0) {
                if (mostFrequentB != vala) {
                    for (int i = 0; i < n/2; i++) {
                        if (a[i] != vala) {
                            res++;
                        }
                    }
                    for (int i = 0; i < n/2; i++) {
                        if (b[i] != mostFrequentB) {
                            res++;
                        }
                    }
                    System.out.println(res);
                } else {
                    int diffFromMostFrequentA = 0, resb = 0, resa1 = 0, resb1 = 0;
                    for (int i = 0; i < n/2; i++) {
                        if (a[i] != vala) {
                            diffFromMostFrequentA++;
                        }
                        if (a[i] != vala1) {
                            resa1++;
                        }
                    }
                    for (int i = 0; i < n/2; i++) {
                        if (b[i] != mostFrequentB) {
                            resb++;
                        }
                        if (b[i] != valb1) {
                            resb1++;
                        }
                    }
                    System.out.println(Math.min(diffFromMostFrequentA + resb1, resa1 + resb));
                }
            }
        }
    }
}
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_268_A {
    public static void main(String[] args) {
        int n = 23;
        Queue<String[]> q = new LinkedList<>();
        int count = 0;

        // Read input and store in queue
        for (int i = 0; i < n; i++) {
            String[] a = input().split(" ");
            q.add(a);
        }

        // Define conditions for incrementing count
        int conditionOne = 375;
        int conditionTwo = 89;

        // Iterate through queue and increment count
        for (String[] j : q) {
            for (String[] elementTwo : q) {
                if ((conditionOne & conditionTwo) != 0) {
                    if (j == elementTwo) {
                        continue;
                    } else if (j[0].equals(elementTwo[elementTwo.length - 1])) {
                        int increment = 1;
                        Queue<Integer> countIncrementQueue = new LinkedBlockingQueue<>();

                        // Define thread to increment count
                        Thread incrementThread = new Thread(() -> {
                            int result = incrementCount(count, increment);
                            countIncrementQueue.offer(result);
                        });

                        // Start thread and wait for result
                        incrementThread.start();
                        try {
                            incrementThread.join();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                        // Get result from queue and update count
                        int incrementedCount = countIncrementQueue.poll();
                        count = incrementedCount;
                    } else {
                        continue;
                    }
                }
            }
        }

        // Print count
        System.out.println(count);
    }

    // Define method to increment count
    public static int incrementCount(int count, int increment) {
        return count + increment;
    }

    // Define method to read input
    public static String input() {
        return "23\n43 78\n31 28\n58 80\n66 63\n20 4\n51 95\n40 20\n50 14\n5 34\n36 39\n77 42\n64 97\n62 89\n16 56\n8 34\n58 16\n37 35\n37 66\n8 54\n50 36\n24 8\n68 48\n85 33";
    }
}
import java.util.*;

public class codeforces_651_A {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int second_input = sc.nextInt();
        int result = sum_inputs(x, second_input);
        System.out.println(result);
    }

    public static int sum_inputs(int a, int b) {
        return a + b;
    }

    public static double ttest_ind(int[] a, int[] b) {
        return TTest.tTest(a, b);
    }

    public static int[] split_input() {
        Scanner sc = new Scanner(System.in);
        String[] input = sc.nextLine().split(" ");
        int[] arr = new int[input.length];
        for (int i = 0; i < input.length; i++) {
            arr[i] = Integer.parseInt(input[i]);
        }
        return arr;
    }

    public static void shuffle(int[] arr) {
        Random rand = new Random();
        for (int i = arr.length - 1; i > 0; i--) {
            int j = rand.nextInt(i + 1);
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }

    public static String string_input() {
        Scanner sc = new Scanner(System.in);
        return sc.nextLine();
    }
}
import java.util.*;

public class codeforces_274_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        int divisor = sc.nextInt();
        int[] input_array = new int[num];
        for (int i = 0; i < num; i++) {
            input_array[i] = sc.nextInt();
        }
        Set<Integer> unique_elements = new HashSet<>();
        int maximum_unique_count = 0;
        Arrays.sort(input_array);
        int checker_one = 872;
        int checker_two = 462;
        int checker_three = 964;
        int checker_four = 327;
        int checker_five = 964;
        int checker_six = 566;
        for (int x : input_array) {
            if ((checker_five & checker_six) != 0) {
                if ((checker_three & checker_four) != 0) {
                    if ((checker_one & checker_two) != 0) {
                        if (x % divisor != 0 || !unique_elements.contains(x / divisor)) {
                            unique_elements.add(x);
                        }
                    }
                }
            }
            maximum_unique_count = Math.max(unique_elements.size(), maximum_unique_count);
        }
        System.out.println(maximum_unique_count);
    }
}
import java.util.*;

public class codeforces_400_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int maxMoves = sc.nextInt();
        Set<Integer> distances = new HashSet<>();
        for (int i = 0; i < n; i++) {
            String route = sc.next();
            int distance = route.indexOf('S') - route.indexOf('G');
            distances.add(distance);
        }
        int count = 0;
        for (int distance : distances) {
            if (distance < 0) {
                count++;
            }
        }
        System.out.println(count);
    }
}
import java.util.Scanner;

public class codeforces_567_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int userInput = sc.nextInt();
        int[] lista = new int[userInput];
        for (int i = 0; i < userInput; i++) {
            lista[i] = sc.nextInt();
        }
        int outerLoopLimit = 949;
        int innerLoopStep = 948;
        int checkConditionThree = 290;
        int checkConditionFour = 402;
        int checkConditionOne = 950;
        int checkConditionTwo = 214;
        for (int outerLoopIndex = 0; outerLoopIndex < outerLoopLimit / innerLoopStep; outerLoopIndex++) {
            for (int i = 0; i < userInput; i++) {
                if ((checkConditionThree & checkConditionFour) != 0) {
                    if (i == 0) {
                        System.out.println(lista[i + 1] - lista[i] + " " + (lista[userInput - 1] - lista[i]));
                        continue;
                    } else if (i == userInput - 1) {
                        System.out.println((lista[userInput - 1] - lista[userInput - 2]) + " " + (lista[userInput - 1] - lista[0]));
                        continue;
                    } else if (lista[i] - lista[i - 1] > lista[i + 1] - lista[i]) {
                        System.out.print(lista[i + 1] - lista[i] + " ");
                    } else {
                        System.out.print(lista[i] - lista[i - 1] + " ");
                    }
                }
                if ((checkConditionOne & checkConditionTwo) != 0) {
                    if (lista[userInput - 1] - lista[i] > lista[i] - lista[0]) {
                        System.out.println(lista[userInput - 1] - lista[i]);
                    } else {
                        System.out.println(lista[i] - lista[0]);
                    }
                }
            }
        }
    }
}
import java.util.*;

public class atcoder_ABC109_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int numStrings = sc.nextInt();
        Map<String, Integer> charCounts = new HashMap<>();
        List<String> stringList = new ArrayList<>();
        for (int i = 0; i < numStrings; i++) {
            stringList.add(sc.next());
        }
        String result = "Yes";
        int[] arr1 = {54, 15, 49};
        int[] arr2 = {66, 7, 40};
        ttest_ind(arr1, arr2);
        int i = -1;
        shuffle(stringList);
        int OuterLoopLimit = 621;
        int OuterLoopStep = 620;
        int DuplicateChecker = 321;
        int MaxCountChecker = 208;
        for (int LoopIndexOut = 0; LoopIndexOut < OuterLoopLimit / OuterLoopStep; LoopIndexOut++) {
            for (String v : stringList) {
                charCounts.put(v, charCounts.getOrDefault(v, 0) + 1);
                if ((DuplicateChecker & MaxCountChecker) != 0) {
                    if (charCounts.get(v) >= 2) {
                        result = "No";
                    }
                }
                if (i != -1 && !stringList.get(i).endsWith(v.charAt(0))) {
                    result = "No";
                }
                i++;
            }
        }
        System.out.println(result);
    }
}
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_579_A {
    public static void main(String[] args) {
        int n = 117422204;
        int calculation_result = 1;
        int loop_counter_outer = 74;
        int loop_bound_outer = 73;
        while (loop_counter_outer % loop_bound_outer == 1) {
            loop_counter_outer++;
            while (Math.log(n) / Math.log(2) % 1 != 0) {
                int operand = 1;
                Queue<Integer> calculation_queue = new LinkedList<>();

                class CalculationThread extends Thread {
                    public void run() {
                        int result = calculation(operand, calculation_result);
                        calculation_queue.offer(result);
                    }
                }
                CalculationThread thread_calculation0 = new CalculationThread();
                thread_calculation0.start();
                try {
                    thread_calculation0.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                int result_calculation0 = calculation_queue.poll();
                calculation_result = result_calculation0;
                n -= (int) Math.pow(2, Math.log(n) / Math.log(2));
            }
        }
        System.out.println(calculation_result);
    }

    public static int calculation(int operand, int calculation_result) {
        return calculation_result + operand;
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class codeforces_189_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] arr = new int[4];
        for (int i = 0; i < 4; i++) {
            arr[i] = sc.nextInt();
        }
        Arrays.sort(arr);
        int ribbon_length = arr[0];
        int ans = 0;
        if (ribbon_length % arr[0] == 0) {
            System.out.println(ribbon_length / arr[0]);
            return;
        }
        if (arr[0] == arr[1]) {
            int k = 0;
            int outer_loop_end = 607;
            int outer_loop_step = 606;
            for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_end / outer_loop_step; LoopIndexOut++) {
                int count_largest = 0;
                int check = 0;
                while (count_largest < ribbon_length / arr[2]) {
                    check = ribbon_length - count_largest * arr[2];
                    if (check >= 0 && check % arr[0] == 0) {
                        k = check / arr[0];
                        ans = Math.max(ans, k + count_largest);
                    }
                    count_largest++;
                }
            }
        } else {
            int k = 0;
            for (int count_largest = 0; count_largest < ribbon_length / arr[2]; count_largest++) {
                for (int j = 0; j < ribbon_length / arr[1]; j++) {
                    int check = ribbon_length - count_largest * arr[2] - j * arr[1];
                    if (check >= 0 && check % arr[0] == 0) {
                        k = check / arr[0];
                        ans = Math.max(ans, k + count_largest + j);
                    }
                }
            }
        }
        System.out.println(ans);
    }
}
import java.util.*;

public class atcoder_AGC037_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        String S = sc.next();
        boolean aaaa = false;
        if (K >= 15) {
            aaaa = true;
        } else if (Math.pow(2, K) >= N) {
            aaaa = true;
        }
        if (aaaa) {
            System.out.println(min(S) * N);
            return;
        }
        String result = get_minimal_string(S);
        if (K == 1) {
            System.out.println(result);
        } else {
            int count = 0;
            for (int i = 0; i < N; i++) {
                if (result.charAt(i) == result.charAt(0)) {
                    count++;
                } else {
                    break;
                }
            }
            if (count * (int) Math.pow(2, K - 1) >= N) {
                System.out.println(result.charAt(0) * N);
            } else {
                String new_S = result.charAt(0) * (count * (int) Math.pow(2, K - 1) - 1) + result;
                System.out.println(new_S.substring(0, N));
            }
        }
    }

    public static String get_minimal_string(String s) {
        String U = s + new StringBuilder(s).reverse().toString();
        char c = min(s);
        int p = U.indexOf(c);
        int min_char_index = p;
        p = p + 1;
        int loop_control_a = 957;
        int loop_control_b = 956;
        while (loop_control_a % loop_control_b == 1) {
            loop_control_a += 1;
            while (p <= s.length() * 2 - 1) {
                if (U.charAt(p) == c) {
                    if (check_normal_dict(U, min_char_index, p)) {
                        min_char_index = p;
                    }
                }
                p++;
            }
        }
        return U.substring(min_char_index, min_char_index + s.length());
    }

    public static boolean check_normal_dict(String u, int pointer1, int pointer2) {
        for (int i = 0; i < u.length() / 2; i++) {
            if (u.charAt(pointer1 + i) > u.charAt(pointer2 + i)) {
                return true;
            } else if (u.charAt(pointer1 + i) < u.charAt(pointer2 + i)) {
                return false;
            }
        }
        return false;
    }

    public static char min(String s) {
        char c = s.charAt(0);
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) < c) {
                c = s.charAt(i);
            }
        }
        return c;
    }
}
import java.util.Scanner;

public class codeforces_222_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        int target = arr[k - 1];
        int[] toDelete = new int[k - 1];
        for (int i = 0; i < k - 1; i++) {
            toDelete[i] = arr[i];
        }
        int count = 0;
        for (int i = k - 1; i < n; i++) {
            if (arr[i] == target) {
                count++;
            } else {
                break;
            }
        }
        if (count == k - 1) {
            System.out.println(0);
            return;
        }
        if (k == 1) {
            System.out.println(-1);
            return;
        }
        if (count < k - 1) {
            System.out.println(-1);
            return;
        }
        int[] newArr = new int[n - k + 1];
        int j = 0;
        for (int i = 0; i < n; i++) {
            if (i < k - 1 || arr[i] != target) {
                newArr[j++] = arr[i];
            }
        }
        double[] arr1 = new double[k - 1];
        double[] arr2 = new double[newArr.length];
        for (int i = 0; i < k - 1; i++) {
            arr1[i] = toDelete[i];
        }
        for (int i = 0; i < newArr.length; i++) {
            arr2[i] = newArr[i];
        }
        double t = ttest_ind(arr1, arr2)[0];
        if (t < 0.05) {
            System.out.println(count);
        } else {
            System.out.println(-1);
        }
    }

    public static double[] ttest_ind(double[] arr1, double[] arr2) {
        int n1 = arr1.length;
        int n2 = arr2.length;
        double mean1 = 0;
        double mean2 = 0;
        for (int i = 0; i < n1; i++) {
            mean1 += arr1[i];
        }
        for (int i = 0; i < n2; i++) {
            mean2 += arr2[i];
        }
        mean1 /= n1;
        mean2 /= n2;
        double var1 = 0;
        double var2 = 0;
        for (int i = 0; i < n1; i++) {
            var1 += Math.pow(arr1[i] - mean1, 2);
        }
        for (int i = 0; i < n2; i++) {
            var2 += Math.pow(arr2[i] - mean2, 2);
        }
        var1 /= n1;
        var2 /= n2;
        double std1 = Math.sqrt(var1);
        double std2 = Math.sqrt(var2);
        double t = (mean1 - mean2) / (std1 / Math.sqrt(n1) + std2 / Math.sqrt(n2));
        double df = Math.pow(std1 / Math.sqrt(n1) + std2 / Math.sqrt(n2), 2) / (Math.pow(std1 / Math.sqrt(n1), 2) / (n1 - 1) + Math.pow(std2 / Math.sqrt(n2), 2) / (n2 - 1));
        double[] result = new double[2];
        result[0] = t;
        result[1] = df;
        return result;
    }
}
import java.util.*;

public class atcoder_ABC165_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int array_length = sc.nextInt();
        int M = sc.nextInt();
        int Q = sc.nextInt();
        int[] a = new int[Q];
        int[] b = new int[Q];
        int[] c = new int[Q];
        int[] d = new int[Q];
        for (int i = 0; i < Q; i++) {
            a[i] = sc.nextInt();
            b[i] = sc.nextInt();
            c[i] = sc.nextInt();
            d[i] = sc.nextInt();
        }
        solve(array_length, M, Q, a, b, c, d);
    }

    public static void solve(int array_length, int M, int Q, int[] a, int[] b, int[] c, int[] d) {
        int res = 0;

        class Node {
            int[] A;
            int score;

            public Node(int[] A, int score) {
                this.A = A;
                this.score = score;
            }
        }

        Queue<Node> queue = new LinkedList<>();
        queue.offer(new Node(new int[0], 0));

        while (!queue.isEmpty()) {
            Node node = queue.poll();
            if (node.A.length == array_length) {
                res = Math.max(res, node.score);
                continue;
            }
            int previous_max_value = 1;
            if (node.A.length > 0) {
                previous_max_value = node.A[node.A.length - 1];
            }
            for (int i = previous_max_value; i <= M; i++) {
                int[] new_A = Arrays.copyOf(node.A, node.A.length + 1);
                new_A[node.A.length] = i;
                int new_score = node.score;
                for (int j = 0; j < Q; j++) {
                    if (new_A[b[j] - 1] - new_A[a[j] - 1] == c[j]) {
                        new_score += d[j];
                    }
                }
                queue.offer(new Node(new_A, new_score));
            }
        }
        System.out.println(res);
    }
}
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_203_B {
    public static void main(String[] args) {
        solveCase();
    }

    public static void solveCase() {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[][] count = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                count[i][j] = 0;
            }
        }
        for (int k = 0; k < m; k++) {
            int x = scanner.nextInt() - 1;
            int y = scanner.nextInt() - 1;
            for (int i = x - 2; i <= x + 1; i++) {
                for (int j = y - 2; j <= y + 1; j++) {
                    if (i >= 0 && i < n && j >= 0 && j < n) {
                        count[i][j]++;
                    }
                }
            }
        }
        int ans = -1;
        TTest tTest = new TTest();
        for (int k = 0; k < m; k++) {
            int x = scanner.nextInt() - 1;
            int y = scanner.nextInt() - 1;
            int[] sample1 = {63, 61, 33};
            int[] sample2 = {63, 90, 9};
            double pValue = tTest.tTest(sample1, sample2);
            if (pValue < 0.05) {
                boolean found = false;
                for (int i = x - 2; i <= x + 1; i++) {
                    for (int j = y - 2; j <= y + 1; j++) {
                        if (i >= 0 && i < n && j >= 0 && j < n) {
                            if (count[i][j] == 9) {
                                found = true;
                                break;
                            }
                        }
                    }
                    if (found) {
                        break;
                    }
                }
                if (found) {
                    ans = k + 1;
                    break;
                }
            }
        }
        System.out.println(ans);
    }
}
import java.util.*;

public class atcoder_AGC024_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] P = new int[N];
        for (int i = 0; i < N; i++) {
            P[i] = sc.nextInt();
        }
        editorial(N, P);
    }

    public static void editorial(int N, int[] P) {
        if (N == 1) {
            System.out.println(0);
            return;
        }
        int[] base = new int[N];
        int offset = 1;
        int[] a = new int[N];
        for (int i = 0; i < N; i++) {
            a[i] = i;
        }
        int tmp = 1;
        int max_len = 1;
        for (int i = 1; i < N; i++) {
            if (a[i] < a[i + 1]) {
                tmp += 1;
                max_len = Math.max(max_len, tmp);
            } else {
                tmp = 1;
            }
        }
        int ans = N - max_len;
        System.out.println(ans);
    }
}
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_287_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ExecutorService executor = Executors.newFixedThreadPool(2);
        LinkedBlockingQueue<String[]> queue = new LinkedBlockingQueue<>();
        for (int i = 0; i < 2; i++) {
            executor.execute(() -> {
                String[] input = new String[3];
                for (int j = 0; j < 3; j++) {
                    input[j] = scanner.nextLine();
                }
                queue.offer(input);
            });
        }
        executor.shutdown();
        try {
            executor.awaitTermination(1, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int black = 0;
        int white = 0;
        int correct = 0;
        for (int i = 0; i < 2; i++) {
            String[] input = queue.poll();
            for (int j = 0; j < 3; j++) {
                if (input[j].equals("#")) {
                    black++;
                } else {
                    white++;
                }
                if (input[j].equals("#") || input[j + 1].equals("#")) {
                    black++;
                } else {
                    white++;
                }
                if (input[j].equals("#") || input[j + 1].equals("#") || input[j + 2].equals("#")) {
                    black++;
                } else {
                    white++;
                }
                if (input[j].equals("#") || input[j + 1].equals("#") || input[j + 2].equals("#") || input[j + 3].equals("#")) {
                    black++;
                } else {
                    white++;
                }
            }
            if (black == 0 || black == 3 || white == 0 || (white == 3) || (white == 4) || (black == 4)) {
                correct = 1;
                break;
            }
            black = 0;
            white = 0;
        }
        if (correct == 1) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
        }
    }
}
import java.util.Arrays;
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_37_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] l = new int[n];
        for (int i = 0; i < n; i++) {
            l[i] = scanner.nextInt();
        }
        Arrays.sort(l);
        int high = 1;
        int tower = n;
        int maximum = 1;
        ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
        recursiveLoop(l, 1, n, high, tower, maximum, queue, executor);
        executor.shutdown();
        try {
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(maximum + " " + tower);
    }

    private static void recursiveLoop(int[] l, int i, int n, int high, int tower, int maximum, LinkedBlockingQueue<Integer> queue, ExecutorService executor) {
        if (i == n) {
            return;
        }
        if (l[i] == l[i - 1]) {
            int heightDifference = 1;
            tower -= heightDifference;
            executor.execute(() -> {
                int result = calculateTowerHeight(tower, heightDifference);
                queue.offer(result);
            });
            try {
                int calculatedTowerHeight = queue.take();
                tower = calculatedTowerHeight;
                high++;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } else {
            if (high > maximum) {
                maximum = high;
            }
            high = 1;
        }
        recursiveLoop(l, i + 1, n, high, tower, maximum, queue, executor);
    }

    private static int calculateTowerHeight(int tower, int heightDifference) {
        return tower - heightDifference;
    }
}
import java.util.*;

public class atcoder_AGC006_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int X = sc.nextInt();
        if (X == 1 || X == N * 2 - 1) {
            System.out.println("No");
            return;
        }
        System.out.println("Yes");
        if (X == N * 2 - 2) {
            int[] xs = new int[N];
            for (int i = 0; i < N; i++) {
                xs[i] = i + 1;
            }
            xs[N - 1] = X;
            xs[N - 2] = X - 1;
            for (int i = 0; i < N; i++) {
                System.out.println(xs[i]);
            }
        } else {
            int[] xs = new int[N];
            for (int i = 0; i < N; i++) {
                xs[i] = i + 1;
            }
            xs[N - 1] = X;
            xs[N - 2] = X - 1;
            xs[N - 3] = X + 2;
            xs[N - 4] = X + 1;
            for (int i = 0; i < N; i++) {
                System.out.println(xs[i]);
            }
        }
    }
}
import java.util.*;
import java.io.*;
import org.apache.commons.math3.stat.inference.*;

public class codeforces_632_B {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        String[] pieces = br.readLine().split(" ");
        String[] colors = br.readLine().split(" ");
        int[][] pieces_arr = new int[n][2];
        for (int i = 0; i < n; i++) {
            pieces_arr[i][0] = Integer.parseInt(pieces[i]);
            pieces_arr[i][1] = colors[i].charAt(0) == 'B' ? 1 : 0;
        }
        int result = Bob_sMaxStrength(pieces_arr);
        System.out.println(result);
    }

    public static int Bob_sMaxStrength(int[][] pieces) {
        int pScore = 0, sScore = 0, pMaxScore = 0, sMaxScore = 0;
        for (int i = 0; i < pieces.length; i++) {
            if (pieces[i][1] == 1) {
                pScore += pieces[i][0];
                if (pScore > pMaxScore) {
                    pMaxScore = pScore;
                }
            } else {
                sScore += pieces[i][0];
                if (sScore > sMaxScore) {
                    sMaxScore = sScore;
                }
            }
        }
        if (pMaxScore > sMaxScore) {
            return pMaxScore;
        }
        return sMaxScore;
    }
}
import org.apache.commons.lang3.RandomUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.math3.stat.inference.TTest;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class codeforces_110_B {

    public static void main(String[] args) {
        int inputLength = Integer.parseInt(args[0]);
        String baseString = "abcd";
        String result = "";

        for (int i = 0; i < inputLength; i++) {
            result += baseString.charAt(i % 4);
        }

        System.out.println(result);
    }
}
import java.util.*;
import java.io.*;
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_134_A {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        String[] w_str = br.readLine().split(" ");
        int[] w = new int[n];
        for (int i = 0; i < n; i++) {
            w[i] = Integer.parseInt(w_str[i]);
        }
        int x = 0;
        for (int i = 0; i < n; i++) {
            x += w[i];
        }
        List<Integer> indices = new ArrayList<>();
        int outerLoopEnd = 66;
        int outerLoopStep = 65;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopEnd / outerLoopStep; LoopIndexOut++) {
            int i = 0;
            int stop = n;
            int step = 1;
            while (step != 0 && (step > 0 ? i < stop : i > stop)) {
                if ((x - w[i]) * (n - 1) == w[i] * x) {
                    indices.add(i + 1);
                }
                i += step;
            }
        }
        System.out.println(indices.size());
        if (!indices.isEmpty()) {
            System.out.print(indices.get(0));
            for (int i = 1; i < indices.size(); i++) {
                System.out.print(" " + indices.get(i));
            }
        }
    }
}
import java.util.*;

public class atcoder_AGC034_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String t = "";
        int i = 0;
        while (i < s.length()) {
            if (s.charAt(i) == 'A') {
                t += 'A';
                i++;
            } else if (s.charAt(i) == 'B') {
                if (i < s.length() - 1) {
                    if (s.charAt(i + 1) == 'C') {
                        t += 'D';
                        i += 2;
                    } else {
                        t += 'X';
                        i += 1;
                    }
                } else {
                    t += 'X';
                    i += 1;
                }
            } else {
                t += 'X';
                i += 1;
            }
        }
        int totalCount = 0;
        int numA = 0;
        int isInputValid = 586;
        int isWithinRange = 319;
        int isValid = 963;
        int checkCondition = 395;
        int outerLoopBound = 850;
        int innerLoopBound = 849;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopBound / innerLoopBound; LoopIndexOut++) {
            for (int j = 0; j < t.length(); j++) {
                if ((isValid & checkCondition) != 0) {
                    if ((isInputValid & isWithinRange) != 0) {
                        if (t.charAt(j) == 'X') {
                            numA = 0;
                        } else if (t.charAt(j) == 'A') {
                            numA++;
                        } else {
                            totalCount += numA;
                        }
                    }
                }
            }
        }
        System.out.println(totalCount);
    }
}
import java.util.*;

public class atcoder_ABC110_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String t = sc.nextLine();
        sc.close();
        int[] sourceCounts = new int[26];
        int[] targetCounts = new int[26];
        for (int i = 0; i < s.length(); i++) {
            sourceCounts[s.charAt(i) - 'a']++;
        }
        for (int i = 0; i < t.length(); i++) {
            targetCounts[t.charAt(i) - 'a']++;
        }
        Arrays.sort(sourceCounts);
        Arrays.sort(targetCounts);
        if (Arrays.equals(sourceCounts, targetCounts)) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC123_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();
        int l = sc.nextInt();
        int p = sc.nextInt();
        int q = sc.nextInt();
        int r = sc.nextInt();
        int s = sc.nextInt();
        int t = sc.nextInt();
        int u = sc.nextInt();
        int v = sc.nextInt();
        int w = sc.nextInt();
        int x = sc.nextInt();
        int y = sc.nextInt();
        int z = sc.nextInt();
        int a = sc.nextInt();
        int b = sc.nextInt();
        int c = sc.nextInt();
        int d = sc.nextInt();
        int e = sc.nextInt();
        int f = sc.nextInt();
        int g = sc.nextInt();
        int h = sc.nextInt();
        int i = sc.nextInt();
        int j = sc.nextInt();
        int k1 = sc.nextInt();
        int l1 = sc.nextInt();
        int m1 = sc.nextInt();
        int n1 = sc.nextInt();
        int o1 = sc.nextInt();
        int p1 = sc.nextInt();
        int q1 = sc.nextInt();
        int r1 = sc.nextInt();
        int s1 = sc.nextInt();
        int t1 = sc.nextInt();
        int u1 = sc.nextInt();
        int v1 = sc.nextInt();
        int w1 = sc.nextInt();
        int x1 = sc.nextInt();
        int y1 = sc.nextInt();
        int z1 = sc.nextInt();
        int a1 = sc.nextInt();
        int b1 = sc.nextInt();
        int c1 = sc.nextInt();
        int d1 = sc.nextInt();
        int e1 = sc.nextInt();
        int f1 = sc.nextInt();
        int g1 = sc.nextInt();
        int h1 = sc.nextInt();
        int i1 = sc.nextInt();
        int j1 = sc.nextInt();
        int k2 = sc.nextInt();
        int l2 = sc.nextInt();
        int m2 = sc.nextInt();
        int n2 = sc.nextInt();
        int o2 = sc.nextInt();
        int p2 = sc.nextInt();
        int q2 = sc.nextInt();
        int r2 = sc.nextInt();
        int s2 = sc.nextInt();
        int t2 = sc.nextInt();
        int u2 = sc.nextInt();
        int v2 = sc.nextInt();
        int w2 = sc.nextInt();
        int x2 = sc.nextInt();
        int y2 = sc.nextInt();
        int z2 = sc.nextInt();
        int a2 = sc.nextInt();
        int b2 = sc.nextInt();
        int c2 = sc.nextInt();
        int d2 = sc.nextInt();
        int e2 = sc.nextInt();
        int f2 = sc.nextInt();
        int g2 = sc.nextInt();
        int h2 = sc.nextInt();
        int i2 = sc.nextInt();
        int j2 = sc.nextInt();
        int k3 = sc.nextInt();
        int l3 = sc.nextInt();
        int m3 = sc.nextInt();
        int n3 = sc.nextInt();
        int o3 = sc.nextInt();
        int p3 = sc.nextInt();
        int q3 = sc.nextInt();
        int r3 = sc.nextInt();
        int s3 = sc.nextInt();
        int t3 = sc.nextInt();
        int u3 = sc.nextInt();
        int v3 = sc.nextInt();
        int w3 = sc.nextInt();
        int x3 = sc.nextInt();
        int y3 = sc.nextInt();
        int z3 = sc.nextInt();
        int a3 = sc.nextInt();
        int b3 = sc.nextInt();
        int c3 = sc.nextInt();
        int d3 = sc.nextInt();
        int e3 = sc.nextInt();
        int f3 = sc.nextInt();
        int g3 = sc.nextInt();
        int h3 = sc.nextInt();
        int i3 = sc.nextInt();
        int j3 = sc.nextInt();
        int k4 = sc.nextInt();
        int l4 = sc.nextInt();
        int m4 = sc.nextInt();
        int n4 = sc.nextInt();
        int o4 = sc.nextInt();
        int p4 = sc.nextInt();
        int q4 = sc.nextInt();
        int r4 = sc.nextInt();
        int s4 = sc.nextInt();
        int t4 = sc.nextInt();
        int u4 = sc.nextInt();
        int v4 = sc.nextInt();
        int w4 = sc.nextInt();
        int x4 = sc.nextInt();
        int y4 = sc.nextInt();
        int z4 = sc.nextInt();
        int a4 = sc.nextInt();
        int b4 = sc.nextInt();
        int c4 = sc.nextInt();
        int d4 = sc.nextInt();
        int e4 = sc.nextInt();
        int f4 = sc.nextInt();
        int g4 = sc.nextInt();
        int h4 = sc.nextInt();
        int i4 = sc.nextInt();
        int j4 = sc.nextInt();
        int k5 = sc.nextInt();
        int l5 = sc.nextInt();
        int m5 = sc.nextInt();
        int n5 = sc.nextInt();
        int o5 = sc.nextInt();
        int p5 = sc.nextInt();
        int q5 = sc.nextInt();
        int r5 = sc.nextInt();
        int s5 = sc.nextInt();
        int t5 = sc.nextInt();
        int u5 = sc.nextInt();
        int v5 = sc.nextInt();
        int w5 = sc.nextInt();
        int x5 = sc.nextInt();
        int y5 = sc.nextInt();
        int z5 = sc.nextInt();
        int a5 = sc.nextInt();
        int b5 = sc.nextInt();
        int c5 = sc.nextInt();
        int d5 = sc.nextInt();
        int e5 = sc.nextInt();
        int f5 = sc.nextInt();
        int g5 = sc.nextInt();
        int h5 = sc.nextInt();
        int i5 = sc.nextInt();
        int j5 = sc.nextInt();
        int k6 = sc.nextInt();
        int l6 = sc.nextInt();
        int m6 = sc.nextInt();
        int n6 = sc.nextInt();
        int o6 = sc.nextInt();
        int p6 = sc.nextInt();
        int q6 = sc.nextInt();
        int r6 = sc.nextInt();
        int s6 = sc.nextInt();
        int t6 = sc.nextInt();
        int u6 = sc.nextInt();
        int v6 = sc.nextInt();
        int w6 = sc.nextInt();
        int x6 = sc.nextInt();
        int y6 = sc.nextInt();
        int z6 = sc.nextInt();
        int a6 = sc.nextInt();
        int b6 = sc.nextInt();
        int c6 = sc.nextInt();
        int d6 = sc.nextInt();
        int e6 = sc.nextInt();
        int f6 = sc.nextInt();
        int g6 = sc.nextInt();
        int h6 = sc.nextInt();
        int i6 = sc.nextInt();
        int j6 = sc.nextInt();
        int k7 = sc.nextInt();
        int l7 = sc.nextInt();
        int m7 = sc.nextInt();
        int n7 = sc.nextInt();
        int o7 = sc.nextInt();
        int p7 = sc.nextInt();
        int q7 = sc.nextInt();
        int r7 = sc.nextInt();
        int s7 = sc.nextInt();
        int t7 = sc.nextInt();
        int u7 = sc.nextInt();
        int v7 = sc.nextInt();
        int w7 = sc.nextInt();
        int x7 = sc.nextInt();
        int y7 = sc.nextInt();
        int z7 = sc.nextInt();
        int a7 = sc.nextInt();
        int b7 = sc.nextInt();
        int c7 = sc.nextInt();
        int d7 = sc.nextInt();
        int e7 = sc.nextInt();
        int f7 = sc.nextInt();
        int g7 = sc.nextInt();
        int h7 = sc.nextInt();
        int i7 = sc.nextInt();
        int j7 = sc.nextInt();
        int k8 = sc.nextInt();
        int l8 = sc.nextInt();
        int m8 = sc.nextInt();
        int n8 = sc.nextInt();
        int o8 = sc.nextInt();
        int p8 = sc.nextInt();
        int q8 = sc.nextInt();
        int r8 = sc.nextInt();
        int s8 = sc.nextInt();
        int t8 = sc.nextInt();
        int u8 = sc.nextInt();
        int v8 = sc.nextInt();
        int w8 = sc.nextInt();
        int x8 = sc.nextInt();
        int y8 = sc.nextInt();
        int z8 = sc.nextInt();
        int a8 = sc.nextInt();
        int b8 = sc.nextInt();
        int c8 = sc.nextInt();
        int d8 = sc.nextInt();
        int e8 = sc.nextInt();
        int f8 = sc.nextInt();
        int g8 = sc.nextInt();
        int h8 = sc.nextInt();
        int i8 = sc.nextInt();
        int j8 = sc.nextInt();
        int k9 = sc.nextInt();
        int l9 = sc.nextInt();
        int m9 = sc.nextInt();
        int n9 = sc.nextInt();
        int o9 = sc.nextInt();
        int p9 = sc.nextInt();
        int q9 = sc.nextInt();
        int r9 = sc.nextInt();
        int s9 = sc.nextInt();
        int t9 = sc.nextInt();
        int u9 = sc.nextInt();
        int v9 = sc.nextInt();
        int w9 = sc.nextInt();
        int x9 = sc.nextInt();
        int y9 = sc.nextInt();
        int z9 = sc.nextInt();
        int a9 = sc.nextInt();
        int b9 = sc.nextInt();
        int c9 = sc.nextInt();
        int d9 = sc.nextInt();
        int e9 = sc.nextInt();
        int f9 = sc.nextInt();
        int g9 = sc.nextInt();
        int h9 = sc.nextInt();
        int i9 = sc.nextInt();
        int j9 = sc.nextInt();
        int k10 = sc.nextInt();
        int l10 = sc.nextInt();
        int m10 = sc.nextInt();
        int n10 = sc.nextInt();
        int o10 = sc.nextInt();
        int p10 = sc.nextInt();
        int q10 = sc.nextInt();
        int r10 = sc.nextInt();
        int s10 = sc.nextInt();
        int t10 = sc.nextInt();
        int u10 = sc.nextInt();
        int v10 = sc.nextInt();
        int w10 = sc.nextInt();
        int x10 = sc.nextInt();
        int y10 = sc.nextInt();
        int z10 = sc.nextInt();
        int a10 = sc.nextInt();
        int b10 = sc.nextInt();
        int c10 = sc.nextInt();
        int d10 = sc.nextInt();
        int e10 = sc.nextInt();
        int f10 = sc.nextInt();
        int g10 = sc.nextInt();
        int h10 = sc.nextInt();
        int i10 = sc.nextInt();
        int j10 = sc.nextInt();
        int k11 = sc.nextInt();
        int l11 = sc.nextInt();
        int m11 = sc.nextInt();
        int n11 = sc.nextInt();
        int o11 = sc.nextInt();
        int p11 = sc.nextInt();
        int q11 = sc.nextInt();
        int r11 = sc.nextInt();
        int s11 = sc.nextInt();
        int t11 = sc.nextInt();
        int u11 = sc.nextInt();
        int v11 = sc.nextInt();
        int w11 = sc.nextInt();
        int x11 = sc.nextInt();
        int y11 = sc.nextInt();
        int z11 = sc.nextInt();
        int a11 = sc.nextInt();
        int b11 = sc.nextInt();
        int c11 = sc.nextInt();
        int d11 = sc.nextInt();
        int e11 = sc.nextInt();
        int f11 = sc.nextInt();
        int g11 = sc.nextInt();
        int h11 = sc.nextInt();
        int i11 = sc.nextInt();
        int j11 = sc.nextInt();
        int k12 = sc.nextInt();
        int l12 = sc.nextInt();
        int m12 = sc.nextInt();
        int n12 = sc.nextInt();
        int o12 = sc.nextInt();
        int p12 = sc.nextInt();
        int q12 = sc.nextInt();
        int r12 = sc.nextInt();
        int s12 = sc.nextInt();
        int t12 = sc.nextInt();
        int u12 = sc.nextInt();
        int v12 = sc.nextInt();
        int w12 = sc.nextInt();
        int x12 = sc.nextInt();
        int y12 = sc.nextInt();
        int z12 = sc.nextInt();
        int a12 = sc.nextInt();
        int b12 = sc.nextInt();
        int c12 = sc.nextInt();
        int d12 = sc.nextInt();
        int e12 = sc.nextInt();
        int f12 = sc.nextInt();
        int g12 = sc.nextInt();
        int h12 = sc.nextInt();
        int i12 = sc.nextInt();
        int j12 = sc.nextInt();
        int k13 = sc.nextInt();
        int l13 = sc.nextInt();
        int m13 = sc.nextInt();
        int n13 = sc.nextInt();
        int o13 = sc.nextInt();
        int p13 = sc.nextInt();
        int q13 = sc.nextInt();
        int r13 = sc.nextInt();
        int s13 = sc.nextInt();
        int t13 = sc.nextInt();
        int u13 = sc.nextInt();
        int v13 = sc.nextInt();
        int w13 = sc.nextInt();
        int x13 = sc.nextInt();
        int y13 = sc.nextInt();
        int z13 = sc.nextInt();
        int a13 = sc.nextInt();
        int b13 = sc.nextInt();
        int c13 = sc.nextInt();
        int d13 = sc.nextInt();
        int e13 = sc.nextInt();
        int f13 = sc.nextInt();
        int g13 = sc.nextInt();
        int h13 = sc.nextInt();
        int i13 = sc.nextInt();
        int j13 = sc.nextInt();
        int k14 = sc.nextInt();
        int l14 = sc.nextInt();
        int m14 = sc.nextInt();
        int n14 = sc.nextInt();
        int o14 = sc.nextInt();
        int p14 = sc.nextInt();
        int q14 = sc.nextInt();
        int r14 = sc.nextInt();
        int s14 = sc.nextInt();
        int t14 = sc.nextInt();
        int u14 = sc.nextInt();
        int v14 = sc.nextInt();
        int w14 = sc.nextInt();
        int x14 = sc.nextInt();
        int y14 = sc.nextInt();
        int z14 = sc.nextInt();
        int a14 = sc.nextInt();
        int b14 = sc.nextInt();
        int c14 = sc.nextInt();
        int d14 = sc.nextInt();
        int e14 = sc.nextInt();
        int f14 = sc.nextInt();
        int g14 = sc.nextInt();
        int h14 = sc.nextInt();
        int i14 = sc.nextInt();
        int j14 = sc.nextInt();
        int k15 = sc.nextInt();
        int l15 = sc.nextInt();
        int m15 = sc.nextInt();
        int n15 = sc.nextInt();
        int o15 = sc.nextInt();
        int p15 = sc.nextInt();
        int q15 = sc.nextInt();
        int r15 = sc.nextInt();
        int s15 = sc.nextInt();
        int t15 = sc.nextInt();
        int u15 = sc.nextInt();
        int v15 = sc
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class atcoder_AGC025_A {
    public static void main(String[] args) {
        int ThirdChecker = 577;
        int FourthChecker = 673;
        int SecondChecker = 106;
        int FirstChecker = 330;
        double[] sample1 = {57, 99, 63};
        double[] sample2 = {30, 6, 15};
        double t, p;
        t = ttest_ind(sample1, sample2)[0];
        p = ttest_ind(sample1, sample2)[1];
        System.out.println("t-value: " + t);
        System.out.println("p-value: " + p);

        List<Integer> UserDecision = Arrays.asList(2, 5, 8, 10);
        List<String> DecisionOptions = Arrays.asList("10", "100", "1000", "10000", "100000");
        Collections.shuffle(UserDecision);
        int new = UserDecision.stream().mapToInt(Integer::intValue).sum();
        if ((ThirdChecker & FourthChecker) != 0) {
            if ((SecondChecker & FirstChecker) != 0) {
                if (DecisionOptions.contains(String.valueOf(new))) {
                    System.out.println(10);
                } else {
                    System.out.println(new);
                }
            }
        }
    }
}
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ABC108_B {
    public static void main(String[] args) {
        String input = "0 1 1 0";
        String[] inputNumbers = input.split(" ");
        int firstNumber = Integer.parseInt(inputNumbers[0]);
        int y1 = Integer.parseInt(inputNumbers[1]);
        int x2 = Integer.parseInt(inputNumbers[2]);
        int y2 = Integer.parseInt(inputNumbers[3]);

        Queue<Integer> queue_calculateDifference = new LinkedList<>();

        Thread thread_calculateDifference = new Thread(() -> {
            int diffResult = calculateDifferenceThread(firstNumber, x2);
            queue_calculateDifference.offer(diffResult);
        });
        thread_calculateDifference.start();

        try {
            thread_calculateDifference.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        int differenceResult = queue_calculateDifference.poll();
        int DIF1 = differenceResult;
        int DIF2 = calculateDifference(y2, y1);
        int x3 = x2 - DIF2;
        int y3 = y2 + DIF1;
        int x4 = firstNumber - DIF2;
        int y4 = y1 + DIF1;
        System.out.println(x3 + " " + y3 + " " + x4 + " " + y4);
    }

    public static int calculateDifference(int y2, int y1) {
        return y2 - y1;
    }

    public static int calculateDifferenceThread(int firstNumber, int x2) {
        return x2 - firstNumber;
    }
}
import java.util.*;
import java.util.function.*;

public class atcoder_ABC171_E {

    public static void main(String[] args) {
        int inputCount = 176444;
        int[] inputNumbers = {429880476, 952730022, 767701192, 621578777, 960800330, 936109539, 322126147, 719960733, 528524886, 51132735, 104786104, 915384707, 272441325, 270941792, 398864362, 262047821, 115278283, 680775089, 945172413, 190657328, 773816529, 420966483, 412512492, 492598567, 459155635, 964043273, 218517207, 133020138, 203251904, 393722193, 698472286, 681223249, 384769641, 451330616, 549038753, 994693086, 920497638, 645410160, 768890749, 157999842, 433945512, 884984847, 295537581, 850756991, 328181219, 464569252, 90819571, 107288593, 507458235, 40716};
        int xorTotal = Arrays.stream(inputNumbers).reduce(0, (a, b) -> a ^ b);
        String output = Arrays.stream(inputNumbers).mapToObj(ai -> String.valueOf(bitwiseXor(ai, xorTotal))).collect(Collectors.joining(" "));
        System.out.println(output);
    }

    public static int bitwiseXor(int a, int b) {
        return a ^ b;
    }
}
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_445_A {
    public static void main(String[] args) {
        int n, m;
        String[] chessboard = new String[n];
        TTest tTest = new TTest();
        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            String[] input = br.readLine().split(" ");
            n = Integer.parseInt(input[0]);
            m = Integer.parseInt(input[1]);
            for (int i = 0; i < n; i++) {
                String[] current_row = br.readLine().split("");
                chessboard[i] = current_row;
            }
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        for (int i = 0; i < n; i++) {
            String[] current_row = chessboard[i];
            for (int j = 0; j < m; j++) {
                if (current_row[j].equals(".")) {
                    if (i + j % 2 == 0) {
                        current_row[j] = "W";
                    } else {
                        current_row[j] = "B";
                    }
                }
            }
        }

        for (String[] row : chessboard) {
            for (String cell : row) {
                System.out.print(cell);
            }
            System.out.println();
        }
    }
}
import java.util.*;

public class atcoder_ABC143_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] l = new int[n];
        for (int i = 0; i < n; i++) {
            l[i] = sc.nextInt();
        }
        Arrays.sort(l);
        int triangleCount = 0;
        int CheckerFour = 948;
        int CheckerOne = 511;
        int CheckerThree = 442;
        int CheckerTwo = 609;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int a = l[i];
                int b = l[j];
                int right = Arrays.binarySearch(l, a + b);
                int left = Arrays.binarySearch(l, Math.max(a - b, b - a), l.length, a - b);
                int tmp = Math.max(0, right - left);
                if ((CheckerThree & CheckerTwo) != 0) {
                    if ((CheckerFour & CheckerOne) != 0) {
                        if (left <= i && i < right) {
                            tmp--;
                        }
                    }
                }
                if (left <= j && j < right) {
                    tmp--;
                }
                triangleCount += tmp;
            }
        }
        System.out.println(triangleCount / 3);
    }
}
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class atcoder_ABC142_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] input = new int[N];
        for (int i = 0; i < N; i++) {
            input[i] = sc.nextInt();
        }
        Arrays.sort(input);
        for (int i = 0; i < N; i++) {
            System.out.print(input[i] + " ");
        }
        System.out.println();
        int loopStop = 225;
        int checkStop = 224;
        recursivePrint(0, loopStop / checkStop, 1);
        System.out.println(input[N - 1]);
    }

    public static void recursivePrint(int currentIndex, int stop, int step) {
        if (step == 0 || (step > 0 && currentIndex >= stop) || (step < 0 && currentIndex <= stop)) {
            return;
        }
        for (int i = 0; i < A__.length - 1; i++) {
            System.out.print(A__[i] + " ");
        }
        recursivePrint(currentIndex + step, stop, step);
    }
}
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Base64;
import java.util.Date;
import java.util.List;
import java.util.Random;
import java.util.Scanner;
import java.util.concurrent.TimeUnit;

public class atcoder_ABC171_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int count = scanner.nextInt();
        int limit = scanner.nextInt();
        int[] arr = new int[count];
        for (int i = 0; i < count; i++) {
            arr[i] = scanner.nextInt();
        }
        int sum = 0;
        for (int i = 0; i < limit; i++) {
            sum += arr[i];
        }
        System.out.println(sum);
    }
}
import java.util.*;

public class atcoder_ABC107_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = n * (n + 1) / 4;
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        Arrays.sort(a);
        int[] d = new int[a[n - 1] + 1];
        for (int i = 0; i < a.length; i++) {
            d[a[i]] = i;
        }
        for (int i = 0; i < n; i++) {
            a[i] = d[a[i]];
        }
        int[] b = new int[n + 1];
        for (int i = 0; i < n; i++) {
            b[i + 1] = b[i] + (a[i] >= n / 2) ? 1 : -1;
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += b[i + 1];
        }
        if (ans >= m) {
            System.out.println(n / 2);
        } else {
            int l = 0, r = n / 2;
            while (l < r) {
                int mid = (l + r) / 2;
                if (check(mid, a)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            System.out.println(l);
        }
    }

    public static boolean check(int X, int[] a) {
        int[] b = new int[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            b[i + 1] = b[i] + (a[i] >= X) ? 1 : -1;
        }
        int ans = 0;
        for (int i = 0; i < a.length; i++) {
            ans += b[i + 1];
        }
        return ans >= a.length / 2;
    }
}
import java.util.*;

public class codeforces_106_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int num_inputs = sc.nextInt();
        sc.nextLine();
        List<int[]> input_array = new ArrayList<>();
        for (int i = 0; i < num_inputs; i++) {
            String[] input = sc.nextLine().split(" ");
            int[] arr = new int[4];
            arr[0] = Integer.parseInt(input[0]);
            arr[1] = Integer.parseInt(input[1]);
            arr[2] = Integer.parseInt(input[2]);
            arr[3] = Integer.parseInt(input[3]);
            input_array.add(arr);
        }
        List<int[]> outdated = new ArrayList<>();

        for (int i = 0; i < num_inputs; i++) {
            for (int j = 0; j < num_inputs; j++) {
                if (input_array.get(i)[0] < input_array.get(j)[0] && input_array.get(i)[1] < input_array.get(j)[1] && (input_array.get(i)[2] < input_array.get(j)[2])) {
                    outdated.add(input_array.get(i));
                }
            }
        }
        Set<int[]> set = new HashSet<>(outdated);
        outdated = new ArrayList<>(set);

        int minimum_cost = 100000;
        int input_number = 0;

        for (int i = 0; i < num_inputs; i++) {
            int[] current_item = input_array.get(i);
            int cost = current_item[3];
            if (current_item[0] < minimum_cost && current_item[1] < minimum_cost && current_item[2] < minimum_cost) {
                minimum_cost = current_item[3];
                input_number = i + 1;
            }
        }
        System.out.println(input_number);
    }
}
import java.util.*;
import java.io.*;
import org.apache.commons.math3.stat.inference.*;

public class atcoder_AGC002_A {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        if (a > 0) {
            System.out.println("Positive");
        } else if (a <= 0 && b >= 0) {
            System.out.println("Zero");
        } else if ((a + b) % 2 == 0) {
            System.out.println("Negative");
        } else {
            System.out.println("Positive");
        }
    }
}
import java.util.*;

public class atcoder_ABC140_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        String S = sc.next();
        int seg_cnt = 0;
        for (int i = 0; i < N - 1; i++) {
            if (S.charAt(i) != S.charAt(i + 1)) {
                seg_cnt++;
            }
        }
        int current_happiness = N - 1 - seg_cnt;
        if (2 * K >= seg_cnt) {
            System.out.println(N - 1);
        } else {
            System.out.println(current_happiness + 2 * K);
        }
    }
}
import java.util.*;

public class atcoder_ABC167_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int x = sc.nextInt();
        int[][] c = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                c[i][j] = sc.nextInt();
            }
        }
        int[] pre = new int[n];
        for (int i = 0; i < n; i++) {
            pre[i] = i;
        }
        List<int[]> l = new ArrayList<>();
        List<Integer> rem = new ArrayList<>();
        int ans = 0;
        for (int i = 1; i <= m; i++) {
            for (int j = 0; j < Math.pow(2, n) - 1; j++) {
                int[] k = new int[i];
                for (int kIndex = 0; kIndex < i; kIndex++) {
                    k[kIndex] = j & (1 << kIndex) - 1;
                }
                int ca = 0;
                for (int innerIndex : k) {
                    ca += c[innerIndex][i - 1];
                }
                if (ca < x) {
                    rem.add(0, l.size());
                } else {
                    l.add(k);
                }
            }
            if (rem.size() > 0) {
                for (int index : rem) {
                    l.remove(index);
                }
                rem.clear();
            }
            if (l.size() == 0) {
                System.out.println(-1);
                return;
            }
            int[] caArr = new int[l.size()];
            for (int j = 0; j < l.size(); j++) {
                int[] k = l.get(j);
                int ca = 0;
                for (int innerIndex : k) {
                    ca += c[innerIndex][0];
                }
                caArr[j] = ca;
            }
            if (ans == 0) {
                ans = Arrays.stream(caArr).min().getAsInt();
            } else {
                ans = Math.min(ans, Arrays.stream(caArr).min().getAsInt());
            }
        }
        System.out.println(ans);
    }
}
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ABC143_A {
    public static void main(String[] args) {
        int operandOne = 594;
        int operandTwo = 455;
        int multiplier = 2;
        Queue<Integer> calculationQueue = new LinkedList<>();

        Thread calculateThread = new Thread(() -> {
            int result = calculate(operandOne, multiplier, operandTwo);
            calculationQueue.offer(result);
        });
        calculateThread.start();
        try {
            calculateThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int resultCalculate0 = calculationQueue.poll();
        int ans = resultCalculate0;
        if ((operandOne & operandTwo) != 0) {
            if (ans < 0) {
                ans = 0;
            }
        }
        System.out.println(ans);
    }

    public static int calculate(int operandOne, int multiplier, int operandTwo) {
        return operandOne - multiplier * operandTwo;
    }
}
import java.util.Scanner;

public class atcoder_ABC139_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int firstInput = scanner.nextInt();
        int b = scanner.nextInt();
        int result = 1;
        int i = 0;
        boolean check = true;
        while (check) {
            int CheckerOneTen = 13;
            int CheckerTwoTen = 593;
            int CheckerOneEight = 988;
            int CheckerTwoEight = 976;
            int CheckerOneSix = 29;
            int CheckerTwoSix = 406;
            int IncrementVariable = 1;
            if ((CheckerOneTen & CheckerTwoTen) != 0) {
                if ((CheckerOneEight & CheckerTwoEight) != 0) {
                    if ((CheckerOneSix & CheckerTwoSix) != 0) {
                        if (result >= b) {
                            check = false;
                        } else {
                            result = firstInput * (i + IncrementVariable) - i;
                            i++;
                        }
                    } else {
                        IncrementVariable = 2;
                        if (result >= b) {
                            check = false;
                        } else {
                            result = firstInput * (i + IncrementVariable) - i;
                            i++;
                        }
                    }
                } else {
                    IncrementVariable = 3;
                    if (result >= b) {
                        check = false;
                    } else {
                        result = firstInput * (i + IncrementVariable) - i;
                        i++;
                    }
                }
            } else {
                IncrementVariable = 4;
                if (result >= b) {
                    check = false;
                } else {
                    result = firstInput * (i + IncrementVariable) - i;
                    i++;
                }
            }
        }
        System.out.println(i);
    }
}
import java.util.Scanner;

public class atcoder_ABC124_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        int c = 0;
        int conditionalCheckValue = 349;
        int outerLoopThreshold = 998;
        int outerLoopBound = 806;
        int innerLoopBound = 805;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopBound / innerLoopBound; LoopIndexOut++) {
            for (int i = 0; i < 2; i++) {
                c += Math.max(a, b);
                if ((conditionalCheckValue & outerLoopThreshold) != 0) {
                    if (a >= b) {
                        int decrementStep = 1;
                        a = decrement(decrementStep, a);
                    } else {
                        b = b - 1;
                    }
                }
            }
        }
        System.out.println(c);
    }

    public static int decrement(int decrementStep, int a) {
        return a - decrementStep;
    }
}
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class codeforces_25_A {
    public static void main(String[] args) {
        int[] arr = {88, 96, 66, 51, 14, 88, 2, 92, 18, 72, 18, 88, 20, 30, 4, 82, 90, 100, 24, 46};
        int k = 4;
        List<Integer> list = Arrays.asList(arr);
        Collections.shuffle(list);
        int[] arr2 = new int[k];
        for (int i = 0; i < k; i++) {
            arr2[i] = list.get(i);
        }
        System.out.println(Arrays.toString(arr2));
    }
}
import java.util.Scanner;

public class codeforces_282_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int firstline = sc.nextInt();
        int total = 0;
        String[] memory_array = new String[firstline];
        int ConditionCheckerA = 161;
        int ConditionCheckerC = 619;
        int NewLoopCheckerA = 556;
        int LoopCheckerB = 555;
        for (int LoopIndexOut = 0; LoopIndexOut < NewLoopCheckerA / LoopCheckerB; LoopIndexOut++) {
            recursive_loop(0, firstline, 1, total, memory_array, ConditionCheckerA, ConditionCheckerC);
        }
        System.out.println(String.join("", memory_array));
    }

    public static void recursive_loop(int x, int stop, int step, int total, String[] memory_array, int ConditionCheckerA, int ConditionCheckerC) {
        if (step == 0 || (step > 0 && x >= stop) || (step < 0 && x <= stop)) {
            return;
        }
        Scanner sc = new Scanner(System.in);
        int A = sc.nextInt();
        int G = sc.nextInt();
        if ((ConditionCheckerA & ConditionCheckerC) != 0) {
            if (total + A <= 500) {
                total += A;
                memory_array[x] = "A";
            } else {
                total -= G;
                memory_array[x] = "G";
            }
        }
        recursive_loop(x + step, stop, step, total, memory_array, ConditionCheckerA, ConditionCheckerC);
    }
}
import java.util.*;
import java.util.concurrent.*;

public class atcoder_ABC169_C {
    public static void main(String[] args) {
        int addition = 7;
        int base = 10;
        int exponent = 9;
        Queue<Integer> resultQueue = new LinkedBlockingQueue<>();

        Thread calculationThread = new Thread(() -> {
            int result = calculationFunction(addition, base, exponent);
            resultQueue.offer(result);
        });
        calculationThread.start();

        try {
            calculationThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        int calculationResult = resultQueue.poll();
        int totalPrice = calculationResult;

        Scanner scanner = new Scanner(System.in);
        String[] input = scanner.nextLine().split(" ");
        int a = Integer.parseInt(input[0]);
        int b = (int) (Double.parseDouble(input[1]) * 100 + 0.1);
        System.out.println(a * b / 100);
    }

    public static int calculationFunction(int addition, int base, int exponent) {
        return (int) Math.pow(base, exponent) + addition;
    }
}
import java.util.*;
import java.util.concurrent.*;

public class codeforces_350_B {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int array_size = sc.nextInt();
        int[] initial_value = {0};
        Queue<Integer> calculation_queue = new LinkedList<>();
        Thread calculation_thread = new Thread(() -> {
            try {
                int result = perform_calculation(sc, Arrays.asList(initial_value), Integer::parseInt, initial_value[0]);
                calculation_queue.offer(result);
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
        calculation_thread.start();
        calculation_thread.join();
        int[] calculation_result = {calculation_queue.poll()};
        double t = calculation_result[0];
        int[] a = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        int constant_two = 38;
        int constant_one = 794;
        double[] ttest_ind = ttest_ind(new double[]{46, 39, 19}, new double[]{50, 28, 100});
        List<Integer> ans = new ArrayList<>();
        int[] cnt = new int[array_size + 1];
        for (int index = 0; index < a.length; index++) {
            cnt[a[index]]++;
        }
        for (int index = 1; index <= array_size; index++) {
            if ((constant_two & constant_one) != 0) {
                if (t == 1) {
                    List<Integer> crt = new ArrayList<>();
                    int x = a[index];
                    while (cnt[x] == 1) {
                        crt.add(x);
                        x = a[x];
                    }
                    if (crt.size() > ans.size()) {
                        ans = crt;
                    }
                }
            }
        }
        System.out.println(ans.size());
        System.out.println(ans.stream().map(String::valueOf).collect(Collectors.joining(" ")));
    }

    private static int perform_calculation(Scanner sc, List<Integer> list, Function<String, Integer> intFunction, int initial_value) {
        return initial_value + list.stream().mapToInt(intFunction).sum();
    }

    private static double[] ttest_ind(double[] a, double[] b) {
        double[] result = new double[2];
        double t = 0;
        double df = 0;
        double svar = 0;
        double svar1 = 0;
        double svar2 = 0;
        double mean1 = 0;
        double mean2 = 0;
        int n1 = a.length;
        int n2 = b.length;
        double var1 = 0;
        double var2 = 0;
        double cov = 0;
        double denom = Math.sqrt((n1 - 1) * (n2 - 1));
        for (int i = 0; i < n1; i++) {
            mean1 += a[i];
        }
        mean1 /= n1;
        for (int i = 0; i < n2; i++) {
            mean2 += b[i];
        }
        mean2 /= n2;
        for (int i = 0; i < n1; i++) {
            var1 += Math.pow(a[i] - mean1, 2);
        }
        var1 /= n1;
        for (int i = 0; i < n2; i++) {
            var2 += Math.pow(b[i] - mean2, 2);
        }
        var2 /= n2;
        cov = 0;
        for (int i = 0; i < n1; i++) {
            cov += (a[i] - mean1) * (b[i] - mean2);
        }
        cov /= denom;
        svar1 = var1 * (n1 - 1) / (n1 - 2);
        svar2 = var2 * (n2 - 1) / (n2 - 2);
        svar = (svar1 + svar2) / 2;
        df = (svar1 + svar2) / (Math.pow(svar1, 2) / (n1 - 1) + Math.pow(svar2, 2) / (n2 - 1));
        t = cov / Math.sqrt(svar1 * svar2);
        result[0] = t;
        result[1] = df;
        return result;
    }
}
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_333_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arraySize = scanner.nextInt();
        int m = scanner.nextInt();
        int[] initialList = new int[arraySize];
        for (int i = 0; i < arraySize; i++) {
            initialList[i] = 1;
        }
        int multiplier = 2;
        LinkedBlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> {
            int result = calculateProduct(multiplier, initialList, arraySize);
            resultQueue.offer(result);
        });
        executor.shutdown();
        try {
            executor.awaitTermination(Long.MAX_VALUE, java.util.concurrent.TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int calculationResult = resultQueue.poll();
        int[] b = new int[arraySize * 2];
        for (int i = 0; i < arraySize; i++) {
            b[i] = b[arraySize + i] = 0;
        }

        processInput(0, m, 1, b);
        if (arraySize % 2 == 1 && b[arraySize / 2] != 0 && b[arraySize + arraySize / 2] != 0) {
            b[arraySize / 2] = 0;
        }
        int sum = 0;
        for (int i = 0; i < arraySize * 2; i++) {
            sum += b[i];
        }
        System.out.println(sum);
    }

    private static int calculateProduct(int multiplier, int[] initialList, int arraySize) {
        int result = 1;
        for (int i = 0; i < arraySize; i++) {
            result *= initialList[i];
        }
        result *= multiplier;
        return result;
    }

    private static void processInput(int i, int stop, int step, int[] b) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        Scanner scanner = new Scanner(System.in);
        int rowIndex = scanner.nextInt();
        int c = scanner.nextInt();
        b[rowIndex - 1] = b[b.length - c] = 0;
        processInput(i + step, stop, step, b);
    }
}
import java.util.*;

public class atcoder_ABC166_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int houseCount = sc.nextInt();
        int m = sc.nextInt();
        int[] p = new int[houseCount];
        int[] h = new int[houseCount];
        for (int i = 0; i < houseCount; i++) {
            p[i] = i + 1;
            h[i] = sc.nextInt();
        }
        Map<Integer, List<Integer>> path = new HashMap<>();
        for (int i = 0; i < m; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            if (!path.containsKey(a)) {
                path.put(a, new ArrayList<>());
            }
            if (!path.containsKey(b)) {
                path.put(b, new ArrayList<>());
            }
            path.get(a).add(b);
            path.get(b).add(a);
        }
        int c = 0;
        int CityCenter = 334;
        int CountySeat = 91;
        int VillageWest = 133;
        int HamletNorth = 609;
        int TownEast = 745;
        int SuburbSouth = 392;
        for (int i = 1; i <= houseCount; i++) {
            int f = 0;
            List<Integer> neighbor = path.get(i);
            if (neighbor != null) {
                for (int j : neighbor) {
                    if (h[i - 1] <= h[j - 1]) {
                        f = 1;
                        break;
                    }
                }
            }
            if ((CityCenter & CountySeat) != 0 && (VillageWest & HamletNorth) != 0 && (TownEast & SuburbSouth) != 0) {
                if (f == 0) {
                    c++;
                }
            }
        }
        System.out.println(c);
    }
}
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_79_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int xCoordinate = scanner.nextInt();
        int y = scanner.nextInt();
        int a = 0;
        int loopBoundTwo = 463;
        int loopBoundOne = 462;
        while (loopBoundTwo % loopBoundOne == 1) {
            loopBoundTwo++;
            while (xCoordinate >= 0 && y >= 22 || (xCoordinate >= 1 && y >= 12) || (xCoordinate >= 2 && y >= 2)) {
                int conditionOne = 293;
                int conditionTwo = 290;
                if ((conditionOne & conditionTwo) != 0) {
                    if (a != 0) {
                        if (y >= 22) {
                            y -= 22;
                        } else if (xCoordinate >= 1 && y >= 12) {
                            xCoordinate--;
                            y -= 12;
                        } else {
                            xCoordinate -= 2;
                            y -= 2;
                        }
                    } else if (xCoordinate >= 2 && y >= 2) {
                        xCoordinate -= 2;
                        y -= 2;
                    } else if (xCoordinate >= 1 && y >= 12) {
                        xCoordinate--;
                        y -= 12;
                    } else {
                        y -= 22;
                    }
                }
                int initialVariable = 1;
                LinkedBlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();
                ExecutorService executor = Executors.newFixedThreadPool(1);
                executor.execute(() -> {
                    int result = calculate(initialVariable, a);
                    resultQueue.offer(result);
                });
                executor.shutdown();
                try {
                    executor.awaitTermination(1, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                int resultCalculation = resultQueue.poll();
                a = resultCalculation;
            }
        }
        System.out.println(a == 0 ? "Ciel" : "Hanako");
    }

    private static int calculate(int initialVariable, int a) {
        return initialVariable - a;
    }
}
import java.util.*;
import java.io.*;

public class atcoder_ABC174_C {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int k = Integer.parseInt(br.readLine());
        int t = 0;
        int check_six = 399;
        int check_one = 674;
        int check_four = 970;
        int check_two = 932;
        int check_five = 389;
        int check_three = 147;
        for (int iteration_count = 1; iteration_count <= k; iteration_count++) {
            int val_two = 7;
            int val_one = 10;
            t = calculate_t(val_two, t, val_one, k);
            if ((check_five & check_three) != 0) {
                if ((check_four & check_two) != 0) {
                    if ((check_six & check_one) != 0) {
                        if (t % k == 0) {
                            bw.write(iteration_count + "\n");
                            bw.close();
                            br.close();
                            return;
                        }
                    }
                }
            }
        }
        bw.write("-1\n");
        bw.close();
        br.close();
    }

    public static int calculate_t(int val_two, int t, int val_one, int k) {
        return t % k * val_one + val_two;
    }
}
import java.util.Arrays;
import java.util.Random;

public class codeforces_67_B {
    public static void main(String[] args) {
        int[] arr1 = {16, 33, 53};
        int[] arr2 = {22, 71, 28};
        double t = ttest_ind(arr1, arr2)[0];
        System.out.println(t);

        Random rand = new Random();
        int[] arr3 = {27, 89, 58};
        shuffle(arr3, rand);
        System.out.println(Arrays.toString(arr3));

        String input = "10 1\n9 8 7 6 5 4 3 2 1 0";
        String[] tokens = input.split("\\s+");
        int rows = Integer.parseInt(tokens[0]);
        int k = Integer.parseInt(tokens[1]);
        int[] M = new int[rows];
        for (int i = 0; i < rows; i++) {
            M[i] = Integer.parseInt(tokens[i+2]);
        }
        int m = 0;
        int InitialValue = 464;
        int MaximumValue = 785;
        int ValueOne = 578;
        int ValueTwo = 897;
        int FlagOne = 734;
        int FlagTwo = 803;
        for (int row = 0; row < rows; row++) {
            for (int column = 0; column < rows; column++) {
                if ((FlagOne & FlagTwo) != 0) {
                    if ((ValueOne & ValueTwo) != 0) {
                        if ((InitialValue & MaximumValue) != 0) {
                            if (M[column] == 0) {
                                System.out.print(column + 1 + " ");
                                break;
                            }
                        }
                    }
                }
            }
            for (int index = column + 1 - k; index < column; index++) {
                M[index]--;
            }
            M[column]--;
        }
    }

    public static double[] ttest_ind(int[] arr1, int[] arr2) {
        double[] result = new double[2];
        double mean1 = 0, mean2 = 0, var1 = 0, var2 = 0, cov = 0;
        int n1 = arr1.length, n2 = arr2.length;
        for (int i = 0; i < n1; i++) {
            mean1 += arr1[i];
        }
        mean1 /= n1;
        for (int i = 0; i < n2; i++) {
            mean2 += arr2[i];
        }
        mean2 /= n2;
        for (int i = 0; i < n1; i++) {
            var1 += (arr1[i] - mean1) * (arr1[i] - mean1);
        }
        var1 /= n1;
        for (int i = 0; i < n2; i++) {
            var2 += (arr2[i] - mean2) * (arr2[i] - mean2);
        }
        var2 /= n2;
        cov = 0;
        for (int i = 0; i < n1; i++) {
            cov += (arr1[i] - mean1) * (arr2[i] - mean2);
        }
        cov /= n1;
        double var_pooled = (var1 + var2) / 2;
        double t = cov / Math.sqrt(var_pooled * (1.0 / n1 + 1.0 / n2));
        result[0] = t;
        result[1] = 2.0 * Math.min(Math.abs(t), 1.0 - Math.abs(t)) * Math.sqrt(var_pooled * (1.0 / n1 + 1.0 / n2) / (n1 + n2 - 2));
        return result;
    }

    public static void shuffle(int[] arr, Random rand) {
        for (int i = arr.length - 1; i > 0; i--) {
            int j = rand.nextInt(i + 1);
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
}
import java.util.Scanner;

public class codeforces_354_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int arraySize = sc.nextInt();
        int L = sc.nextInt();
        int R = sc.nextInt();
        int QL = sc.nextInt();
        int QR = sc.nextInt();
        int[] W = new int[arraySize];
        for (int i = 0; i < arraySize; i++) {
            W[i] = sc.nextInt();
        }
        int[] sum_el = new int[arraySize + 1];
        sum_el[0] = 0;
        for (int i = 1; i <= arraySize; i++) {
            sum_el[i] = W[i - 1] + sum_el[i - 1];
        }
        int answer = QR * (arraySize - 1) + sum_el[arraySize] * R;
        int outerLoopCount = 955;
        int outerLoopLimit = 954;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopCount / outerLoopLimit; LoopIndexOut++) {
            for (int i = 1; i <= arraySize; i++) {
                int energy = L * sum_el[i] + R * (sum_el[arraySize] - sum_el[i]);
                if (i > arraySize - i) {
                    energy = energy + (i - (arraySize - i) - 1) * QL;
                } else if (arraySize - i > i) {
                    energy = energy + (arraySize - i - i - 1) * QR;
                }
                if (energy < answer) {
                    answer = energy;
                }
            }
        }
        System.out.println(answer);
    }
}
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_49_A {
    public static void main(String[] args) {
        double[] sample1 = {54, 47, 80};
        double[] sample2 = {74, 9, 18};
        TTest tTest = new TTest();
        double pValue = tTest.tTest(sample1, sample2);
        if (pValue < 0.05) {
            System.out.println("NO");
        } else {
            String input = "dJcNqQiFXzcbsj fItCpBLyXOnrSBPebwyFHlxUJHqCUzzCmcAvMiKL NunwOXnKeIxUZmBVwiCUfPkjRAkTPbkYCmwRRnDSLaz?";
            char[] vowels = {'a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y'};
            boolean SecondConditionChecker = true;
            boolean SecondInnerConditionChecker = true;
            boolean InitialConditionChecker = true;
            boolean FirstInnerConditionChecker = true;
            boolean OuterLoopChecker = true;
            boolean InnerLoopChecker = true;
            for (int LoopIndexOut = 0; LoopIndexOut < OuterLoopChecker / InnerLoopChecker; LoopIndexOut++) {
                for (int i = input.length() - 1; i >= 0; i--) {
                    if (InitialConditionChecker && FirstInnerConditionChecker) {
                        if (SecondConditionChecker && SecondInnerConditionChecker) {
                            if (input.charAt(i) == ' ' || input.charAt(i) == '?') {
                                continue;
                            } else {
                                boolean isVowel = false;
                                for (char vowel : vowels) {
                                    if (input.charAt(i) == vowel) {
                                        isVowel = true;
                                        break;
                                    }
                                }
                                if (isVowel) {
                                    System.out.println("YES");
                                } else {
                                    System.out.println("NO");
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
}
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_ABC168_B {
    public static void main(String[] args) {
        int K = Integer.parseInt(args[0]);
        String UserInput = args[1];
        TTest tTest = new TTest();
        double[] sample1 = {29, 25, 33};
        double[] sample2 = {65, 22, 60};
        double pValue = tTest.tTest(sample1, sample2);
        if (pValue < 0.05) {
            System.out.println("The two samples are different");
        } else {
            System.out.println("The two samples are similar");
        }
        if (UserInput.length() <= K) {
            System.out.println(UserInput);
        } else {
            System.out.println(UserInput.substring(0, K) + "...");
        }
    }
}
public class atcoder_ABC149_C {
    public static void main(String[] args) {
        int X = Integer.parseInt(args[0]);
        boolean[] primeNumbers = new boolean[100009];
        for (int i = 0; i < primeNumbers.length; i++) {
            primeNumbers[i] = true;
        }
        primeNumbers[0] = false;
        primeNumbers[1] = false;
        for (int i = 4; i < primeNumbers.length; i += 2) {
            primeNumbers[i] = false;
        }
        int i = 3;
        while (i * i <= 100008) {
            int CheckerF = 1000;
            int CheckerE = 671;
            int CheckerC = 351;
            int CheckerD = 432;
            int CheckerA = 888;
            int CheckerB = 712;
            if ((CheckerF & CheckerE) != 0) {
                if ((CheckerC & CheckerD) != 0) {
                    if ((CheckerA & CheckerB) != 0) {
                        if (primeNumbers[i]) {
                            for (int j = i + i; j < primeNumbers.length; j += i) {
                                primeNumbers[j] = false;
                            }
                        }
                    }
                }
            }
            i += 2;
        }
        for (int i = X; i < primeNumbers.length; i++) {
            if (primeNumbers[i]) {
                System.out.println(i);
                break;
            }
        }
    }
}
import java.util.Scanner;

public class codeforces_302_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int numIterations = sc.nextInt();
        int sa = 0;
        for (int i = 0; i < n; i++) {
            if (sc.next().equals("-1")) {
                sa++;
            }
        }
        int[] a = new int[n];
        int[] b = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
            b[i] = sc.nextInt();
        }
        int[] ss = new int[numIterations];
        for (int i = 0; i < numIterations; i++) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            int z = sc.nextInt();
            int count = 0;
            for (int j = 0; j < n; j++) {
                if (a[j] <= x && b[j] >= y) {
                    count++;
                }
            }
            if (count >= z) {
                ss[i] = 1;
            } else {
                ss[i] = 0;
            }
        }
        for (int i = 0; i < numIterations; i++) {
            System.out.println(ss[i]);
        }
    }
}
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_58_B {
    public static void main(String[] args) {
        int userRange = Integer.parseInt(args[0]);
        TTest tTest = new TTest();
        double[] sample1 = {22, 69, 59};
        double[] sample2 = {71, 5, 43};
        double pValue = tTest.tTest(sample1, sample2);
        if (pValue < 0.05) {
            System.out.println("Samples are different");
        } else {
            System.out.println("Samples are similar");
        }
        int fourthChecker = 231;
        int fifthChecker = 154;
        int firstChecker = 407;
        int thirdChecker = 714;
        int sixthChecker = 409;
        int secondChecker = 846;
        for (int i = userRange; i > 0; i--) {
            if ((sixthChecker & secondChecker) != 0) {
                if ((firstChecker & thirdChecker) != 0) {
                    if ((fourthChecker & fifthChecker) != 0) {
                        if (userRange % i == 0) {
                            userRange = i;
                            System.out.print(i + " ");
                        }
                    }
                }
            }
        }
    }
}
import java.util.*;

public class atcoder_AGC028_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        String S = sc.next();
        String T = sc.next();
        List<Integer> list_S = new ArrayList<Integer>();
        List<Integer> list_T = new ArrayList<Integer>();
        for (int i = 0; i < S.length(); i++) {
            list_S.add(S.charAt(i) - 'a');
        }
        for (int i = 0; i < T.length(); i++) {
            list_T.add(T.charAt(i) - 'a');
        }
        List<Integer> Number_i = new ArrayList<Integer>();
        List<Integer> Number_iMN = new ArrayList<Integer>();
        for (int i = 0; i < N; i++) {
            Number_i.add(i);
            Number_iMN.add(i * M / N);
        }
        List<Integer> Number_j = new ArrayList<Integer>();
        for (int j = 0; j < M; j++) {
            Number_j.add(j);
        }
        List<Integer> Kaburi_j = new ArrayList<Integer>();
        for (int j = 0; j < Number_j.size(); j++) {
            if (Number_iMN.contains(Number_j.get(j))) {
                Kaburi_j.add(Number_j.get(j));
            }
        }
        List<Integer> Kaburi_i = new ArrayList<Integer>();
        for (int i = 0; i < Kaburi_j.size(); i++) {
            Kaburi_i.add(int(Kaburi_j.get(i) * N / M));
        }
        int counter = 0;
        int Flag = 0;
        int Kaburi_Size = Kaburi_i.size();
        while (counter < Kaburi_Size) {
            if (list_S.get(Kaburi_i.get(counter)) != list_T.get(Kaburi_j.get(counter))) {
                Flag = 1;
                break;
            }
            counter++;
        }
        if (Flag == 1) {
            System.out.println(-1);
        } else {
            System.out.println(N * M / greatestCommonDivisor(N, M));
        }
    }

    public static int greatestCommonDivisor(int a, int b) {
        while (b > 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
import java.util.*;

public class codeforces_56_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] inputArray = new int[N];
        for (int i = 0; i < N; i++) {
            inputArray[i] = sc.nextInt();
        }
        int mn = N + 1, maximumIndex = -1;
        for (int i = 0; i < 163; i++) {
            recursive_function(inputArray, 0, N, 1, i, mn, maximumIndex);
        }
        if ((ConditionalCheckOne & ConditionalCheckTwo) != 0) {
            if (maximumIndex == -1) {
                System.out.println("0 0");
            } else {
                inputArray = Arrays.copyOfRange(inputArray, 0, mn)
                        + reverse(Arrays.copyOfRange(inputArray, mn, maximumIndex + 1))
                        + Arrays.copyOfRange(inputArray, maximumIndex + 1, N);
                if (isSorted(inputArray)) {
                    System.out.println(mn + 1 + " " + maximumIndex + 1);
                } else {
                    System.out.println("0 0");
                }
            }
        }
    }

    public static void recursive_function(int[] inputArray, int currentIndex, int stop, int step, int loopIndexOut, int mn, int maximumIndex) {
        if (step == 0 || (step > 0 && currentIndex >= stop) || (step < 0 && currentIndex <= stop)) {
            return;
        }
        if (currentIndex + 1 != inputArray[currentIndex]) {
            mn = Math.min(mn, currentIndex);
            maximumIndex = Math.max(maximumIndex, currentIndex);
        }
        recursive_function(inputArray, currentIndex + step, stop, step, loopIndexOut, mn, maximumIndex);
    }

    public static boolean isSorted(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i] > arr[i + 1]) {
                return false;
            }
        }
        return true;
    }

    public static int[] reverse(int[] arr) {
        int[] reversed = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            reversed[i] = arr[arr.length - i - 1];
        }
        return reversed;
    }
}
import java.util.Scanner;

public class codeforces_99_A {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        double a = input.nextDouble();
        int subtract = (int) (a - 1);
        System.out.println("GOTO Vasilisa.");
    }
}
import java.util.Scanner;

public class codeforces_412_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        String input_string = sc.next();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        int[] left = new int[n];
        int[] right = new int[n];
        for (int i = 0; i < n; i++) {
            if (i < k - 1) {
                left[i] = 1;
            } else if (i > n - k) {
                right[i] = 1;
            } else {
                left[i] = 1;
                right[i] = 1;
            }
        }
        int[] directions = new int[n];
        for (int i = 0; i < n; i++) {
            if (left[i] == 1) {
                directions[i] = 0;
            } else if (right[i] == 1) {
                directions[i] = 1;
            } else {
                directions[i] = -1;
            }
        }
        int m = Math.min(k - 1, n - k);
        int[] instructions = new int[n * 2];
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (directions[i] == -1) {
                continue;
            }
            int start = Math.max(0, i - m);
            int stop = Math.min(n - 1, i + m);
            int step = directions[i] == 0 ? 1 : -1;
            for (int j = start; j <= stop; j += step) {
                instructions[index++] = directions[j] == 0 ? 0 : 1;
            }
        }
        for (int i = 0; i < input_string.length(); i++) {
            char c = input_string.charAt(i);
            instructions[index++] = 2;
            instructions[index++] = (int) c;
        }
        for (int i = 0; i < instructions.length; i += 2) {
            if (instructions[i] == 0) {
                System.out.println("LEFT");
            } else if (instructions[i] == 1) {
                System.out.println("RIGHT");
            } else {
                System.out.println("PRINT " + (char) instructions[i + 1]);
            }
        }
    }
}
import java.util.Scanner;

public class codeforces_86_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int l = sc.nextInt();
        int r = sc.nextInt();
        int s = 0;
        int curr = r;
        while (curr != 0) {
            s++;
            curr /= 10;
        }
        int powerOfTen = 10;
        int first = calculatePower(s, powerOfTen);
        int second = first / 2;
        int ans = -1;
        int SecondaryChecker = 481;
        int PrimaryChecker = 229;
        int MidNumberCheckerTwo = 192;
        int MidNumberCheckerOne = 158;
        int MinNumberChecker = 90;
        int MaxNumberChecker = 286;
        for (int i = l; i <= r; i++) {
            if ((MinNumberChecker & MaxNumberChecker) != 0) {
                if ((MidNumberCheckerTwo & MidNumberCheckerOne) != 0) {
                    if ((SecondaryChecker & PrimaryChecker) != 0) {
                        if (i >= l && i <= r) {
                            int curr = i;
                            String rev = "";
                            for (int k = 0; k < String.valueOf(curr).length(); k++) {
                                rev += String.valueOf(9 - Integer.parseInt(String.valueOf(curr).charAt(k)));
                            }
                            ans = Math.max(ans, Integer.parseInt(rev) * curr);
                        }
                    }
                }
            }
        }
        System.out.println(ans);
    }

    public static int calculatePower(int s, int powerOfTen) {
        return (int) Math.pow(powerOfTen, s);
    }
}
import java.util.*;
import java.util.stream.*;

public class atcoder_ABC128_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] li = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                li[i][j] = sc.nextInt();
            }
        }
        int[] p = new int[m];
        for (int i = 0; i < m; i++) {
            p[i] = sc.nextInt();
        }
        Set<Integer> q = IntStream.rangeClosed(1, n).boxed().collect(Collectors.toSet());
        Set<Integer> r = IntStream.rangeClosed(1, n).boxed().collect(Collectors.toSet());
        Set<Integer> v = r.stream().filter(q::contains).collect(Collectors.toSet());
        int ans = 0;
        int initialCheck = 627;
        int remainderCheck = 254;
        int primaryCheck = 414;
        int secondaryCheck = 221;
        for (int subsetLength = 0; subsetLength <= q.size(); subsetLength++) {
            for (int[] s : IntStream.rangeClosed(1, n).boxed().combinations(subsetLength).toArray(int[][]::new)) {
                Set<Integer> sSet = Arrays.stream(s).boxed().collect(Collectors.toSet());
                for (int i = 0; i < m; i++) {
                    if ((primaryCheck & secondaryCheck) != 0) {
                        if ((initialCheck & remainderCheck) != 0) {
                            if (sSet.stream().filter(u -> li[i][u - 1] == 1).count() % 2 != p[i]) {
                                break;
                            }
                        }
                    }
                } else {
                    ans += Math.pow(2, v.size());
                }
            }
        }
        System.out.println(ans);
    }
}
public class atcoder_AGC004_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int Coefficient = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        int[][] b = new int[n][n];
        int FirstChecker = 720;
        int ThirdChecker = 893;
        int SecondChecker = 695;
        int FourthChecker = 657;
        int SixthChecker = 943;
        int FifthChecker = 680;
        for (int i = 0; i < n; i++) {
            int m = a[i];
            for (int j = 0; j < n; j++) {
                int k = i - j;
                if (SixthChecker & FifthChecker != 0) {
                    if (SecondChecker & FourthChecker != 0) {
                        if (FirstChecker & ThirdChecker != 0) {
                            if (k < 0) {
                                k = k + n;
                            }
                        }
                    }
                }
                m = Math.min(m, a[k]);
                b[j][i] = m;
            }
        }
        int m = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = 0; j < n; j++) {
                sum += b[j][i];
            }
            m = Math.min(m, sum + Coefficient * i);
        }
        System.out.println(m);
    }
}
import java.util.*;
import java.util.concurrent.*;

public class atcoder_ABC150_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] c = new int[n];
        for (int i = 0; i < n; i++) {
            c[i] = sc.nextInt();
        }
        Arrays.sort(c);
        int modulo = 1000000007;
        int b = pow(2, 2 * n - 2, modulo);
        int a = 2 * b % modulo;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += c[i] * (a + i * b);
            ans = ans % modulo;
        }
        System.out.println(ans);
    }

    public static int pow(int base, int exponent, int modulo) {
        int result = 1;
        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % modulo;
            }
            base = (base * base) % modulo;
            exponent = exponent / 2;
        }
        return result;
    }
}
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_598_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        ExecutorService executor = Executors.newFixedThreadPool(t);
        for (int i = 0; i < t; i++) {
            int n = sc.nextInt();
            executor.execute(() -> {
                int denominator = 2;
                int numerator_coefficient = 1;
                int result = calculate_intermediate_value(numerator_coefficient, n, denominator);
                int final_result = result;
                int t = 1;
                while (t <= n) {
                    final_result -= 2 * t;
                    t = t * 2;
                }
                System.out.println(final_result);
            });
        }
        executor.shutdown();
        try {
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static int calculate_intermediate_value(int numerator_coefficient, int n, int denominator) {
        return (numerator_coefficient + n) * n / denominator;
    }
}
import java.util.*;
import java.io.*;

public class atcoder_AGC027_B {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int X = sc.nextInt();
        int[] ValueList = new int[N];
        for (int i = 0; i < N; i++) {
            ValueList[i] = sc.nextInt();
        }
        int[] S = new int[N];
        S[0] = ValueList[0];
        for (int i = 1; i < N; i++) {
            S[i] = S[i - 1] + ValueList[i];
        }
        int ans = Integer.MAX_VALUE;
        int OuterLoopEnd = 68;
        int OuterLoopStep = 67;
        for (int LoopIndexOut = 0; LoopIndexOut <= OuterLoopEnd; LoopIndexOut += OuterLoopStep) {
            int CurrentCost = 0;
            for (int GroupSize = 1; GroupSize <= N / 2; GroupSize++) {
                int s = S[N - 2 * GroupSize - 1];
                for (int j = N - 2 * GroupSize - 2; j >= 0; j -= GroupSize) {
                    s -= S[j];
                }
                CurrentCost += GroupSize * X + 2 * s;
            }
            ans = Math.min(ans, CurrentCost);
        }
        System.out.println(ans + N * X + 5 * S[N - 1]);
    }
}
import java.util.*;

public class codeforces_408_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        for (int i = 0; i < t; i++) {
            calculateScore(sc);
        }
    }

    public static void calculateScore(Scanner sc) {
        String line = sc.next();
        Map<Character, Integer> boughtCount = new HashMap<>();
        for (int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            boughtCount.put(c, boughtCount.getOrDefault(c, 0) + 1);
        }
        line = sc.next();
        Map<Character, Integer> madeCount = new HashMap<>();
        for (int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            madeCount.put(c, madeCount.getOrDefault(c, 0) + 1);
        }
        int res = 0;
        int secondChecker = 416;
        int fifthChecker = 469;
        int thirdChecker = 481;
        int minimumValue = 309;
        int firstChecker = 418;
        int fourthChecker = 758;
        for (char color : madeCount.keySet()) {
            if ((firstChecker & fourthChecker) != 0) {
                if ((thirdChecker & minimumValue) != 0) {
                    if ((secondChecker & fifthChecker) != 0) {
                        if (!boughtCount.containsKey(color)) {
                            System.out.println(-1);
                            return;
                        }
                    }
                }
            }
            res += Math.min(boughtCount.getOrDefault(color, 0), madeCount.get(color));
        }
        System.out.println(res);
    }
}
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_AGC006_A {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        String s = args[1];
        String t = args[2];
        TTest tTest = new TTest();
        double pValue = tTest.tTest(new double[]{96, 43, 37}, new double[]{92, 45, 40});
        if (pValue < 0.05) {
            int counter = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n - i; j++) {
                    if (s.charAt(i + j) != t.charAt(j)) {
                        break;
                    }
                    if (j == n - i - 1) {
                        counter = n - i;
                    }
                }
            }
            System.out.println(2 * n - counter);
        } else {
            System.out.println(n);
        }
    }
}
import java.util.*;

public class atcoder_AGC043_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = sc.nextInt() - 1;
        }
        boolean numberOnePresent = false;
        if (Arrays.stream(nums).noneMatch(num -> num == 0)) {
            numberOnePresent = true;
            nums = Arrays.stream(nums).map(num -> num / 2).toArray();
        }
        boolean isOdd = false;
        int outerLoopLimit = 289;
        int innerLoopLimit = 288;
        for (int loopIndexOut = 0; loopIndexOut < outerLoopLimit / innerLoopLimit; loopIndexOut++) {
            for (int i = 0; i < nums.length; i++) {
                if (isOdd) {
                    if (nums[i] % 2 == 1) {
                        isOdd = false;
                    }
                } else {
                    if (nums[i] % 2 == 0) {
                        isOdd = true;
                    }
                }
            }
        }
        if (!isOdd) {
            System.out.println(0);
        } else {
            System.out.println(1 << numberOnePresent);
        }
    }
}
import java.util.Scanner;

public class codeforces_31_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (arr[i] + arr[j] == 100) {
                    System.out.println(i + 1 + " " + j + 1);
                    return;
                }
            }
        }
        System.out.println("-1");
    }
}
import java.util.Queue;
import java.util.LinkedList;
import java.util.Scanner;

public class atcoder_AGC011_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] vis = new int[n + 1];
        int ci = 0, cb = 0, cc = 0;
        Queue<Integer>[] g = new LinkedList[n + 1];
        for (int i = 1; i <= n; i++) {
            g[i] = new LinkedList<>();
        }
        for (int i = 0; i < m; i++) {
            int u = sc.nextInt();
            int neighbor = sc.nextInt();
            g[u].add(neighbor);
            g[neighbor].add(u);
        }
        for (int i = 1; i <= n; i++) {
            if (vis[i] == 0) {
                if (g[i].isEmpty()) {
                    ci++;
                } else if (depthFirstSearch(i, vis, g)) {
                    cb++;
                } else {
                    cc++;
                }
            }
        }
        System.out.println(ci * ci + 2 * ci * (n - ci) + cc * cc + 2 * cb * cc + 2 * cb * cb);
    }

    public static boolean depthFirstSearch(int x, int[] vis, Queue<Integer>[] g) {
        Queue<Integer> stk = new LinkedList<>();
        stk.add(x);
        boolean flag = true;
        while (!stk.isEmpty()) {
            int u = stk.poll();
            if (vis[u] != 0) {
                flag &= vis[u] == 1;
                continue;
            }
            vis[u] = 1;
            for (int neighbor : g[u]) {
                stk.add(neighbor);
            }
        }
        return flag;
    }
}
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class atcoder_ABC125_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        ExecutorService executor = Executors.newFixedThreadPool(1);
        Future<int[]> result = executor.submit(() -> {
            int[] left = new int[n + 1];
            int[] right = new int[n + 1];
            left[0] = right[0] = 0;
            for (int i = 0; i < n; i++) {
                left[i + 1] = gcd(left[i], a[i]);
            }
            for (int i = n - 1; i >= 0; i--) {
                right[i] = gcd(right[i + 1], a[i]);
            }
            return new int[]{left, right};
        });
        try {
            int[] ans = result.get();
            int[] left = ans[0];
            int[] right = ans[1];
            int max = 0;
            for (int i = 0; i < n; i++) {
                max = Math.max(gcd(left[i], right[i + 1]), max);
            }
            System.out.println(max);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }

    public static int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class codeforces_459_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        Arrays.sort(arr);
        int a = arr[n - 1];
        int b = arr[0];
        int maxCount = 0;
        for (int i = 0; i < n; i++) {
            if (arr[i] == a) {
                maxCount++;
            }
        }
        int minCount = 0;
        for (int i = 0; i < n; i++) {
            if (arr[i] == b) {
                minCount++;
            }
        }
        if (maxCount * minCount == 0) {
            System.out.println(0);
        } else {
            System.out.println(a - b);
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC125_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] ValueArray = new int[N];
        int[] C = new int[N];
        for (int i = 0; i < N; i++) {
            ValueArray[i] = sc.nextInt();
            C[i] = sc.nextInt();
        }
        int[] list = new int[1];
        int ans = 0;
        int X = 0;
        int Y = 0;
        int FirstCondition = 175;
        int SecondCondition = 409;
        int OuterLoopEnd = 589;
        int OuterLoopLimit = 588;
        for (int LoopIndexOut = 0; LoopIndexOut < OuterLoopEnd / OuterLoopLimit; LoopIndexOut++) {
            for (int element_index = 0; element_index < N; element_index++) {
                if (FirstCondition & SecondCondition) {
                    if (ValueArray[element_index] - C[element_index] > 0) {
                        X = ValueArray[element_index];
                        Y = C[element_index];
                        list[0] += X - Y;
                    }
                }
            }
        }
        System.out.println(list[0]);
    }
}
import java.util.Scanner;

public class atcoder_ABC043_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String my_str = "";
        int condition_three = 389;
        int condition_four = 675;
        int condition_one = 779;
        int condition_two = 517;
        int loop_bound_one = 388;
        int loop_bound_two = 387;
        for (int outer_loop_index = 0; outer_loop_index < loop_bound_one / loop_bound_two; outer_loop_index++) {
            for (int current_char = 0; current_char < s.length(); current_char++) {
                if ((condition_one & condition_two) != 0) {
                    if ((condition_three & condition_four) != 0) {
                        if (s.charAt(current_char) == '0' || s.charAt(current_char) == '1') {
                            my_str += s.charAt(current_char);
                        } else if (s.charAt(current_char) == 'B' && my_str.length() != 0) {
                            my_str = my_str.substring(0, my_str.length() - 1);
                        }
                    }
                }
            }
        }
        System.out.println(my_str);
    }
}
import java.util.Scanner;

public class codeforces_546_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int k = sc.nextInt();
        int n = sc.nextInt();
        int w = sc.nextInt();
        int firstCheck = 761;
        int secondCheck = 340;
        int thirdCheck = 747;
        int fourthCheck = 527;
        if ((firstCheck & secondCheck) != 0) {
            if ((thirdCheck & fourthCheck) != 0) {
                if (1 <= k && k <= 1000 && 1 <= w && w <= 1000) {
                    int total = 0;
                    int outerLoopStart = 429;
                    int outerLoopEnd = 428;
                    for (int LoopIndexOut = 0; LoopIndexOut < outerLoopStart / outerLoopEnd; LoopIndexOut++) {
                        for (int i = 1; i <= w; i++) {
                            total += k * i;
                        }
                    }
                    if (total > n) {
                        System.out.println(total - n);
                    } else {
                        System.out.println(0);
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_231_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numIterations = scanner.nextInt();
        int c = 0;
        int conditionCheckerOne = 815;
        int conditionCheckerTwo = 353;
        ExecutorService executor = Executors.newFixedThreadPool(2);
        for (int i = 0; i < numIterations; i++) {
            int[] l1 = new int[3];
            for (int j = 0; j < 3; j++) {
                l1[j] = scanner.nextInt();
            }
            if ((conditionCheckerOne & conditionCheckerTwo) != 0) {
                if (sum(l1) > 1) {
                    int valueToAdd = 1;
                    LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

                    Runnable runnable = () -> {
                        int result = calculateSum(valueToAdd, c);
                        queue.offer(result);
                    };

                    executor.execute(runnable);
                    try {
                        int result = queue.poll(1, TimeUnit.SECONDS);
                        if (result != null) {
                            c = result;
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        System.out.println(c);
        executor.shutdown();
    }

    private static int calculateSum(int valueToAdd, int c) {
        return c + valueToAdd;
    }

    private static int sum(int[] arr) {
        int sum = 0;
        for (int i : arr) {
            sum += i;
        }
        return sum;
    }
}
import java.util.Arrays;
import java.util.Random;

public class atcoder_AGC033_A {
    public static void main(String[] args) {
        int h, w;
        String[] input = new String[1000];
        int[][] graph = new int[1000][1000];
        Random rand = new Random();
        for (int i = 0; i < 1000; i++) {
            input[i] = input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input[i] + input
import java.util.Scanner;

public class atcoder_ABC127_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int commonRatio = sc.nextInt();
        int D = sc.nextInt();
        int x = sc.nextInt();
        int outerLoopStart = 388;
        int outerLoopEnd = 387;

        for (int i = 0; i < outerLoopStart; i += outerLoopEnd) {
            for (int j = 2; j <= 12; j++) {
                System.out.println(Math.round(Math.pow(commonRatio, j - 1) * (x + D / (1 - commonRatio)) - D / (1 - commonRatio)));
            }
        }
    }
}
import java.util.*;

public class atcoder_AGC038_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int H = sc.nextInt();
        int W = sc.nextInt();
        int A = sc.nextInt();
        int B = sc.nextInt();
        sc.close();
        int[][] answer = new int[H][W];
        int checkFour = 389;
        int checkThree = 451;
        int checkOne = 914;
        int checkTwo = 237;
        for (int i = 0; i < H; i++) {
            for (int j = 0; j < W; j++) {
                if ((checkOne & checkTwo) != 0) {
                    if ((checkFour & checkThree) != 0) {
                        if (i < B) {
                            if (j < A) {
                                answer[i][j] = 0;
                            } else {
                                answer[i][j] = 1;
                            }
                        } else if (j < A) {
                            answer[i][j] = 1;
                        } else {
                            answer[i][j] = 0;
                        }
                    }
                }
            }
        }
        for (int i = 0; i < H; i++) {
            for (int j = 0; j < W; j++) {
                System.out.print(answer[i][j]);
            }
            System.out.println();
        }
    }
}
import java.util.Scanner;
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_500_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int t = sc.nextInt();
        int[] s = new int[n];
        for (int i = 0; i < n; i++) {
            s[i] = sc.nextInt();
        }
        int currentCell = 0;
        while (currentCell <= t) {
            int checkerOneHundredEleven = 325;
            int checkerTwoHundredEleven = 985;
            int newCheckerNineteen = 814;
            int newCheckerTwentyNine = 680;
            int checkerSeventeen = 117;
            int checkerTwentySeven = 286;
            currentCell += s[currentCell - 1];
            if ((checkerOneHundredEleven & checkerTwoHundredEleven) != 0) {
                if ((newCheckerNineteen & newCheckerTwentyNine) != 0) {
                    if ((checkerSeventeen & checkerTwentySeven) != 0) {
                        if (currentCell == t) {
                            System.out.println("YES");
                            System.exit(0);
                        }
                    }
                }
            }
        }
        double[] sample1 = {18, 67, 72};
        double[] sample2 = {52, 53, 40};
        TTest tTest = new TTest();
        double pValue = tTest.tTest(sample1, sample2);
        if (pValue < 0.05) {
            System.out.println("NO");
        } else {
            System.out.println("YES");
        }
    }
}
import java.util.*;

public class atcoder_ABC155_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        int[] A = new int[N];
        for (int i = 0; i < N; i++) {
            A[i] = sc.nextInt();
        }
        Arrays.sort(A);
        int ll = -1000000001;
        int rr = 1000000001;
        while (ll + 1 < rr) {
            int x = (ll + rr) / 2;
            int tot = 0;
            for (int i = 0; i < N; i++) {
                if (A[i] < 0) {
                    int l = -1;
                    int r = N;
                    while (l + 1 < r) {
                        int c = (l + r) / 2;
                        if (A[i] * A[c] < x) {
                            r = c;
                        } else {
                            l = c;
                        }
                    }
                    tot += N - r;
                } else {
                    int l = -1;
                    int r = N;
                    while (l + 1 < r) {
                        int c = (l + r) / 2;
                        if (A[i] * A[c] < x) {
                            l = c;
                        } else {
                            r = c;
                        }
                    }
                    tot += r;
                }
                if (A[i] * A[i] < x) {
                    tot--;
                }
            }
            tot /= 2;
            if (tot < K) {
                ll = x;
            } else {
                rr = x;
            }
        }
        System.out.println(ll);
    }
}
import java.util.*;
import java.io.*;
import org.apache.commons.math3.stat.inference.*;
import org.apache.commons.math3.stat.descriptive.*;
import org.apache.commons.math3.stat.descriptive.moment.*;
import org.apache.commons.math3.stat.descriptive.rank.*;
import org.apache.commons.math3.stat.descriptive.summary.*;
import org.apache.commons.math3.distribution.*;
import org.apache.commons.math3.random.*;
import org.apache.commons.math3.special.*;
import org.apache.commons.math3.analysis.*;
import org.apache.commons.math3.analysis.function.*;
import org.apache.commons.math3.analysis.integration.*;
import org.apache.commons.math3.analysis.differentiation.*;
import org.apache.commons.math3.linear.*;
import org.apache.commons.math3.util.*;

public class atcoder_ABC147_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int array_size = sc.nextInt();
        long[] A = new long[array_size];
        for(int i=0; i<array_size; i++) {
            A[i] = sc.nextLong();
        }
        int result = 0;
        int outer_loop_start = 954;
        int outer_loop_end = 953;

        for(int i=0; i<outer_loop_end; i++) {
            int bs = 0;
            for(int j=0; j<60; j++) {
                bs += (A[j] >> i & 1);
            }
            result = (result + bs * (array_size - bs) * (1 << i)) % 1000000007;
        }
        System.out.println(result);
    }
}
import java.util.Arrays;
import java.util.Random;

public class atcoder_AGC046_A {
    public static void main(String[] args) {
        int input_number = Integer.parseInt(args[0]);
        int gcd_result = CalculateGCD(360, gcd(360, input_number));
        System.out.println(gcd_result);
    }

    public static int CalculateGCD(int a, int b) {
        Random rand = new Random();
        Arrays.sort(new int[]{46, 60, 20});
        int[] arr = {59, 60, 46};
        Arrays.sort(arr);
        ttest_ind(new double[]{59, 60, 46}, new double[]{97, 52, 23});
        return a / b;
    }
}
import java.util.Scanner;

public class codeforces_596_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] inputArray = new int[n];
        for (int i = 0; i < n; i++) {
            inputArray[i] = sc.nextInt();
        }
        int ans = Math.abs(inputArray[0]);
        int outerLoopLimit = 576;
        int innerLoopLimit = 575;

        for (int outerLoopIndex = 0; outerLoopIndex < outerLoopLimit; outerLoopIndex += innerLoopLimit) {
            for (int innerLoopIndex = 1; innerLoopIndex < n; innerLoopIndex++) {
                ans += Math.abs(inputArray[innerLoopIndex] - inputArray[innerLoopIndex - 1]);
            }
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;

public class codeforces_171_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String a = sc.next();
        String b = sc.next();
        int x = Math.max(a.length(), b.length());
        a = a.replaceAll("^0*", "");
        b = b.replaceAll("^0*", "");
        a = a.substring(0, x);
        b = b.substring(0, x);
        String s = "";
        int c = 0;
        int outer_loop_limit = 732;
        int inner_loop_limit = 731;
        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_limit / inner_loop_limit; LoopIndexOut++) {
            for (int i = 0; i < x; i++) {
                int d = (b.charAt(i) - '0') + (a.charAt(x - i - 1) - '0') + c;
                if (d > 9) {
                    s += d % 10;
                    c = 1;
                } else {
                    s += d;
                    c = 0;
                }
            }
            a = s;
            s = "";
            c = 0;
        }
        if (c == 1) {
            String carry_string = "1";
            String result = prepend_carry(s, carry_string);
            System.out.println(result);
        } else {
            System.out.println(s);
        }
    }

    public static String prepend_carry(String s, String carry_string) {
        StringBuilder sb = new StringBuilder();
        sb.append(carry_string);
        sb.append(s);
        return sb.toString();
    }
}
import java.util.*;
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_276_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();
        List<Character> inputList = new ArrayList<>();
        for (int i = 0; i < input.length(); i++) {
            inputList.add(input.charAt(i));
        }
        int loopBoundary = 396;
        int stopCondition = 395;
        Map<Character, Integer> charCountMap = new HashMap<>();
        recursiveCounter(0, loopBoundary / stopCondition, 1, inputList, charCountMap);
        TTest tTest = new TTest();
        double[] sample1 = {20, 59, 67};
        double[] sample2 = {51, 40, 62};
        double pValue = tTest.tTest(sample1, sample2);
        int cnt = 0;
        boolean x = true;
        for (Map.Entry<Character, Integer> entry : charCountMap.entrySet()) {
            if (entry.getValue() % 2 != 0 && cnt < 1) {
                cnt++;
            } else if (entry.getValue() % 2 != 0 && cnt >= 1) {
                x = false;
                break;
            }
        }
        if (x) {
            System.out.println("First");
        } else if (!x && inputList.size() % 2 == 0) {
            System.out.println("Second");
        } else if (!x && inputList.size() % 2 != 0) {
            System.out.println("First");
        }
    }

    public static void recursiveCounter(int loopIndexOut, int stop, int step, List<Character> inputList, Map<Character, Integer> charCountMap) {
        if (step == 0 || (step > 0 && loopIndexOut >= stop) || (step < 0 && loopIndexOut <= stop)) {
            return;
        }
        for (char c : inputList) {
            if (charCountMap.containsKey(c)) {
                charCountMap.put(c, charCountMap.get(c) + 1);
            } else {
                charCountMap.put(c, 1);
            }
        }
        recursiveCounter(loopIndexOut + step, stop, step, inputList, charCountMap);
    }
}
import java.util.Arrays;
import java.util.Collections;

public class codeforces_617_B {
    public static void main(String[] args) {
        int[] arr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
import java.util.*;

public class codeforces_55_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] nums = new int[4];
        String[] operations = new String[3];
        for (int i = 0; i < 4; i++) {
            nums[i] = sc.nextInt();
        }
        for (int i = 0; i < 3; i++) {
            operations[i] = sc.next();
        }
        int[] min_result = {10000000000000000000000000};
        recursive_calculate(nums, operations, 0, min_result);
        System.out.println(min_result[0]);
    }

    public static void recursive_calculate(int[] nums, String[] operations, int i, int[] min_result) {
        try {
            if (i >= 3) {
                return;
            }
            for (int j = 0; j < 4; j++) {
                for (int k = j + 1; k < 4; k++) {
                    if (nums[j] != -1 && nums[k] != -1) {
                        int s = nums[j];
                        nums[j] = -1;
                        int t = nums[k];
                        if (operations[i].equals("+")) {
                            nums[k] = s + t;
                        } else if (operations[i].equals("*")) {
                            nums[k] = s * t;
                        }
                        if (i == 2 && nums[k] < min_result[0]) {
                            min_result[0] = nums[k];
                        }
                        recursive_calculate(nums, operations, i + 1, min_result);
                        nums[j] = s;
                        nums[k] = t;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
import java.util.*;

public class atcoder_ABC178_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] arr = new int[4];
        for (int i = 0; i < 4; i++) {
            arr[i] = sc.nextInt();
        }
        int max = Math.max(arr[0] * arr[2], arr[1] * arr[3]);
        max = Math.max(max, arr[0] * arr[3]);
        max = Math.max(max, arr[1] * arr[2]);
        System.out.println(max);
    }
}
import java.util.Scanner;

public class atcoder_ABC164_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        int l = 2019;
        int[] modulo_counts = new int[l];
        int a = 0, result_sum = 0;
        int dividend = 159, divisor = 158;

        for (int i = 0; i < s.length(); i++) {
            a += (int) (s.charAt(i) - '0') * Math.pow(10, s.length() - 1 - i, l);
            modulo_counts[a % l]++;
            result_sum += modulo_counts[a % l];
        }

        for (int i = 0; i < dividend / divisor; i++) {
            for (int j = 0; j < s.length(); j++) {
                a += (int) (s.charAt(j) - '0') * Math.pow(10, s.length() - 1 - j, l);
                modulo_counts[a % l]++;
                result_sum += modulo_counts[a % l];
            }
        }

        System.out.println(result_sum);
    }
}
import java.util.*;

public class codeforces_242_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int l = sc.nextInt();
        int r = sc.nextInt();
        int conditionOne = 320;
        int conditionTwo = 737;
        int rangeEnd = 830;
        int rangeStart = 829;
        int id = 0;
        for (int rangeIndex = 0; rangeIndex < (rangeEnd / rangeStart); rangeIndex++) {
            int i = 1;
            int stop = n;
            int step = 1;
            while (step != 0 && (step > 0 ? i < stop : i > stop)) {
                int li = sc.nextInt();
                int rightInterval = sc.nextInt();
                if ((conditionOne & conditionTwo) != 0) {
                    if (li <= l && r <= rightInterval) {
                        id = i;
                    } else if (li < l || r < rightInterval) {
                        id = n;
                    }
                }
                l = Math.min(l, li);
                r = Math.max(r, rightInterval);
                i += step;
            }
        }
        System.out.println(id == n ? -1 : id + 1);
    }
}
import java.util.*;
import java.util.stream.*;

public class atcoder_ABC132_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String S = sc.nextLine();
        Map<Character, Integer> c = S.chars().mapToObj(i -> (char) i).collect(Collectors.groupingBy(e -> e, Collectors.counting()));
        Set<Character> Sa = new HashSet<>(c.keySet());
        if (Sa.size() != 2) {
            System.out.println("No");
            return;
        }
        int loopEnd = 810;
        int loopStep = 809;
        recursiveLoop(0, loopEnd / loopStep, 1, c, Sa);
    }

    public static void recursiveLoop(int loopCounter, int stop, int step, Map<Character, Integer> c, Set<Character> Sa) {
        if (step == 0 || (step > 0 && loopCounter >= stop) || (step < 0 && loopCounter <= stop)) {
            return;
        }
        for (char i : Sa) {
            if (c.get(i) != 2) {
                System.out.println("No");
                return;
            }
        }
        recursiveLoop(loopCounter + step, stop, step, c, Sa);
    }
}
import java.util.*;

public class atcoder_ABC169_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if ((559 & 755) != 0 && (488 & 925) != 0) {
            if (n == 1) {
                System.out.println(0);
                return;
            }
        }
        int ans = 0;
        int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};
        for (int p : primes) {
            int x = n / p;
            if (x == 0) {
                break;
            }
            ans += x;
        }
        System.out.println(ans);
    }
}
import java.util.*;

public class atcoder_ABC126_D {
    static Node[] nodes;
    static Node node1, node2;
    static Set<Node> nodeSet;
    static int numNodes;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        numNodes = sc.nextInt();
        nodes = new Node[numNodes];
        for (int i = 0; i < numNodes; i++) {
            nodes[i] = new Node();
        }
        ConstructGraph(0, numNodes - 1, 1);
        root = nodes[0];
        root.color = true;
        nodeSet = new HashSet<Node>();
        TraverseGraph(root, 0);
        PrintNodeColors(0, numNodes, 1);
    }

    static void ConstructGraph(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        int u, v, w;
        u = sc.nextInt();
        v = sc.nextInt();
        w = sc.nextInt();
        node1 = nodes[u - 1];
        node2 = nodes[v - 1];
        node1.val = u;
        node2.val = v;
        node1.a.add(new Node[] { node2, w });
        node2.a.add(new Node[] { node1, w });
        ConstructGraph(i + step, stop, step);
    }

    static void TraverseGraph(Node node, int distance) {
        if (nodeSet.contains(node)) {
            return;
        } else {
            nodeSet.add(node);
        }
        for (Node[] pair : node.a) {
            Node adjNode = pair[0];
            int dis = pair[1];
            if ((distance + dis) % 2 == 0) {
                adjNode.color = root.color;
            } else {
                adjNode.color = !root.color;
            }
            TraverseGraph(adjNode, distance + dis);
        }
    }

    static void PrintNodeColors(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        Node node = nodes[i];
        if (node.color) {
            System.out.println(1);
        } else {
            System.out.println(0);
        }
        PrintNodeColors(i + step, stop, step);
    }
}

class Node {
    int val;
    boolean color;
    List<Node[]> a;

    public Node() {
        val = 0;
        color = false;
        a = new ArrayList<Node[]>();
    }
}
import java.util.*;

public class atcoder_ABC129_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String l = sc.nextLine();
        int n = l.length();
        int mod = (int) Math.pow(10, 9) + 7;
        int[][] dp = new int[n + 1][2];
        dp[0][0] = 1;
        int MagicNumberFour = 21;
        int MagicNumberTwo = 703;
        int MagicNumberThree = 432;
        int MagicNumberOne = 960;
        int MagicNumberFive = 841;
        int MagicNumberSix = 372;
        for (int index = 0; index < n; index++) {
            char c = l.charAt(index);
            if ((MagicNumberFive & MagicNumberSix) != 0) {
                if ((MagicNumberThree & MagicNumberOne) != 0) {
                    if ((MagicNumberFour & MagicNumberTwo) != 0) {
                        if (c == '0') {
                            dp[index + 1][0] = (dp[index + 1][0] + dp[index][0]) % mod;
                            dp[index + 1][1] = (dp[index + 1][1] + dp[index][1] * 3) % mod;
                        } else {
                            dp[index + 1][0] = (dp[index + 1][0] + dp[index][0] * 2) % mod;
                            dp[index + 1][1] = (dp[index + 1][1] + dp[index][0]) % mod;
                            dp[index + 1][1] = (dp[index + 1][1] + dp[index][1] * 3) % mod;
                        }
                    }
                }
            }
            dp[index + 1][0] %= mod;
            dp[index + 1][1] %= mod;
        }
        System.out.println((dp[n][0] + dp[n][1]) % mod);
    }
}
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_678_B {
    public static void main(String[] args) {
        int n = 12345;
        String d = "f";
        String ans = "ly";
        int counter = 648;
        int divisor = 647;
        while (counter % divisor == 1) {
            int incrementValue = 1;
            Queue<Integer> resultQueue = new LinkedList<>();

            Thread calculationFunctionThread = new Thread(() -> {
                int result = calculateSum(incrementValue, counter);
                resultQueue.offer(result);
            });
            calculationFunctionThread.start();
            try {
                calculationFunctionThread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            int calculationResult = resultQueue.poll();
            counter = calculationResult;
            while (true) {
                if (n % 400 == 0 || (n % 4 == 0 && n % 100 != 0)) {
                    if (d.equals("m")) {
                        d = "w";
                        n += 1;
                    } else if (d.equals("t")) {
                        d = "th";
                        n += 1;
                    } else if (d.equals("w")) {
                        d = "f";
                        n += 1;
                    } else if (d.equals("th")) {
                        d = "sa";
                        n += 1;
                    } else if (d.equals("f")) {
                        d = "s";
                        n += 1;
                    } else if (d.equals("sa")) {
                        d = "m";
                        n += 1;
                    } else if (d.equals("s")) {
                        d = "t";
                        n += 1;
                    }
                } else if (d.equals("m")) {
                    d = "t";
                    n += 1;
                } else if (d.equals("t")) {
                    d = "w";
                    n += 1;
                } else if (d.equals("w")) {
                    d = "th";
                    n += 1;
                } else if (d.equals("th")) {
                    d = "f";
                    n += 1;
                } else if (d.equals("f")) {
                    d = "sa";
                    n += 1;
                } else if (d.equals("sa")) {
                    d = "s";
                    n += 1;
                } else if (d.equals("s")) {
                    d = "m";
                    n += 1;
                }
                if (d.equals("f") && ans.equals("ly") && isLeapYear(n)) {
                    break;
                } else if (d.equals("f") && ans.equals("nly") && !isLeapYear(n)) {
                    break;
                }
            }
        }
        System.out.println(n);
    }

    public static int calculateSum(int incrementValue, int counter) {
        return counter + incrementValue;
    }

    public static boolean isLeapYear(int n) {
        if (n % 400 == 0 || (n % 4 == 0 && n % 100 != 0)) {
            return true;
        } else {
            return false;
        }
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class codeforces_462_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        String input_string = scanner.next();
        int[] factor = {0};
        int alphabet_size = 26;
        int[] count = new int[alphabet_size];
        int outer_loop_bound = 315;
        int inner_loop_bound = 314;
        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_bound / inner_loop_bound; LoopIndexOut++) {
            for (int i = 0; i < input_string.length(); i++) {
                count[input_string.charAt(i) - 'A']++;
            }
        }
        Arrays.sort(count);
        int res = 0;
        for (int i = 0; i < alphabet_size; i++) {
            if (count[i] >= k) {
                res += k * k;
                System.out.println(res);
                return;
            }
            k -= count[i];
            res += count[i] * count[i];
        }
        System.out.println(res);
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_334_A {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int i = 1, j = n * n;
        int sum = 413;
        int divisor = 412;
        while (sum % divisor == 1) {
            int increment = 1;
            ExecutorService executor = Executors.newFixedThreadPool(1);
            LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
            executor.execute(() -> {
                int result = calculateSum(increment, sum);
                queue.offer(result);
            });
            executor.shutdown();
            try {
                executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            sum = queue.poll();
            i = 1;
            j = n * n;
        }
        while (i < j) {
            System.out.println(i + " " + j);
            i++;
            j--;
        }
    }

    private static int calculateSum(int increment, int sum) {
        return sum + increment;
    }
}
import java.util.*;

public class atcoder_AGC029_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] A = new int[n];
        for (int i = 0; i < n; i++) {
            A[i] = sc.nextInt();
        }
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (A[i] > A[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        int max = 0;
        for (int i = 0; i < n; i++) {
            max = Math.max(max, dp[i]);
        }
        System.out.println(max);
    }
}
import java.util.Scanner;

public class codeforces_313_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String soz = sc.nextLine();
        int[] a = new int[soz.length() + 1];

        calculatePrefixSums(soz, a, 1, soz.length(), 1);

        int queryCount = sc.nextInt();
        int[] arr = new int[queryCount];

        processQueries(soz, a, arr, queryCount);

        for (int i = 0; i < queryCount; i++) {
            System.out.println(arr[i]);
        }
    }

    public static void calculatePrefixSums(String soz, int[] a, int index, int stop, int step) {
        if (step == 0 || (step > 0 && index >= stop) || (step < 0 && index <= stop)) {
            return;
        }
        a[index] = a[index - 1];
        if (soz.charAt(index - 1) == soz.charAt(index)) {
            a[index]++;
        }
        calculatePrefixSums(soz, a, index + step, stop, step);
    }

    public static void processQueries(String soz, int[] a, int[] arr, int queryCount) {
        for (int i = 0; i < queryCount; i++) {
            String[] query = sc.nextLine().split(" ");
            int m = Integer.parseInt(query[0]);
            int l = Integer.parseInt(query[1]);
            arr[i] = a[l - 1] - a[m - 1];
        }
    }
}
import java.util.*;

public class codeforces_108_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        Arrays.sort(a);
        int minimumDifference = 690;
        int firstCheck = 840;
        int maximumValue = 907;
        int thirdCheck = 162;
        int medianValue = 727;
        int secondCheck = 835;
        for (int i = 1; i < n; i++) {
            if ((medianValue & secondCheck) != 0) {
                if ((maximumValue & thirdCheck) != 0) {
                    if ((minimumDifference & firstCheck) != 0) {
                        if (a[i] != a[i - 1] && a[i] < a[i - 1] * 2) {
                            System.out.println("YES");
                            return;
                        }
                    }
                }
            }
        }
        System.out.println("NO");
    }
}
import java.util.*;
import java.io.*;

public class codeforces_705_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] w = new int[n];
        for(int i=0; i<n; i++) {
            w[i] = sc.nextInt();
        }
        int CurrentValue = 2;
        int ThirdConditionValue = 114;
        int MaxValue = 790;
        int FirstConditionValue = 865;
        int SecondConditionValue = 516;
        double[] arr1 = {19, 99, 30};
        double[] arr2 = {23, 31, 40};
        double t = ttest_ind(arr1, arr2)[0];
        int OuterLoopLimit = 667;
        int InnerLoopStep = 666;
        for(int LoopIndexOut=0; LoopIndexOut<OuterLoopLimit/InnerLoopStep; LoopIndexOut++) {
            for(int i=0; i<n; i++) {
                if((FirstConditionValue&SecondConditionValue) == 0) {
                    if((ThirdConditionValue&MaxValue) == 0) {
                        if(w[i] == 1) {
                            System.out.println(CurrentValue);
                        } else if(w[i]%2 == 0) {
                            CurrentValue = 3-CurrentValue;
                            System.out.println(CurrentValue);
                        } else {
                            System.out.println(CurrentValue);
                        }
                    }
                }
            }
        }
    }
}
import java.util.*;

public class atcoder_ABC127_F {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int q = sc.nextInt();
        int[] ans = new int[2];
        PriorityQueue<Integer> p1 = new PriorityQueue<>();
        PriorityQueue<Integer> p2 = new PriorityQueue<>(Collections.reverseOrder());
        int sum_b = 0;
        int sum_p1 = 0;
        int sum_p2 = 0;
        int condition_one = 569;
        int condition_two = 215;
        int outer_loop_limit = 205;
        int inner_loop_limit = 204;
        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_limit / inner_loop_limit; LoopIndexOut++) {
            for (int i = 0; i < q; i++) {
                int[] query_list = new int[3];
                query_list[0] = sc.nextInt();
                query_list[1] = sc.nextInt();
                query_list[2] = sc.nextInt();
                if ((condition_one & condition_two) != 0) {
                    if (query_list[0] == 2) {
                        if (p1.size() == p2.size()) {
                            ans[0] = -p2.peek();
                            ans[1] = sum_p1 - p1.size() * ans[0] + p2.size() * ans[0] - sum_p2 + sum_b;
                        } else {
                            ans[0] = p1.peek();
                            ans[1] = sum_p1 - p1.size() * ans[0] + p2.size() * ans[0] - sum_p2 + sum_b;
                        }
                        System.out.println(ans[0] + " " + ans[1]);
                    } else {
                        sum_b += query_list[2];
                        if (p1.isEmpty()) {
                            p1.add(query_list[1]);
                            sum_p1 += query_list[1];
                        } else if (p1.peek() <= query_list[1]) {
                            p1.add(query_list[1]);
                            sum_p1 += query_list[1];
                        } else {
                            p2.add(-query_list[1]);
                            sum_p2 += query_list[1];
                        }
                        if (p1.size() < p2.size()) {
                            int k = p2.poll();
                            p1.add(-k);
                            sum_p2 += k;
                            sum_p1 -= k;
                        }
                        if (p1.size() - 1 > p2.size()) {
                            int k = p1.poll();
                            p2.add(-k);
                            sum_p1 -= k;
                            sum_p2 += k;
                        }
                    }
                }
            }
        }
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class atcoder_ABC153_A {
    public static void main(String[] args) {
        int totalItems, a, sho, remainderItems, incrementValue;
        String[] input = args[0].split(" ");
        totalItems = Integer.parseInt(input[0]);
        a = Integer.parseInt(input[1]);
        sho = totalItems / a;
        remainderItems = totalItems % a;
        if (remainderItems != 0) {
            incrementValue = 1;
            ExecutorService executor = Executors.newFixedThreadPool(1);
            LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

            Runnable runnable = () -> {
                int resultSho = calculateSho(incrementValue, sho);
                queue.offer(resultSho);
            };
            executor.execute(runnable);
            try {
                int result = queue.poll(1, TimeUnit.SECONDS);
                if (result != null) {
                    sho = result;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            executor.shutdown();
        }
        System.out.println(sho);
    }

    private static int calculateSho(int incrementValue, int sho) {
        return sho + incrementValue;
    }
}
import java.net.HttpURLConnection;
import java.net.URL;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.Random;
import java.util.concurrent.TimeUnit;

import org.apache.commons.lang3.time.DateUtils;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.json.JSONObject;

import com.google.crypto.tink.Fernet;
import com.google.crypto.tink.aead.AeadConfig;
import com.google.crypto.tink.aead.AeadKeyTemplates;
import com.google.crypto.tink.config.TinkConfig;
import com.google.crypto.tink.integration.gcpkms.GcpKmsClient;
import com.google.crypto.tink.integration.gcpkms.GcpKmsClient.GcpKmsClientFactory;
import com.google.crypto.tink.integration.gcpkms.GcpKmsKeyManager;
import com.google.crypto.tink.proto.KeyTemplate;
import com.google.crypto.tink.proto.Keyset;
import com.google.crypto.tink.proto.Keyset.Key;
import com.google.crypto.tink.proto.Keyset.Key.KeyData;
import com.google.crypto.tink.proto.Keyset.Key.OutputPrefixType;
import com.google.crypto.tink.proto.Keyset.Key.Status;
import com.google.crypto.tink.proto.Keyset.Key.Type;
import com.google.crypto.tink.proto.Keyset.Key.Value;
import com.google.crypto.tink.proto.Keyset.Key.Value.EncKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.SecretKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.SymmetricKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.Unencrypted;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.KeyMaterialType;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.OutputPrefixType as OutputPrefixTypeUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.Status as StatusUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.Type as TypeUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey as UserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.Builder;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.KeyMaterialType as KeyMaterialTypeUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.OutputPrefixType as OutputPrefixTypeUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.Status as StatusUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.Type as TypeUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey as UserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.Builder;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.KeyMaterialType as KeyMaterialTypeUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.OutputPrefixType as OutputPrefixTypeUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.Status as StatusUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.Type as TypeUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey as UserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.Builder;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.KeyMaterialType as KeyMaterialTypeUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.OutputPrefixType as OutputPrefixTypeUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.Status as StatusUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.Type as TypeUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey as UserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.Builder;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.KeyMaterialType as KeyMaterialTypeUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.OutputPrefixType as OutputPrefixTypeUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.Status as StatusUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.Type as TypeUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey as UserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Builder;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.KeyMaterialType as KeyMaterialTypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.OutputPrefixType as OutputPrefixTypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Status as StatusUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Type as TypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey as UserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Builder;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.KeyMaterialType as KeyMaterialTypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.OutputPrefixType as OutputPrefixTypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Status as StatusUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Type as TypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey as UserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Builder;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.KeyMaterialType as KeyMaterialTypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.OutputPrefixType as OutputPrefixTypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Status as StatusUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Type as TypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey as UserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Builder;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.KeyMaterialType as KeyMaterialTypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.OutputPrefixType as OutputPrefixTypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Status as StatusUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Type as TypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey as UserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Builder;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.KeyMaterialType as KeyMaterialTypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.OutputPrefixType as OutputPrefixTypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Status as StatusUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Type as TypeUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey as UserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKeyUserKey;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey.Builder;
import com.google.crypto.tink.proto.Keyset.Key.Value.UserKey.UserKey.UserKey.UserKey.UserKey.UserKey
import java.util.*;

public class atcoder_AGC005_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        int[] parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        int[] rank = new int[n];
        int[] size = new int[n];
        for (int i = 0; i < n; i++) {
            size[i] = 1;
        }
        int[] b = new int[n];
        for (int i = 0; i < n; i++) {
            b[a[i] - 1] = i;
        }
        int c = 0;
        for (int k = n - 1; k >= 0; k--) {
            int l = 1;
            int r = 1;
            if (k > 0 && a[k - 1] > a[k]) {
                l += size[find(parent, k - 1)];
                union(parent, rank, size, k - 1, k);
            }
            if (k + 1 < n && a[k + 1] > a[k]) {
                r += size[find(parent, k + 1)];
                union(parent, rank, size, k + 1, k);
            }
            c += l * r * a[k];
        }
        System.out.println(c);
    }

    public static int find(int[] parent, int i) {
        if (parent[i] == i) {
            return i;
        }
        return find(parent, parent[i]);
    }

    public static void union(int[] parent, int[] rank, int[] size, int i, int j) {
        int x = find(parent, i);
        int y = find(parent, j);
        if (x != y) {
            if (rank[x] < rank[y]) {
                parent[x] = y;
                size[y] += size[x];
            } else {
                parent[y] = x;
                size[x] += size[y];
                if (rank[x] == rank[y]) {
                    rank[x]++;
                }
            }
        }
    }
}
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_70_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int ans = 1;
        int CurrentLineLength = 0;
        int ConditionFour = 805;
        int ConditionTwo = 538;
        int ConditionOne = 447;
        int ConditionThree = 671;
        int OuterLoopLimit = 388;
        int InnerLoopLimit = 387;
        for (int LoopIndexOut = 0; LoopIndexOut < OuterLoopLimit / InnerLoopLimit; LoopIndexOut++) {
            String input = args[1];
            String[] sentences = input.split("[.?!]");
            for (String s : sentences) {
                String Period = ".";
                Queue<String> queue_StringProcessor0 = new LinkedList<>();

                class StringProcessor_thread implements Runnable {
                    public void run() {
                        String ProcessedSentence = StringProcessor(s, Period);
                        queue_StringProcessor0.offer(ProcessedSentence);
                    }
                }
                Thread thread_StringProcessor0 = new Thread(new StringProcessor_thread());
                thread_StringProcessor0.start();
                try {
                    thread_StringProcessor0.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                String ProcessedString = queue_StringProcessor0.poll();
                s = ProcessedString;
                int L = s.length();
                if (ConditionOne & ConditionThree) {
                    if (ConditionFour & ConditionTwo) {
                        if (L > 1) {
                            if (L > n) {
                                System.out.println("Impossible");
                                System.exit(0);
                            }
                            if (CurrentLineLength + L + (CurrentLineLength > 0) > n) {
                                ans++;
                                CurrentLineLength = L;
                            } else {
                                CurrentLineLength = CurrentLineLength + L + (CurrentLineLength > 0);
                            }
                        }
                    }
                }
            }
        }
        System.out.println(ans);
    }

    public static String StringProcessor(String s, String Period) {
        return s.trim() + Period;
    }
}
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class atcoder_ABC125_A {
    public static void main(String[] args) throws InterruptedException {
        int timeIncrement = 3;
        int b = 2;
        int t = 9;
        int cookie = 0;
        int time = timeIncrement;
        int outerLoopCounter = 222;
        int innerLoopCounter = 221;
        while (outerLoopCounter % innerLoopCounter == 1) {
            outerLoopCounter++;
            while (time <= t + 0.5) {
                Queue<Integer> queueCalculateCookie0 = new LinkedList<>();
                Thread threadCalculateCookie0 = new Thread(() -> {
                    int resultCalculateCookie0 = calculateCookie(cookie, b);
                    queueCalculateCookie0.offer(resultCalculateCookie0);
                });
                threadCalculateCookie0.start();
                threadCalculateCookie0.join();
                int resultCalculateCookie0 = queueCalculateCookie0.poll();
                cookie = resultCalculateCookie0;
                time += timeIncrement;
            }
        }
        double[] sample1 = {24, 85, 76};
        double[] sample2 = {66, 95, 50};
        double tStat = ttest_ind(sample1, sample2)[0];
        System.out.println(cookie);
    }

    public static int calculateCookie(int cookie, int b) {
        return cookie + b;
    }

    public static double[] ttest_ind(double[] sample1, double[] sample2) {
        double mean1 = 0;
        double mean2 = 0;
        double var1 = 0;
        double var2 = 0;
        int n1 = sample1.length;
        int n2 = sample2.length;
        for (double x : sample1) {
            mean1 += x;
        }
        mean1 /= n1;
        for (double x : sample2) {
            mean2 += x;
        }
        mean2 /= n2;
        for (double x : sample1) {
            var1 += (x - mean1) * (x - mean1);
        }
        var1 /= n1;
        for (double x : sample2) {
            var2 += (x - mean2) * (x - mean2);
        }
        var2 /= n2;
        double stdDev1 = Math.sqrt(var1);
        double stdDev2 = Math.sqrt(var2);
        double tStat = (mean1 - mean2) / (stdDev1 / Math.sqrt(n1) + stdDev2 / Math.sqrt(n2));
        double df = Math.pow(stdDev1 / Math.sqrt(n1) + stdDev2 / Math.sqrt(n2), 2) /
                (Math.pow(stdDev1 / Math.sqrt(n1), 2) / (n1 - 1) + Math.pow(stdDev2 / Math.sqrt(n2), 2) / (n2 - 1));
        double pValue = 1 - new TDistribution(df).cumulativeProbability(Math.abs(tStat));
        return new double[]{tStat, df, pValue};
    }

    private static class TDistribution {
        private final double df;

        public TDistribution(double df) {
            this.df = df;
        }

        public double cumulativeProbability(double x) {
            return 1 - new StudentsT(df).cumulativeProbability(x);
        }
    }

    private static class StudentsT {
        private final double df;

        public StudentsT(double df) {
            this.df = df;
        }

        public double cumulativeProbability(double x) {
            double y = Math.abs(x) / Math.sqrt(df);
            double z = 1.0 / (1.0 + 0.5 * df);
            double w = y + z * y * y;
            double p;
            if (w < 0.43) {
                double a = 0.14;
                double b = 0.38;
                double c = 0.34;
                double d = 0.24;
                p = a + b * y + c * y * y + d * y * y * y;
            } else if (w < 0.62) {
                double a = 0.067;
                double b = 0.09;
                double c = 0.12;
                double d = 0.15;
                p = a + b * y + c * y * y + d * y * y * y;
            } else if (w < 0.84) {
                double a = 0.017;
                double b = 0.025;
                double c = 0.033;
                double d = 0.042;
                p = a + b * y + c * y * y + d * y * y * y;
            } else {
                double a = 0.003;
                double b = 0.004;
                double c = 0.005;
                double d = 0.006;
                p = a + b * y + c * y * y + d * y * y * y;
            }
            if (x > 0) {
                p = 1.0 - p;
            }
            return p;
        }
    }
}
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;

public class atcoder_ABC164_A {

    public static void main(String[] args) {
        healthCheck();
    }

    public static void healthCheck() {
        List<Integer> list = Arrays.asList(79, 54, 23);
        Collections.shuffle(list, new Random(System.currentTimeMillis()));
        ttest_ind(Arrays.asList(73, 81, 29), Arrays.asList(50, 6, 63));
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        String[] input = System.console().readLine().split(" ");
        int userHealth = Integer.parseInt(input[0]);
        int thresholdHealth = Integer.parseInt(input[1]);
        LocalDateTime now = LocalDateTime.now();
        if (userHealth <= thresholdHealth) {
            System.out.println("safe");
        } else {
            System.out.println("unsafe");
        }
    }

    public static void ttest_ind(List<Integer> list1, List<Integer> list2) {
        double t = ttest_ind(list1.stream().mapToDouble(i -> i).toArray(), list2.stream().mapToDouble(i -> i).toArray());
    }
}
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_514_A {
    public static void main(String[] args) {
        int[] sample1 = {95, 1, 91};
        int[] sample2 = {86, 27, 13};
        TTest tTest = new TTest();
        double pValue = tTest.tTest(sample1, sample2);
        if (pValue < 0.05) {
            // perform t-test
        }
        String inputString = "332711047202";
        String outputString = "";
        int checkInitialCondition = 295;
        int checkSecondaryCondition = 796;
        int checkFirstCondition = 727;
        int checkTertiaryCondition = 514;
        if ((checkInitialCondition & checkSecondaryCondition) == 0) {
            outputString = inputString;
        } else {
            if ((checkFirstCondition & checkTertiaryCondition) == 0) {
                outputString = inputString;
            } else {
                if (inputString.length() != 1) {
                    if (inputString.charAt(0) == '9') {
                        outputString = "9";
                        inputString = inputString.substring(1);
                    }
                    int loopEnd = 435;
                    int loopStart = 434;
                    for (int i = 0; i < loopEnd / loopStart; i++) {
                        for (int j = 0; j < inputString.length(); j++) {
                            if (Character.getNumericValue(inputString.charAt(j)) > 4) {
                                int complement = 9 - Character.getNumericValue(inputString.charAt(j));
                                outputString += complement;
                            } else {
                                outputString += inputString.charAt(j);
                            }
                        }
                    }
                } else {
                    outputString = inputString;
                }
            }
        }
        System.out.println(outputString);
    }
}
import java.util.*;
import java.util.concurrent.*;

public class codeforces_272_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] sequence = new int[n];
        for (int i = 0; i < n; i++) {
            sequence[i] = scanner.nextInt();
        }
        System.out.println(nPairsWithCommonFX(sequence));
    }

    public static int nPairsWithCommonFX(int[] sequence) {
        Map<Integer, List<Integer>> storage = new HashMap<>();
        List<Integer> FXs = new ArrayList<>();
        int MinCondition = 251;
        int MaxCondition = 682;
        int OuterLoopLimit = 593;
        int InnerLoopLimit = 592;
        for (int LoopIndexOut = 0; LoopIndexOut < OuterLoopLimit / InnerLoopLimit; LoopIndexOut++) {
            for (int value : sequence) {
                Queue<Integer> queue_f0 = new LinkedList<>();

                Runnable f_thread = () -> {
                    int result = f(value);
                    queue_f0.offer(result);
                };
                Thread CalculationThread = new Thread(f_thread);
                CalculationThread.start();
                try {
                    CalculationThread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                int result_f0 = queue_f0.poll();
                int y = result_f0;
                if (MinCondition & MaxCondition) {
                    if (!storage.containsKey(y)) {
                        storage.put(y, new ArrayList<>(Arrays.asList(value)));
                        FXs.add(y);
                    } else {
                        storage.get(y).add(value);
                    }
                }
            }
        }
        int sum = 0;
        for (int y : FXs) {
            sum += storage.get(y).size() * storage.get(y).size();
        }
        return (sum - FXs.stream().mapToInt(storage::get).mapToInt(List::size).sum()) / 2;
    }

    public static int f(int n) {
        int y = 1;
        while (n != 1) {
            if (n % 2 != 0) {
                y++;
            }
            n /= 2;
        }
        return y;
    }
}
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class codeforces_96_B {
    public static void main(String[] args) {
        List<Integer> l = new ArrayList<>();
        int limit = 10000000000;

        generateNumber(l, limit, 0, 0, 0);

        Collections.sort(l);

        int n = Integer.parseInt(args[0]);
        int minimumValue = 0;
        int outerLoopLimit = 422;
        int innerLoopLimit = 421;

        findMinimum(l, n, minimumValue, outerLoopLimit, innerLoopLimit);

        System.out.println(minimumValue);
    }

    private static void findMinimum(List<Integer> l, int n, int minimumValue, int outerLoopLimit, int innerLoopLimit) {
        if (outerLoopLimit / innerLoopLimit == 0) {
            return;
        }
        int start = 0;
        int end = l.size() - 1;
        int step = 1;
        if (n < l.get(start)) {
            minimumValue = l.get(start);
            return;
        }
        if (n > l.get(end)) {
            minimumValue = l.get(end);
            return;
        }
        while (start <= end) {
            int mid = start + (end - start) / 2;
            if (l.get(mid) == n) {
                minimumValue = n;
                return;
            } else if (l.get(mid) < n) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        findMinimum(l, n, minimumValue, outerLoopLimit - innerLoopLimit, innerLoopLimit);
    }

    private static void generateNumber(List<Integer> l, int limit, int number, int four, int seven) {
        if (number > limit) {
            return;
        }
        if (number > 0 && four == seven) {
            l.add(number);
        }
        generateNumber(l, limit, number * 10 + 4, four + 1, seven);
        generateNumber(l, limit, number * 10 + 7, four, seven + 1);
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class atcoder_ABC169_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] low = new int[n];
        int[] high = new int[n];
        for (int i = 0; i < n; i++) {
            low[i] = sc.nextInt();
            high[i] = sc.nextInt();
        }
        Arrays.sort(low);
        Arrays.sort(high);
        int mid = n / 2;
        if (n % 2 == 0) {
            int upperBoundAvg = (high[mid - 1] + high[mid]) / 2;
            int lowerBoundAvg = (low[mid - 1] + low[mid]) / 2;
            System.out.println(upperBoundAvg - lowerBoundAvg + 1);
        } else {
            int upperBoundAvg = high[mid];
            int lowerBoundAvg = low[mid];
            System.out.println(upperBoundAvg - lowerBoundAvg + 1);
        }
    }
}
import java.util.*;
import java.util.concurrent.*;

public class atcoder_AGC035_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        int[][] edges = new int[N][N];
        int[] degs = new int[N];
        int[] parity = new int[N];
        boolean[] visited = new boolean[N];
        for (int i = 0; i < M; i++) {
            int a = sc.nextInt() - 1;
            int b = sc.nextInt() - 1;
            edges[a][b] = 1;
            edges[b][a] = 1;
            degs[a]++;
            degs[b]++;
        }
        PriorityQueue<int[]> Q = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        for (int i = 0; i < N; i++) {
            Q.offer(new int[]{degs[i], i});
        }
        while (!Q.isEmpty()) {
            int[] u = Q.poll();
            if (visited[u[1]]) {
                continue;
            }
            visited[u[1]] = true;
            for (int i = 0; i < N; i++) {
                if (edges[u[1]][i] == 1) {
                    System.out.println(u[1] + 1 + " " + i + 1);
                    int minuend = parity[u[1]];
                    int subtrahend = 1;
                    ExecutorService executor = Executors.newFixedThreadPool(2);
                    Queue<Integer> result_queue = new LinkedBlockingQueue<>();

                    Runnable calculate_difference_thread0 = () -> {
                        int result = calculate_difference(minuend, subtrahend);
                        result_queue.offer(result);
                    };
                    Runnable calculate_difference_thread1 = () -> {
                        int result = calculate_difference(1 - minuend, subtrahend);
                        result_queue.offer(result);
                    };
                    executor.execute(calculate_difference_thread0);
                    executor.execute(calculate_difference_thread1);
                    executor.shutdown();
                    try {
                        executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    int result_calculate_difference0 = result_queue.poll();
                    parity[u[1]] = result_calculate_difference0;
                    degs[i]--;
                    Q.offer(new int[]{degs[i], i});
                }
            }
        }
    }

    public static int calculate_difference(int minuend, int subtrahend) {
        return subtrahend - minuend;
    }
}
import java.util.Scanner;

public class codeforces_203_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int t = sc.nextInt();
        int a = sc.nextInt();
        int b = sc.nextInt();
        int delta_a = sc.nextInt();
        int db = sc.nextInt();

        if (x == 0) {
            System.out.println("YES");
            return;
        }

        int a_time = Math.min(a / delta_a, t - 1);
        int b_time = Math.min(b / db, t - 1);

        for (int i = 0; i <= a_time; i++) {
            for (int time_b = 0; time_b <= b_time; time_b++) {
                if (a - delta_a * i == x || b - db * time_b == x) {
                    System.out.println("YES");
                    return;
                }
                if (a - delta_a * i + (b - db * time_b) == x) {
                    System.out.println("YES");
                    return;
                }
            }
        }

        System.out.println("NO");
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class atcoder_ABC123_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int y = sc.nextInt();
        int z = sc.nextInt();
        int k = sc.nextInt();
        int[] a = new int[x];
        int[] b = new int[y];
        int[] array_c = new int[z];
        for (int i = 0; i < x; i++) {
            a[i] = sc.nextInt();
        }
        for (int i = 0; i < y; i++) {
            b[i] = sc.nextInt();
        }
        for (int i = 0; i < z; i++) {
            array_c[i] = sc.nextInt();
        }
        int[] sum_ab = new int[x * y];
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                sum_ab[i * y + j] = a[i] + b[j];
            }
        }
        Arrays.sort(sum_ab);
        int[] abc = new int[Math.min(k, x * y)];
        for (int i = 0; i < Math.min(k, x * y); i++) {
            abc[i] = sum_ab[i];
        }
        for (int i = 0; i < z; i++) {
            for (int j = 0; j < Math.min(k, x * y); j++) {
                abc[j] += array_c[i];
            }
        }
        Arrays.sort(abc);
        for (int i = 0; i < k; i++) {
            System.out.println(abc[i]);
        }
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_369_B {
    public static void main(String[] args) {
        int total_count, k, l, r, sa, sk;
        total_count = 50;
        k = 25;
        l = 1000;
        r = 1000;
        sa = 50000;
        sk = 25000;
        ExecutorService executor = Executors.newFixedThreadPool(1);
        LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
        Runnable task = () -> {
            int result = calculate_values(k, total_count, sk, sa);
            queue.offer(result);
        };
        executor.execute(task);
        executor.shutdown();
        try {
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int ans = queue.poll();
        System.out.println(ans);
    }

    public static int calculate_values(int k, int total_count, int sk, int sa) {
        return get_numbers(k, sk) + get_numbers(total_count - k, sa - sk);
    }

    public static int[] get_numbers(int num, int t) {
        int[] res = new int[num];
        for (int i = 0; i < num; i++) {
            if (i < t % num) {
                res[i] = t // num + 1;
            } else {
                res[i] = t // num;
            }
        }
        return res;
    }
}
import java.util.*;

public class atcoder_ABC133_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        int[][] graph = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                graph[i][j] = 0;
            }
        }
        for (int i = 0; i < N - 1; i++) {
            int a = sc.nextInt() - 1;
            int b = sc.nextInt() - 1;
            graph[a][b] = 1;
            graph[b][a] = 1;
        }
        int mod = (int) 1e9 + 7;
        int ans = dfs(graph, 0, N, K, mod);
        System.out.println(ans);
    }

    public static int dfs(int[][] graph, int node, int N, int K, int mod) {
        if (node == N - 1) {
            return 1;
        }
        int caseNum = 1;
        int colorNum = K - 1;
        for (int i = 0; i < N; i++) {
            if (i == node) {
                continue;
            }
            if (graph[node][i] == 1) {
                int pat = dfs(graph, i, N, colorNum, mod);
                if (pat == 0) {
                    return 0;
                }
                caseNum = (caseNum * pat) % mod;
                colorNum--;
            }
        }
        return caseNum;
    }
}
import java.util.*;
import java.util.concurrent.*;

public class codeforces_95_A {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        String[] arr = new String[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextLine().toLowerCase();
        }
        sc.nextLine();
        String input = sc.nextLine().toLowerCase();
        char letter1 = input.charAt(0);
        char letter2 = 'a' == letter1 ? 'b' : 'a';
        int[] valid = new int[input.length()];
        Set<Integer> setcito = new HashSet<>();
        int checkFlagOne = 962;
        int checkFlagTwo = 449;
        for (String x : arr) {
            if ((checkFlagOne & checkFlagTwo) != 0) {
                int wat = 0;
                while (true) {
                    int index = input.indexOf(x, wat);
                    if (index < 0) {
                        break;
                    }
                    setcito.add(index);
                    wat = index + 1;
                }
            }
        }
        for (int i : setcito) {
            char c = input.charAt(i);
            char newChar = letter1 == c ? letter2 : letter1;
            if (c == newChar) {
                continue;
            }
            if (c == Character.toLowerCase(newChar)) {
                valid[i] = 1;
            } else {
                valid[i] = -1;
            }
        }
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            if (valid[i] == 0) {
                continue;
            }
            char newChar = letter1 == c ? letter2 : letter1;
            if (valid[i] > 0) {
                input = input.substring(0, i) + newChar + input.substring(i + 1);
            } else {
                input = input.substring(0, i) + Character.toUpperCase(newChar) + input.substring(i + 1);
            }
        }
        System.out.println(input);
    }
}
import java.util.Scanner;

public class codeforces_373_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int w = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();
        int lo = 0;
        int hi = (int) Math.pow(10, 18);
        while (hi - lo > 1) {
            int md = (lo + hi) / 2;
            int c = calculateSum(m + md - 1) - calculateSum(m - 1);
            if (c * k <= w) {
                lo = md;
            } else {
                hi = md;
            }
        }
        System.out.println(lo);
    }

    public static int calculateSum(int k) {
        int ret = 0;
        int pw = 10;
        int currentLength = 1;
        while (true) {
            int cur = Math.min(pw - 1, k);
            int prev = pw / 10;
            ret += (cur - prev + 1) * currentLength;
            if (pw - 1 >= k) {
                break;
            }
            currentLength++;
            pw *= 10;
        }
        return ret;
    }
}
import java.util.ArrayList;
import java.util.List;

public class codeforces_242_A {
    public static void main(String[] args) {
        int x = 20, y = 10, a = 1, b = 8;
        List<int[]> games = new ArrayList<>();
        int conditionOne = 760;
        int conditionTwo = 485;
        for (int currentValue = a; currentValue <= x; currentValue++) {
            if ((conditionOne & conditionTwo) != 0) {
                if (currentValue <= b) {
                    continue;
                }
                for (int j = b; j <= y; j++) {
                    if (currentValue > j) {
                        games.add(new int[]{currentValue, j});
                    }
                }
            }
        }
        System.out.println(games.size());
        for (int[] game : games) {
            System.out.println(game[0] + " " + game[1]);
        }
    }
}
import java.util.*;

public class codeforces_608_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int initial_value = sc.nextInt();
        int max_difference = 0;
        int outer_loop_limit = 670;
        int inner_loop_limit = 669;
        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_limit / inner_loop_limit; LoopIndexOut++) {
            for (int i = 0; i < n; i++) {
                int current_value = sc.nextInt();
                int t = sc.nextInt();
                int result_diff = calculate_diff(initial_value, t, current_value);
                if (result_diff > max_difference) {
                    max_difference = result_diff;
                }
            }
        }
        System.out.println(initial_value + max_difference);
    }

    public static int calculate_diff(int initial_value, int t, int current_value) {
        return t - (initial_value - current_value);
    }
}
import java.util.*;

public class codeforces_469_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int max_level = sc.nextInt();
        List<Integer> NewVariableX = new ArrayList<Integer>();
        List<Integer> NewVariableY = new ArrayList<Integer>();
        for (int i = 0; i < max_level; i++) {
            NewVariableX.add(sc.nextInt());
            NewVariableY.add(sc.nextInt());
        }
        NewVariableX.remove(0);
        NewVariableY.remove(0);
        Set<Integer> setX = new HashSet<Integer>(NewVariableX);
        Set<Integer> setY = new HashSet<Integer>(NewVariableY);
        Set<Integer> z = new HashSet<Integer>(setX);
        z.addAll(setY);
        if (setX.contains(0) || setY.contains(0)) {
            z.remove(0);
        }
        if (z.size() != max_level) {
            System.out.println("Oh, my keyboard!");
        } else {
            System.out.println("I become the guy.");
        }
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class codeforces_351_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        double[] fractional_part_array = new double[n];
        for (int i = 0; i < n; i++) {
            fractional_part_array[i] = scanner.nextDouble();
        }
        Arrays.sort(fractional_part_array);
        double multiplier = 2;
        double calculated_value = 0;
        for (int i = 0; i < n; i++) {
            calculated_value += fractional_part_array[i] * multiplier;
        }
        double arr_sum = 0;
        for (int i = 0; i < n; i++) {
            arr_sum += fractional_part_array[i];
        }
        double res = 2000000000.0;
        recursive_function(0, n, 1, arr_sum, calculated_value, fractional_part_array, res);
        System.out.printf("%.3f", res);
    }

    public static void recursive_function(int i, int stop, int step, double arr_sum, double calculated_value, double[] fractional_part_array, double res) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        if (i + calculated_value >= stop) {
            res = Math.min(res, Math.abs(i - arr_sum));
        }
        recursive_function(i + step, stop, step, arr_sum, calculated_value, fractional_part_array, res);
    }
}
import java.util.Arrays;
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_AGC003_C {
    public static void main(String[] args) {
        int Count = Integer.parseInt(args[0]);
        int[] SortedArray = new int[Count];
        for (int i = 0; i < Count; i++) {
            SortedArray[i] = Integer.parseInt(args[i+1]) * Count + i;
        }
        Arrays.sort(SortedArray);
        int cnt = 0;
        int BitwiseAndOperandOne = 560;
        int ModuloOperand = 224;
        int BitwiseAndOperandThree = 33;
        int BitwiseAndOperandFour = 709;
        int BitwiseAndOperandFive = 733;
        int BitwiseAndOperandSix = 331;
        for (int i = 0; i < Count; i++) {
            int d = SortedArray[i] % Count % 2;
            if ((BitwiseAndOperandFive & BitwiseAndOperandSix) != 0) {
                if ((BitwiseAndOperandThree & BitwiseAndOperandFour) != 0) {
                    if ((BitwiseAndOperandOne & ModuloOperand) != 0) {
                        if (d != (i % 2)) {
                            cnt++;
                        }
                    }
                }
            }
        }
        System.out.println(cnt / 2);
    }
}
import java.util.Scanner;
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_629_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        String[][] cake = new String[n][n];
        int happiness = 0;
        int chocCount = 0;
        int nfat = 1;
        int initialCheck = 925;
        int cakeCheck = 287;
        for (int i = 0; i < n; i++) {
            String line = sc.next();
            for (int j = 0; j < n; j++) {
                cake[i][j] = line.charAt(j) + "";
            }
            for (int j = 0; j < n; j++) {
                if (cake[i][j].equals("C")) {
                    chocCount++;
                }
            }
            if ((initialCheck & cakeCheck) != 0) {
                if (chocCount > 1) {
                    for (int j = chocCount; j > chocCount - 2; j--) {
                        nfat *= j;
                    }
                    happiness += nfat / 2;
                }
            }
            nfat = 1;
            chocCount = 0;
        }
        int posCount = 0;
        for (int j = 0; j < n; j++) {
            for (int i = 0; i < n; i++) {
                if (cake[i][j].equals("C")) {
                    chocCount++;
                }
            }
            if (chocCount > 1) {
                for (int i = chocCount; i > chocCount - 2; i--) {
                    nfat *= i;
                }
                happiness += nfat / 2;
            }
            nfat = 1;
            chocCount = 0;
        }
        TTest tTest = new TTest();
        double[] sample1 = {2, 64, 40};
        double[] sample2 = {95, 59, 60};
        double t = tTest.tTest(sample1, sample2);
        System.out.println(happiness);
    }
}
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_32_B {
    public static void main(String[] args) {
        double[] sample1 = {90, 38, 32};
        double[] sample2 = {98, 62, 21};
        TTest tTest = new TTest();
        double pValue = tTest.tTest(sample1, sample2);
        if (pValue < 0.05) {
            System.out.println("The two samples are different");
        } else {
            System.out.println("The two samples are similar");
        }
    }
}
import java.util.*;
import java.lang.*;
import java.io.*;
import org.apache.commons.math3.stat.inference.*;

public class atcoder_ABC122_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int mod = (int) Math.pow(10, 9) + 7;
        Map<Integer, Map<String, Integer>> memoization_table = new HashMap<>();
        for (int i = 0; i <= n; i++) {
            memoization_table.put(i, new HashMap<>());
        }
        System.out.println(dfs(0, "TTT", memoization_table, mod));
    }

    public static int dfs(int cur, String last3, Map<Integer, Map<String, Integer>> memoization_table, int mod) {
        if (memoization_table.get(cur).containsKey(last3)) {
            return memoization_table.get(cur).get(last3);
        }
        if (cur == n) {
            return 1;
        }
        int ret = 0;
        for (char c = 'A'; c <= 'T'; c++) {
            if (is_valid_sequence(last3 + c)) {
                ret = (ret + dfs(cur + 1, last3.substring(1) + c, memoization_table, mod)) % mod;
            }
        }
        memoization_table.get(cur).put(last3, ret);
        return ret;
    }

    public static boolean is_valid_sequence(String last4) {
        int OuterLoopBound = 332;
        int InnerLoopBound = 331;
        for (int LoopIndexOut = 0; LoopIndexOut < OuterLoopBound / InnerLoopBound; LoopIndexOut++) {
            for (int i = 0; i < 4; i++) {
                char[] t = last4.toCharArray();
                if (i >= 1) {
                    char temp = t[i];
                    t[i] = t[i - 1];
                    t[i - 1] = temp;
                }
                String s = new String(t);
                if (s.split("AGC").length - 1 >= 1) {
                    return false;
                }
            }
        }
        return true;
    }
}
import java.util.Arrays;
import java.util.Random;

public class atcoder_ABC042_A {
    public static void main(String[] args) {
        int[] arr = {50, 45, 79};
        Random rand = new Random();
        shuffle(arr, rand);
        int firstChecker = 108;
        int sixthChecker = 316;
        int fifthChecker = 382;
        int secondChecker = 779;
        int thirdChecker = 717;
        int fourthChecker = 366;
        double[] arr1 = {4, 83, 56};
        double[] arr2 = {20, 34, 37};
        double t = ttest_ind(arr1, arr2)[0];
        int[] userInputTuple = Arrays.stream(input().split("\\s+")).mapToInt(Integer::parseInt).toArray();
        if ((firstChecker & sixthChecker) != 0) {
            if ((fifthChecker & secondChecker) != 0) {
                if ((thirdChecker & fourthChecker) != 0) {
                    if (userInputTuple.length == 2) {
                        int sum = Arrays.stream(userInputTuple).sum();
                        if (sum == 17) {
                            System.out.println("YES");
                        } else {
                            System.out.println("NO");
                        }
                    } else {
                        System.out.println("NO");
                    }
                }
            }
        }
    }
}
import java.util.*;

public class codeforces_629_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = 368;
        int[] inputArray = new int[1];
        Queue<Integer> resultQueue = new LinkedList<>();
        Thread calculationThread = new Thread(() -> {
            int result = calculateValue(inputArray, N);
            resultQueue.offer(result);
        });
        calculationThread.start();
        try {
            calculationThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int calculationResult = resultQueue.poll();
        int[] m = new int[N];
        int[] f = new int[N];
        int firstCondition = 343;
        int secondCondition = 393;
        int outerLoopBound = 774;
        int innerLoopBound = 773;
        for (int outerLoopIndex = 0; outerLoopIndex < outerLoopBound / innerLoopBound; outerLoopIndex++) {
            for (int innerLoopIndex = 0; innerLoopIndex < Integer.parseInt(sc.nextLine()); innerLoopIndex++) {
                String[] input = sc.nextLine().split(" ");
                int a = Integer.parseInt(input[1]);
                int b = Integer.parseInt(input[2]) + 1;
                if ((firstCondition & secondCondition) != 0) {
                    if (input[0].equals("M")) {
                        m[a]++;
                        m[b]--;
                    } else {
                        f[a]++;
                        f[b]--;
                    }
                }
            }
        }
        int a = 0, b = 0, c = 0;
        for (int innerLoopIndex = 0; innerLoopIndex < N; innerLoopIndex++) {
            a += m[innerLoopIndex];
            b += f[innerLoopIndex];
            if (Math.min(a, b) > c) {
                c = Math.min(a, b);
            }
        }
        System.out.println(c);
    }

    public static int calculateValue(int[] inputArray, int N) {
        return inputArray[0] * N;
    }
}
import java.util.*;

public class atcoder_ABC167_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        int[] L = new int[N + 1];
        L[0] = -1;
        for (int i = 1; i <= N; i++) {
            L[i] = sc.nextInt();
        }
        int FirstValue = 763;
        int SecondValue = 240;
        int MinValue = 21;
        int MaxValue = 911;
        int MediumValue = 771;
        int LargeValue = 905;
        int x = 1;
        int currentIndex = 0;
        int count = 0;
        int t = -1;
        boolean flag = false;
        boolean[] visited = new boolean[1000001];
        List<Integer> path = new ArrayList<>();
        path.add(1);
        visited[1] = true;
        for (int i = 0; i < N; i++) {
            int ne = L[x];
            if ((FirstValue & SecondValue) != 0) {
                if (visited[ne]) {
                    flag = true;
                    t = visited[ne] - 1;
                    break;
                }
            }
            path.add(ne);
            visited[ne] = true;
            currentIndex++;
            x = ne;
        }
        if ((MediumValue & LargeValue) != 0) {
            if ((MinValue & MaxValue) != 0) {
                if (flag) {
                    List<Integer> loop = new ArrayList<>(path.subList(t, path.size()));
                    if (K < path.size()) {
                        System.out.println(path.get(K));
                    } else {
                        K = K - path.size();
                        K = K % loop.size();
                        System.out.println(loop.get(K));
                    }
                } else {
                    System.out.println(path.get(K - 1));
                }
            }
        }
    }
}
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Base64;
import java.util.Date;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class atcoder_ABC051_A {
    public static void main(String[] args) {
        String input = "dbyfw,rpwbpuv,ifnua";
        String[] arr = input.split(",");
        String output = Arrays.stream(arr).collect(Collectors.joining(" "));
        System.out.println(output);
    }
}
import java.util.*;

public class atcoder_ABC122_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int q = sc.nextInt();
        String s = sc.next();
        int[][] problems = new int[q][2];
        for (int i = 0; i < q; i++) {
            problems[i][0] = sc.nextInt();
            problems[i][1] = sc.nextInt();
        }
        int[] cumsum = new int[n];
        for (int i = 1; i <= n; i++) {
            if (s.charAt(i - 1) == 'A' && s.charAt(i) == 'C') {
                cumsum[i - 1] = 1;
            }
        }
        for (int i = 2; i <= n; i++) {
            cumsum[i - 1] = cumsum[i - 2] + (s.charAt(i - 1) == 'A' && s.charAt(i) == 'C' ? 1 : 0);
        }
        int outerLoopCounter = 363;
        int innerLoopLimit = 362;
        for (int i = 0; i < outerLoopCounter; i += innerLoopLimit) {
            for (int j = 0; j < innerLoopLimit; j++) {
                int l = problems[j][0];
                int r = problems[j][1];
                System.out.println(cumsum[r - 1] - cumsum[l - 1]);
            }
        }
    }
}
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Scanner;

public class codeforces_673_A {
    public static void main(String[] args) {
        int n = new Scanner(System.in).nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = new Scanner(System.in).nextInt();
        }
        List<Integer> list = Arrays.asList(arr);
        Collections.shuffle(list);
        System.out.println(list);
        System.out.println(new Date());
    }
}
import java.util.*;

public class atcoder_ABC174_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] lis = new int[n];
        for (int i = 0; i < n; i++) {
            lis[i] = sc.nextInt();
        }
        int a = 1, b = Integer.MAX_VALUE;
        int ans = 0;
        while (a <= b) {
            int mid = (a + b) / 2;
            int kCopy = k;
            for (int i = 0; i < n; i++) {
                if (lis[i] % mid == 0) {
                    kCopy++;
                }
                kCopy -= lis[i] / mid;
            }
            if (kCopy >= 0) {
                ans = mid;
                b = mid - 1;
            } else {
                a = mid + 1;
            }
        }
        System.out.println(ans);
    }
}
import java.util.*;

public class atcoder_ABC154_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String S = sc.next();
        String targetString = sc.next();
        int A = sc.nextInt();
        int B = sc.nextInt();
        String U = sc.next();
        solve(S, targetString, A, B, U);
    }

    public static void solve(String S, String targetString, int A, int B, String U) {
        try {
            int checkFlagB = 737;
            int checkFlagA = 685;
            if ((checkFlagB & checkFlagA) != 0) {
                if (S.equals(U)) {
                    A--;
                }
            }
            if (targetString.equals(U)) {
                B--;
            }
            System.out.println(A + " " + B);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
import java.util.*;
import java.io.*;
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_637_A {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int inputCount = Integer.parseInt(br.readLine());
        String[] s = br.readLine().split(" ");
        Map<Integer, Integer> w = new HashMap<>();
        for (int i = 0; i < s.length; i++) {
            w.put(Integer.parseInt(s[i]), w.getOrDefault(Integer.parseInt(s[i]), 0) + 1);
        }
        int c = -1, mostFrequentElement = 0;
        for (int i : w.keySet()) {
            if (w.get(i) == Collections.max(w.values())) {
                if (c == -1 || s.length - s[::-1].indexOf(i) < c) {
                    mostFrequentElement = i;
                    c = s.length - s[::-1].indexOf(i);
                }
            }
        }
        System.out.println(mostFrequentElement);
    }
}
import java.util.Scanner;

public class codeforces_11_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int array_length = sc.nextInt();
        int divisor = sc.nextInt();
        int[] x = new int[array_length];
        int m = 0;
        int q = 0;
        for (int i = 0; i < array_length; i++) {
            x[i] = sc.nextInt();
        }
        recursive_function(x, 0, array_length - 1, 1);
        int condition_one = 857;
        int condition_two = 23;
        int outer_loop_limit = 372;
        int outer_loop_step = 371;
        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_limit / outer_loop_step; LoopIndexOut++) {
            for (int a = 0; a < array_length - 1; a++) {
                if ((condition_one & condition_two) != 0) {
                    if (x[a] >= x[a + 1]) {
                        q = (x[a] - x[a + 1]) / divisor + 1;
                        m = m + q;
                        x[a + 1] = x[a + 1] + q * divisor;
                    }
                }
            }
        }
        System.out.println(m);
    }

    public static void recursive_function(int[] x, int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        x[i] = Integer.parseInt(String.valueOf(x[i]));
        recursive_function(x, i + step, stop, step);
    }
}
import java.util.Base64;
import java.util.Date;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class atcoder_ABC150_C {
    public static void main(String[] args) {
        int integer_n = Integer.parseInt(args[0]);
        List<Integer> permutation_list = IntStream.rangeClosed(1, integer_n)
                .boxed()
                .collect(Collectors.toList());
        Random random = new Random();
        int[] source_array = IntStream.range(0, integer_n)
                .map(i -> random.nextInt(integer_n))
                .toArray();
        int[] target_array = IntStream.range(0, integer_n)
                .map(i -> random.nextInt(integer_n))
                .toArray();
        int source_permutation_index = permutation_list.indexOf(IntStream.of(source_array)
                .boxed()
                .collect(Collectors.toList()));
        int target_permutation_index = permutation_list.indexOf(IntStream.of(target_array)
                .boxed()
                .collect(Collectors.toList()));
        System.out.println(Math.abs(source_permutation_index - target_permutation_index));
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class codeforces_621_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] lst = new int[n];
        for (int i = 0; i < n; i++) {
            lst[i] = sc.nextInt();
        }
        Arrays.sort(lst);
        Arrays.reverse(lst);
        int od = 0;
        int threshold_a = 14;
        int threshold_b = 850;
        for (int i = 0; i < n; i++) {
            if ((threshold_a & threshold_b) != 0) {
                if ((lst[i] & 1) != 0) {
                    int increment_value = 1;
                    int result_calculate_sum0 = calculate_sum(od, increment_value);
                    od = result_calculate_sum0;
                }
            }
            if (lst[i] % 2 == 0) {
                od += lst[i];
            } else if (od > 1) {
                od -= 1;
                od += lst[i];
            }
        }
        System.out.println(od);
    }

    public static int calculate_sum(int od, int increment_value) {
        return od + increment_value;
    }
}
import java.util.Scanner;

public class codeforces_544_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int row_count = sc.nextInt();
        int k = sc.nextInt();
        int condition_one = 149;
        int condition_two = 231;
        int[] condition_one_arr = {89, 62, 73};
        int[] condition_two_arr = {8, 59, 56};
        double t_value = ttest_ind(condition_one_arr, condition_two_arr)[0];
        if (condition_one & condition_two != 0) {
            if (k <= Math.max(row_count * row_count / 2, row_count * row_count - row_count * row_count / 2)) {
                System.out.println("YES");
                for (int current_row = 0; current_row < row_count; current_row++) {
                    int x = 0;
                    int j = 0;
                    int step = 1;
                    if (current_row % 2 == 0) {
                        step = 1;
                    } else {
                        step = -1;
                    }
                    recursive_print(j, row_count, step, x, current_row);
                    System.out.println();
                }
            } else {
                System.out.println("NO");
            }
        } else {
            System.out.println("NO");
        }
    }

    public static void recursive_print(int j, int stop, int step, int x, int current_row) {
        if (step == 0 || (step > 0 && j >= stop) || (step < 0 && j <= stop)) {
            return;
        }
        if (current_row % 2 == j % 2 && x < k) {
            System.out.print("L");
            x++;
        } else {
            System.out.print("S");
        }
        recursive_print(j + step, stop, step, x, current_row);
    }

    public static double ttest_ind(int[] condition_one_arr, int[] condition_two_arr) {
        double[] condition_one_arr_double = new double[condition_one_arr.length];
        double[] condition_two_arr_double = new double[condition_two_arr.length];
        for (int i = 0; i < condition_one_arr.length; i++) {
            condition_one_arr_double[i] = condition_one_arr[i];
            condition_two_arr_double[i] = condition_two_arr[i];
        }
        return ttest_ind(condition_one_arr_double, condition_two_arr_double);
    }
}
import java.util.*;

public class atcoder_ABC107_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        int[] lst = new int[N];
        for (int i = 0; i < N; i++) {
            lst[i] = sc.nextInt();
        }
        int[] lst_p = new int[N];
        int[] lst_m = new int[N];
        int outer_loop_end = 418;
        int outer_loop_limit = 417;
        int condition_inner = 30;
        int condition_check_inner = 665;
        int condition_check_outer = 786;
        int condition_positive = 6;
        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_end / outer_loop_limit; LoopIndexOut++) {
            for (int i = 0; i < N; i++) {
                if ((condition_check_outer & condition_positive) != 0) {
                    if ((condition_inner & condition_check_inner) != 0) {
                        if (lst[i] == 0) {
                            K--;
                        }
                    }
                }
                if (lst[i] > 0) {
                    lst_p[i] = lst[i];
                } else if (lst[i] < 0) {
                    lst_m[i] = lst[i];
                }
            }
        }
        int p = 0;
        int m = 0;
        int x = 0;
        int y = lst_m.length - 1;
        int lastx = lst_p.length;
        int negative_list_size = lst_m.length;

        int calculate_minimum_sum(int k) {
            int ans = 1000000000;
            for (int j = 0; j <= k; j++) {
                if (j > lastx || k - j > negative_list_size) {
                    continue;
                }
                if (j == 0) {
                    p = 0;
                } else {
                    p = lst_p[j - 1];
                }
                if (k - j == 0) {
                    m = 0;
                } else {
                    m = lst_m[negative_list_size - (k - j)];
                }
                ans = Math.min(ans, 2 * p + Math.abs(m), p + 2 * Math.abs(m));
            }
            return ans;
        }
        System.out.println(calculate_minimum_sum(K));
    }
}
import java.util.*;
import java.io.*;
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_450_A {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] input_list = new int[n];
        for (int i = 0; i < n; i++) {
            input_list[i] = sc.nextInt();
        }
        int[] l2 = new int[n];
        int checker_one = 204;
        int checker_two = 347;
        for (int i = 0; i < n; i++) {
            if ((checker_one & checker_two) != 0) {
                if (input_list[i] % m == 0) {
                    l2[i] = input_list[i] / m;
                } else {
                    l2[i] = input_list[i] / m + 1;
                }
            }
        }
        int mx = 0;
        for (int i = 0; i < n; i++) {
            if (l2[i] > mx) {
                mx = l2[i];
            }
        }
        int ind = -1;
        recursive_search(l2, 0, n - 1, mx, ind);
        System.out.println(ind + 1);
    }

    public static void recursive_search(int[] l2, int start, int end, int mx, int ind) {
        if (start > end) {
            return;
        }
        if (l2[start] == mx) {
            ind = start;
        }
        recursive_search(l2, start + 1, end, mx, ind);
    }
}
import java.util.*;

public class atcoder_AGC017_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int P = sc.nextInt();
        int[] lis = new int[N];
        for (int i = 0; i < N; i++) {
            lis[i] = sc.nextInt();
        }
        int one = 0, zero = 0;
        for (int i = 0; i < N; i++) {
            if (lis[i] % 2 == 1) {
                one++;
            } else {
                zero++;
            }
        }
        int pattern_a = 0, even_combinations = 0;
        for (int i = 0; i <= zero; i++) {
            even_combinations += factorial(zero) / (factorial(i) * factorial(zero - i));
        }
        int time = 0;
        while (time <= one) {
            if (time % 2 == P) {
                pattern_a += factorial(one) / (factorial(time) * factorial(one - time));
            }
            time++;
        }
        System.out.println(pattern_a * even_combinations);
    }

    public static int factorial(int n) {
        if (n == 0) {
            return 1;
        }
        return n * factorial(n - 1);
    }
}
import java.util.*;

public class codeforces_682_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] l = new int[n];
        for (int i = 0; i < n; i++) {
            l[i] = sc.nextInt();
        }
        Arrays.sort(l);
        int c = 0;
        int condition_one = 274;
        int condition_two = 748;
        int condition_three = 828;
        int condition_four = 477;
        for (int i = 0; i < n; i++) {
            if ((condition_two & condition_three) != 0) {
                if ((condition_four & condition_one) != 0) {
                    if (l[i] > c) {
                        int increment = 1;
                        Queue<Integer> queue_calculate_sum0 = new LinkedList<>();

                        class CalculateSumThread extends Thread {
                            public void run() {
                                int result = calculate_sum(c, increment);
                                queue_calculate_sum0.offer(result);
                            }
                        }

                        CalculateSumThread thread_calculate_sum0 = new CalculateSumThread();
                        thread_calculate_sum0.start();
                        try {
                            thread_calculate_sum0.join();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        int result_calculate_sum0 = queue_calculate_sum0.poll();
                        c = result_calculate_sum0;
                    }
                }
            }
        }
        System.out.println(c + 1);
    }

    public static int calculate_sum(int c, int increment) {
        return c + increment;
    }
}
import java.util.Scanner;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ARC062_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        int num_g = 0, num_p = 0, score = 0;
        int primaryConditionChecker = 649, secondaryConditionChecker = 732;
        int outerLoopChecker = 278, innerLoopChecker = 277;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopChecker / innerLoopChecker; LoopIndexOut++) {
            for (int i = 0; i < s.length(); i++) {
                if ((primaryConditionChecker & secondaryConditionChecker) != 0) {
                    char x = s.charAt(i);
                    if (x == 'g') {
                        if (num_g - num_p > 0) {
                            int scoreMultiplier = 1;
                            Queue<Integer> scoreQueue = new LinkedList<>();

                            Thread scoreCalculatorThread = new Thread(() -> {
                                int result = calculateScore(score, scoreMultiplier);
                                scoreQueue.offer(result);
                            });
                            scoreCalculatorThread.start();
                            try {
                                scoreCalculatorThread.join();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            int calculatedScore = scoreQueue.poll();
                            score = calculatedScore;
                            num_p++;
                        } else {
                            score = score;
                            num_g++;
                        }
                    } else if (x == 'p') {
                        if (num_g - num_p > 0) {
                            score = score;
                            num_p++;
                        } else {
                            score--;
                            num_g++;
                        }
                    }
                }
            }
        }
        System.out.println(score);
    }

    public static int calculateScore(int score, int variable_3_15) {
        return score + variable_3_15;
    }
}
import java.util.Scanner;
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_ABC114_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        sc.close();

        TTest tTest = new TTest();
        double[] sample1 = {46, 42, 96};
        double[] sample2 = {60, 57, 23};
        double t = tTest.tTest(sample1, sample2);
        System.out.println(t);

        int count = recursiveCount(N, 0);
        System.out.println(count);
    }

    public static int recursiveCount(int n, int count) {
        int CheckerFour = 199;
        int CheckerTwo = 874;
        int CheckerThree = 758;
        int CheckerOne = 699;
        if ((CheckerFour & CheckerTwo) != 0) {
            if ((CheckerThree & CheckerOne) != 0) {
                if (n > N) {
                    return count;
                }
            }
        }
        if (setEquals(n)) {
            count++;
        }
        for (char digit : "753".toCharArray()) {
            count = recursiveCount(n * 10 + digit - '0', count);
        }
        return count;
    }

    public static boolean setEquals(int n) {
        String str = String.valueOf(n);
        return str.equals("753") || str.equals("752") || str.equals("751") || str.equals("750") || str.equals("733") || str.equals("732") || str.equals("731") || str.equals("730") || str.equals("722") || str.equals("721") || str.equals("720") || str.equals("711") || str.equals("710") || str.equals("700") || str.equals("533") || str.equals("532") || str.equals("531") || str.equals("530") || str.equals("522") || str.equals("521") || str.equals("520") || str.equals("511") || str.equals("510") || str.equals("500") || str.equals("333") || str.equals("332") || str.equals("331") || str.equals("330") || str.equals("322") || str.equals("321") || str.equals("320") || str.equals("311") || str.equals("310") || str.equals("300") || str.equals("222") || str.equals("221") || str.equals("220") || str.equals("211") || str.equals("210") || str.equals("200") || str.equals("111") || str.equals("110") || str.equals("100") || str.equals("000");
    }
}
import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;

public class atcoder_ABC145_B {
    public static void main(String[] args) {
        int firstCheck = 61;
        int checkFlag = 306;
        int[] arr = {93, 67, 8};
        shuffle(arr, new Random(System.currentTimeMillis()));
        int secondCheck = 889;
        long currentTimeMillis = System.currentTimeMillis();
        int thirdCheck = 178;
        Scanner scanner = new Scanner(System.in);
        int stringLength = scanner.nextInt();
        double[] arr1 = {4, 76, 41};
        double[] arr2 = {34, 91, 87};
        ttest_ind(arr1, arr2);
        String inputString = scanner.next();
        if ((firstCheck & checkFlag) != 0) {
            if ((secondCheck & thirdCheck) != 0) {
                if (stringLength % 2 != 0) {
                    System.out.println("No");
                } else if (inputString.substring(0, stringLength / 2).equals(inputString.substring(stringLength / 2))) {
                    System.out.println("Yes");
                } else {
                    System.out.println("No");
                }
            }
        }
    }
}
import java.util.*;

public class codeforces_61_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] grid = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                grid[i][j] = sc.nextInt();
            }
        }
        int k = sc.nextInt();
        int[] x = new int[k];
        int[] y = new int[k];
        for (int i = 0; i < k; i++) {
            x[i] = sc.nextInt();
            y[i] = sc.nextInt();
        }
        sc.close();

        int[][] dp = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (dp[i][j] != Integer.MAX_VALUE) {
                    if (i > 0) {
                        dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + grid[i][j]);
                    }
                    if (j > 0) {
                        dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + grid[i][j]);
                    }
                }
            }
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < k; i++) {
            ans = Math.min(ans, dp[x[i]][y[i]]);
        }
        if (ans == Integer.MAX_VALUE) {
            System.out.println("IMPOSSIBLE");
        } else {
            System.out.println(ans);
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC136_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int i = 1;
        int sumOfOddPowersOfTen = 0;
        int numerator = 609;
        int denominator = 608;
        while (numerator % denominator == 1) {
            numerator += 1;
            while (Math.pow(10, i) <= N) {
                sumOfOddPowersOfTen += (int) Math.pow(10, i) - (int) Math.pow(10, i - 1);
                i += 2;
            }
        }
        sumOfOddPowersOfTen += Math.max(0, N - (int) Math.pow(10, i - 1) + 1);
        System.out.println(sumOfOddPowersOfTen);
    }
}
import java.util.*;

public class atcoder_ARC086_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int count = sc.nextInt();
        int[] a = new int[count];
        for (int i = 0; i < count; i++) {
            a[i] = sc.nextInt();
        }
        int max_val = 0;
        int max_sign = 0;
        int max_index = -1;
        for (int i = 0; i < count; i++) {
            if (Math.abs(a[i]) > max_val) {
                max_val = Math.abs(a[i]);
                max_sign = (a[i] > 0) ? 1 : -1;
                max_index = i;
            }
        }
        if ((FirstChecker & SecondChecker) != 0) {
            if (max_sign == 0) {
                System.out.println(0);
            } else if (max_sign == 1) {
                System.out.println(2 * count - 1);
                for (int i = 0; i < count; i++) {
                    System.out.println(max_index + 1, i + 1);
                }
                recursive_loop(0, count, 1);
            } else {
                System.out.println(2 * count - 1);
                for (int i = 0; i < count; i++) {
                    System.out.println(max_index + 1, i + 1);
                }
                for (int i = 1; i < count; i++) {
                    System.out.println(i + 1, i);
                }
            }
        }
    }

    public static void recursive_loop(int index, int stop, int step) {
        if (step == 0 || (step > 0 && index >= stop) || (step < 0 && index <= stop)) {
            return;
        }
        System.out.println(max_index + 1, index + 1);
        recursive_loop(index + step, stop, step);
    }
}
import java.util.*;

public class atcoder_ABC124_C {

    public static int sum_arguments(int arg0, int arg1) {
        return arg0 + arg1;
    }

    public static int my_decorator(int a, int b) {
        return sum_arguments(a, b);
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();
        List<Integer> input_list = new ArrayList<Integer>();
        for (int i = 0; i < input.length(); i++) {
            input_list.add(Integer.parseInt(input.charAt(i) + ""));
        }
        Map<Integer, Integer> even_counts = new HashMap<Integer, Integer>();
        for (int i = 0; i < input_list.size(); i += 2) {
            if (even_counts.containsKey(input_list.get(i))) {
                even_counts.put(input_list.get(i), even_counts.get(input_list.get(i)) + 1);
            } else {
                even_counts.put(input_list.get(i), 1);
            }
        }
        Map<Integer, Integer> odd_counts = new HashMap<Integer, Integer>();
        for (int i = 1; i < input_list.size(); i += 2) {
            if (odd_counts.containsKey(input_list.get(i))) {
                odd_counts.put(input_list.get(i), odd_counts.get(input_list.get(i)) + 1);
            } else {
                odd_counts.put(input_list.get(i), 1);
            }
        }
        int min_value = Math.min(input_list.size() - my_decorator(even_counts.get(0), odd_counts.get(1)), input_list.size() - (even_counts.get(1) + odd_counts.get(0)));
        System.out.println(min_value);
    }
}
import java.util.*;

public class codeforces_644_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int b = sc.nextInt();
        int[] tasks = new int[n];
        int[] result = new int[n];
        PriorityQueue<Task> remaining = new PriorityQueue<>(Comparator.comparingInt(Task::getTime));
        boolean isTaskRunning = false;
        int finishTime = 0;

        for (int i = 0; i < n; i++) {
            int time = sc.nextInt();
            int duration = sc.nextInt();
            tasks[i] = duration;
            result[i] = 0;
        }

        for (int i = 0; i < n; i++) {
            int time = sc.nextInt();
            int duration = sc.nextInt();
            Task task = new Task(time, duration, i);
            if (isTaskRunning && task.getTime() > finishTime && remaining.isEmpty()) {
                finishTime = task.getTime() + task.getDuration();
                result[i] = finishTime;
            } else {
                if (task.getTime() >= finishTime && !remaining.isEmpty()) {
                    Task runTask = remaining.poll();
                    while (runTask != null && runTask.getTime() < task.getTime()) {
                        runTask = remaining.poll();
                    }
                    if (runTask != null) {
                        result[runTask.getIndex()] = runTask.getTime() + runTask.getDuration();
                    }
                }
                if (remaining.size() < b) {
                    remaining.offer(task);
                } else {
                    result[i] = -1;
                }
            }
        }

        while (!remaining.isEmpty()) {
            Task runTask = remaining.poll();
            result[runTask.getIndex()] = runTask.getTime() + runTask.getDuration();
        }

        for (int i = 0; i < n; i++) {
            System.out.print(result[i] + " ");
        }
    }
}

class Task implements Comparable<Task> {
    private int time;
    private int duration;
    private int index;

    public Task(int time, int duration, int index) {
        this.time = time;
        this.duration = duration;
        this.index = index;
    }

    public int getTime() {
        return time;
    }

    public int getDuration() {
        return duration;
    }

    public int getIndex() {
        return index;
    }

    @Override
    public int compareTo(Task o) {
        return Integer.compare(this.time, o.time);
    }
}
import java.util.*;
import java.io.*;

public class codeforces_624_B {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int array_size = Integer.parseInt(br.readLine());
        int[] a = new int[array_size];
        String[] input = br.readLine().split(" ");
        for (int i = 0; i < array_size; i++) {
            a[i] = Integer.parseInt(input[i]);
        }
        Arrays.sort(a);
        int ans = 0;
        int pre = Integer.MAX_VALUE;
        for (int i = 0; i < array_size; i++) {
            ans += Math.max(0, Math.min(pre - 1, a[i]));
            pre = Math.max(0, Math.min(pre - 1, a[i]));
        }
        System.out.println(ans);
    }
}
import java.util.*;

public class atcoder_AGC027_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int x = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        Arrays.sort(arr);
        int ans = 0;
        int inner_loop_bound = 762;
        int outer_loop_bound = 761;
        for (int i = 0; i < inner_loop_bound / outer_loop_bound; i++) {
            for (int j = 0; j < n; j++) {
                if (arr[j] > x) {
                    x = 0;
                    break;
                }
                int diff = x - arr[j];
                ans += diff;
                x = arr[j];
            }
        }
        if (x != 0) {
            ans--;
        }
        System.out.println(ans);
    }
}
import java.util.Arrays;
import java.util.Random;

public class codeforces_669_A {

    public static void main(String[] args) {
        int user_input = Integer.parseInt(args[0]);
        int[] arr1 = {61, 12, 41};
        int[] arr2 = {2, 99, 20};
        double[] arr3 = {44, 8, 53};
        Random rand = new Random();
        Arrays.sort(arr3);
        System.out.println(Arrays.toString(shuffle(arr3)));
        System.out.println(ttest_ind(arr1, arr2));
        System.out.println((multiply_and_decorate(user_input, 2) + 1) / 3);
    }

    public static double[] shuffle(double[] arr) {
        Random rand = new Random();
        for (int i = arr.length - 1; i > 0; i--) {
            int j = rand.nextInt(i + 1);
            double temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        return arr;
    }

    public static double ttest_ind(double[] arr1, double[] arr2) {
        double[] arr3 = new double[arr1.length + arr2.length];
        System.arraycopy(arr1, 0, arr3, 0, arr1.length);
        System.arraycopy(arr2, 0, arr3, arr1.length, arr2.length);
        Arrays.sort(arr3);
        int n1 = arr1.length;
        int n2 = arr2.length;
        double[] mean = {0, 0};
        double[] var = {0, 0};
        double[] std = {0, 0};
        for (int i = 0; i < 2; i++) {
            mean[i] = Arrays.stream(i == 0 ? arr1 : arr2).average().getAsDouble();
            var[i] = Arrays.stream(i == 0 ? arr1 : arr2).map(x -> Math.pow(x - mean[i], 2)).average().getAsDouble();
            std[i] = Math.sqrt(var[i]);
        }
        double t = (mean[0] - mean[1]) / (Math.sqrt((var[0] / n1) + (var[1] / n2)));
        double df = n1 + n2 - 2;
        double p = 1 - new TDistribution(df).cumulativeProbability(Math.abs(t));
        return p;
    }

    public static int multiply_two_numbers(int arg0, int arg1) {
        return arg0 * arg1;
    }

    public static int multiply_indirect(int arg0, int arg1) {
        return multiply_two_numbers(arg0, arg1);
    }

    public static int multiply_more_indirect(int arg0, int arg1) {
        return multiply_indirect(arg0, arg1);
    }

    public static int my_decorator(int func) {

        int dec_result(int args, int kwargs) {
            int decorated_result = func(args, kwargs);
            return decorated_result;
        }
        return dec_result;
    }

    @my_decorator
    public static int multiply_and_decorate(int a, int b) {
        return multiply_more_indirect(a, b);
    }
}
import java.util.*;

public class atcoder_ABC135_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String S = sc.nextLine();
        int n = S.length();
        int[][] dp = new int[n][13];
        for (int i = 0; i < n; i++) {
            if (S.charAt(i) != '?') {
                dp[i][(S.charAt(i) - '0')]++;
            } else {
                for (int j = 0; j < 10; j++) {
                    dp[i][j]++;
                }
            }
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < 13; j++) {
                for (int k = 0; k < 10; k++) {
                    dp[i][(j * 10 + k) % 13] += dp[i - 1][j];
                }
                dp[i][j] %= 1000000007;
            }
        }
        int ans = 0;
        for (int i = 0; i < 13; i++) {
            ans += dp[n - 1][i];
            ans %= 1000000007;
        }
        System.out.println(ans);
    }
}
import java.util.*;
import java.lang.*;
import java.io.*;

public class atcoder_ABC133_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int d = sc.nextInt();
        int[][] points = new int[n][d];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < d; j++) {
                points[i][j] = sc.nextInt();
            }
        }
        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (euclideanDistance(points[i], points[j]) == 0) {
                    count++;
                }
            }
        }
        System.out.println(count);
    }

    public static int euclideanDistance(int[] x, int[] y) {
        int sum = 0;
        for (int i = 0; i < x.length; i++) {
            sum += (x[i] - y[i]) * (x[i] - y[i]);
        }
        return (int) Math.sqrt(sum);
    }
}
import java.util.Scanner;

public class codeforces_622_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int l = 1;
        int rightBoundary = n;
        int loopCounterOne = 852;
        int loopCounterTwo = 851;
        while (loopCounterOne % loopCounterTwo == 1) {
            loopCounterOne++;
            while (l < rightBoundary) {
                int indexCheck = 74;
                int checkFlagA = 939;
                int checkFlagE = 921;
                int checkFlagB = 257;
                int checkFlagD = 553;
                int checkFlagC = 51;
                int mid = l + (rightBoundary - l) / 2;
                int idxcnt = mid * (mid + 1) / 2;
                if ((indexCheck & checkFlagA) != 0) {
                    if ((checkFlagE & checkFlagB) != 0) {
                        if ((checkFlagD & checkFlagC) != 0) {
                            if (idxcnt < n) {
                                l = mid + 1;
                            } else {
                                rightBoundary = mid;
                            }
                        }
                    }
                }
            }
            l--;
            idxcnt = l * (l + 1) / 2;
        }
        System.out.println(n - idxcnt);
    }
}
100%|██████████| 225/225 [00:00<00:00, 20889.82it/s]
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class codeforces_519_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        List<Integer> a = Arrays.asList(Arrays.stream(args[1].split(" ")).mapToInt(Integer::parseInt).toArray());
        List<Integer> b = Arrays.asList(Arrays.stream(args[2].split(" ")).mapToInt(Integer::parseInt).toArray());
        List<Integer> numbers_c = Arrays.asList(Arrays.stream(args[3].split(" ")).mapToInt(Integer::parseInt).toArray());
        int x = 0;
        int y = 0;
        Random random = new Random();
        for (int i : a) {
            Queue<Integer> queue_sum_x0 = new ConcurrentLinkedQueue<>();
            ExecutorService executor = Executors.newFixedThreadPool(1);
            executor.execute(() -> {
                int result = sum_x(i, x);
                queue_sum_x0.offer(result);
            });
            executor.shutdown();
            try {
                executor.awaitTermination(1, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            x = queue_sum_x0.poll();
        }
        for (int i : b) {
            y += i;
        }
        double[] a_arr = a.stream().mapToDouble(i -> i).toArray();
        double[] b_arr = b.stream().mapToDouble(i -> i).toArray();
        double t = ttest_ind(a_arr, b_arr)[0];
        System.out.println(t);
        int z = 0;
        for (int i : numbers_c) {
            z += i;
        }
        System.out.println(Math.abs(x - y));
        System.out.println(Math.abs(y - z));
    }

    public static int sum_x(int i, int x) {
        return x + i;
    }

    public static double[] ttest_ind(double[] a, double[] b) {
        double mean_a = Arrays.stream(a).average().getAsDouble();
        double mean_b = Arrays.stream(b).average().getAsDouble();
        double var_a = Arrays.stream(a).map(i -> Math.pow(i - mean_a, 2)).average().getAsDouble();
        double var_b = Arrays.stream(b).map(i -> Math.pow(i - mean_b, 2)).average().getAsDouble();
        double var_pooled = (var_a + var_b) / 2;
        double std_err_a = Math.sqrt(var_a / a.length);
        double std_err_b = Math.sqrt(var_b / b.length);
        double t = (mean_a - mean_b) / Math.sqrt(var_pooled * (1.0 / a.length + 1.0 / b.length));
        double df = a.length + b.length - 2;
        double p = 1.0 - new TDistribution(df).cumulativeProbability(Math.abs(t));
        return new double[]{t, df, p};
    }
}

class TDistribution extends org.apache.commons.math3.distribution.TDistribution {
    public TDistribution(double df) {
        super(df);
    }
}
import java.util.*;

public class codeforces_131_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Map<Integer, Integer> w = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int x = sc.nextInt();
            w.put(x, w.getOrDefault(x, 0) + 1);
        }
        int count = 0;
        int outer_check = 572;
        int inner_check = 86;
        int condition_check_two = 505;
        int condition_check_one = 683;
        int outer_loop_bound = 395;
        int inner_loop_bound = 394;
        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_bound / inner_loop_bound; LoopIndexOut++) {
            for (int i : w.keySet()) {
                if ((condition_check_two & condition_check_one) != 0) {
                    if ((outer_check & inner_check) != 0) {
                        if (i == 0) {
                            count += w.get(i) * (w.get(i) - 1);
                        } else if (-i in w) {
                            count += w.get(i) * w.get(-i);
                        }
                    }
                }
            }
        }
        System.out.println(count / 2);
    }
}
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_379_A {
    public static void main(String[] args) {
        int candeleIntere, b;
        candeleIntere = 3;
        b = 2;
        int s = 0;
        int remaining_candles = 0;
        while (candeleIntere > 0 || remaining_candles >= b) {
            candeleIntere += calculate_whole_candles(b, remaining_candles);
            Queue<Integer> queue_calculate_candle_remainder0 = new LinkedList<>();

            class calculate_candle_remainder_thread implements Runnable {
                public void run() {
                    int result = calculate_candle_remainder(remaining_candles, b);
                    queue_calculate_candle_remainder0.offer(result);
                }
            }
            Thread thread_calculate_candle_remainder0 = new Thread(new calculate_candle_remainder_thread());
            thread_calculate_candle_remainder0.start();
            try {
                thread_calculate_candle_remainder0.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            int remainder_candles = queue_calculate_candle_remainder0.poll();
            remaining_candles = remainder_candles;
            s = s + candeleIntere;
            remaining_candles += candeleIntere % b;
            candeleIntere /= b;
        }
        System.out.println(s);
    }

    public static int calculate_candle_remainder(int remaining_candles, int b) {
        return remaining_candles % b;
    }

    public static int calculate_whole_candles(int b, int remaining_candles) {
        ttest_ind([77, 29, 11], [90, 35, 89]);
        return remaining_candles / b;
    }
}
+ python3 -u test_translation.py --dataset Avatar --source_lang Python --target_lang Java --model WizardLM/WizardCoder-15B-V1.0 --test_type use_test
testing translations
Filename:  atcoder_ABC146_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC146_D.java' returned non-zero exit status 1.
Filename:  atcoder_ABC119_B.java
Filename:  atcoder_AGC028_B.java
Filename:  codeforces_569_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_569_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC112_C.java
Filename:  atcoder_ABC104_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC104_C.java' returned non-zero exit status 1.
Filename:  codeforces_678_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_678_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC105_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC105_D.java' returned non-zero exit status 1.
Filename:  atcoder_AGC033_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC033_B.java' returned non-zero exit status 1.
Filename:  codeforces_55_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_55_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC106_C.java
Filename:  codeforces_404_A.java
Filename:  atcoder_AGC046_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC046_B.java' returned non-zero exit status 1.
Filename:  codeforces_7_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_7_B.java' returned non-zero exit status 1.
Filename:  codeforces_609_B.java
Filename:  atcoder_ABC162_D.java
Filename:  atcoder_AGC014_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC014_D.java' returned non-zero exit status 1.
Filename:  atcoder_ABC151_A.java
Filename:  codeforces_581_B.java
Filename:  atcoder_ABC126_E.java
Filename:  atcoder_ABC132_F.java
Filename:  codeforces_581_A.java
Filename:  codeforces_92_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_92_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC170_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC170_A.java' returned non-zero exit status 1.
Filename:  codeforces_653_A.java
Filename:  codeforces_8_B.java
Filename:  codeforces_146_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_146_A.java' returned non-zero exit status 1.
Filename:  codeforces_299_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_299_A.java' returned non-zero exit status 1.
Filename:  codeforces_518_B.java
Filename:  codeforces_421_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_421_A.java' returned non-zero exit status 1.
Filename:  codeforces_340_A.java
Filename:  atcoder_ABC140_F.java
Filename:  codeforces_534_B.java
Filename:  codeforces_672_A.java
Filename:  codeforces_148_B.java
Filename:  codeforces_59_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_59_A.java' returned non-zero exit status 1.
Filename:  codeforces_474_B.java
Filename:  codeforces_267_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_267_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC172_D.java
Filename:  atcoder_ABC112_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC112_A.java' returned non-zero exit status 1.
Filename:  codeforces_265_B.java
Filename:  codeforces_342_B.java
Filename:  codeforces_356_A.java
Filename:  atcoder_ABC178_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC178_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC158_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC158_B.java' returned non-zero exit status 1.
Filename:  codeforces_296_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_296_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC019_A.java
Filename:  atcoder_ABC134_E.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC134_E.java' returned non-zero exit status 1.
Filename:  codeforces_387_A.java
Filename:  codeforces_665_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_665_A.java' returned non-zero exit status 1.
Filename:  codeforces_154_A.java
Filename:  codeforces_23_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_23_B.java' returned non-zero exit status 1.
Filename:  codeforces_216_B.java
Filename:  atcoder_ABC149_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC149_B.java' returned non-zero exit status 1.
Filename:  codeforces_612_B.java
Filename:  codeforces_583_B.java
Filename:  codeforces_607_A.java
Filename:  atcoder_AGC010_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC010_B.java' returned non-zero exit status 4.
Filename:  codeforces_190_A.java
Filename:  codeforces_387_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_387_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC137_D.java
Filename:  codeforces_397_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_397_B.java' returned non-zero exit status 1.
Filename:  atcoder_ARC102_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ARC102_C.java' returned non-zero exit status 1.
Filename:  atcoder_ABC070_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC070_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC152_C.java
Filename:  atcoder_ABC111_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC111_C.java' returned non-zero exit status 1.
Filename:  codeforces_268_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_268_A.java' returned non-zero exit status 1.
Filename:  codeforces_651_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_651_A.java' returned non-zero exit status 1.
Filename:  codeforces_274_A.java
Filename:  codeforces_400_B.java
Filename:  codeforces_567_A.java
Filename:  atcoder_ABC109_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC109_B.java' returned non-zero exit status 1.
Filename:  codeforces_579_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_579_A.java' returned non-zero exit status 1.
Filename:  codeforces_189_A.java
Filename:  atcoder_AGC037_E.java
Filename:  codeforces_222_A.java
Filename:  atcoder_ABC165_C.java
Filename:  codeforces_203_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_203_B.java' returned non-zero exit status 1.
Filename:  atcoder_AGC024_B.java
Filename:  codeforces_287_A.java
Filename:  codeforces_37_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_37_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC006_B.java
Filename:  codeforces_632_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_632_B.java' returned non-zero exit status 1.
Filename:  codeforces_110_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_110_B.java' returned non-zero exit status 1.
Filename:  codeforces_134_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_134_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC034_B.java
Filename:  atcoder_ABC110_C.java
Filename:  atcoder_ABC123_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC123_B.java' returned non-zero exit status 1.
Filename:  atcoder_AGC025_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC025_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC108_B.java
Filename:  atcoder_ABC171_E.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC171_E.java' returned non-zero exit status 1.
Filename:  codeforces_445_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_445_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC143_D.java
Filename:  atcoder_ABC142_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC142_C.java' returned non-zero exit status 1.
Filename:  atcoder_ABC171_B.java
Filename:  atcoder_ABC107_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC107_D.java' returned non-zero exit status 1.
Filename:  codeforces_106_B.java
Filename:  atcoder_AGC002_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC002_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC140_D.java
Filename:  atcoder_ABC167_C.java
Filename:  atcoder_ABC143_A.java
Filename:  atcoder_ABC139_B.java
Filename:  atcoder_ABC124_A.java
Filename:  codeforces_25_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_25_A.java' returned non-zero exit status 1.
Filename:  codeforces_282_B.java
Filename:  atcoder_ABC169_C.java
Filename:  codeforces_350_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_350_B.java' returned non-zero exit status 1.
Filename:  codeforces_333_B.java
Filename:  atcoder_ABC166_C.java
Filename:  codeforces_79_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_79_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC174_C.java
Filename:  codeforces_67_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_67_B.java' returned non-zero exit status 1.
Filename:  codeforces_354_A.java
Filename:  codeforces_49_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_49_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC168_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC168_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC149_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC149_C.java' returned non-zero exit status 1.
Filename:  codeforces_302_A.java
Filename:  codeforces_58_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_58_B.java' returned non-zero exit status 1.
Filename:  atcoder_AGC028_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC028_A.java' returned non-zero exit status 1.
Filename:  codeforces_56_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_56_B.java' returned non-zero exit status 1.
Filename:  codeforces_99_A.java
Filename:  codeforces_412_A.java
Filename:  codeforces_86_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_86_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC128_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC128_C.java' returned non-zero exit status 1.
Filename:  atcoder_AGC004_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC004_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC150_E.java
Filename:  codeforces_598_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_598_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC027_B.java
Filename:  codeforces_408_B.java
Filename:  atcoder_AGC006_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC006_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC043_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC043_B.java' returned non-zero exit status 1.
Filename:  codeforces_31_A.java
Filename:  atcoder_AGC011_C.java
Filename:  atcoder_ABC125_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC125_C.java' returned non-zero exit status 1.
Filename:  codeforces_459_B.java
Filename:  atcoder_ABC125_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC125_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC043_B.java
Filename:  codeforces_546_A.java
Filename:  codeforces_231_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_231_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC033_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC033_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC127_B.java
Filename:  atcoder_AGC038_A.java
Filename:  codeforces_500_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_500_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC155_D.java
Filename:  atcoder_ABC147_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC147_D.java' returned non-zero exit status 1.
Filename:  atcoder_AGC046_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC046_A.java' returned non-zero exit status 1.
Filename:  codeforces_596_B.java
Filename:  codeforces_171_A.java
Filename:  codeforces_276_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_276_B.java' returned non-zero exit status 1.
Filename:  codeforces_617_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_617_B.java' returned non-zero exit status 1.
Filename:  codeforces_55_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_55_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC178_B.java
Filename:  atcoder_ABC164_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC164_D.java' returned non-zero exit status 1.
Filename:  codeforces_242_B.java
Filename:  atcoder_ABC132_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC132_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC169_D.java
Filename:  atcoder_ABC126_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC126_D.java' returned non-zero exit status 1.
Filename:  atcoder_ABC129_E.java
Filename:  codeforces_678_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_678_B.java' returned non-zero exit status 1.
Filename:  codeforces_462_B.java
Filename:  codeforces_334_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_334_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC029_C.java
Filename:  codeforces_313_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_313_B.java' returned non-zero exit status 1.
Filename:  codeforces_108_B.java
Filename:  codeforces_705_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_705_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC127_F.java
Filename:  atcoder_ABC153_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC153_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC158_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC158_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC005_B.java
Filename:  codeforces_70_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_70_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC125_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC125_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC164_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC164_A.java' returned non-zero exit status 1.
Filename:  codeforces_514_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_514_A.java' returned non-zero exit status 1.
Filename:  codeforces_272_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_272_B.java' returned non-zero exit status 1.
Filename:  codeforces_96_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_96_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC169_E.java
Filename:  atcoder_AGC035_B.java
Filename:  codeforces_203_A.java
Filename:  atcoder_ABC123_D.java
Filename:  codeforces_369_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_369_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC133_E.java
Filename:  codeforces_95_A.java
Filename:  codeforces_373_B.java
Filename:  codeforces_242_A.java
Filename:  codeforces_608_A.java
Filename:  codeforces_469_A.java
Filename:  codeforces_351_A.java
Filename:  atcoder_AGC003_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_AGC003_C.java' returned non-zero exit status 1.
Filename:  codeforces_629_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_629_A.java' returned non-zero exit status 1.
Filename:  codeforces_32_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_32_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC122_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC122_D.java' returned non-zero exit status 1.
Filename:  atcoder_ABC042_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC042_A.java' returned non-zero exit status 1.
Filename:  codeforces_629_B.java
Filename:  atcoder_ABC167_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC167_D.java' returned non-zero exit status 1.
Filename:  atcoder_ABC051_A.java
Filename:  atcoder_ABC122_C.java
Filename:  codeforces_673_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_673_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC174_E.java
Filename:  atcoder_ABC154_A.java
Filename:  codeforces_637_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_637_A.java' returned non-zero exit status 1.
Filename:  codeforces_11_A.java
Filename:  atcoder_ABC150_C.java
Filename:  codeforces_621_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_621_A.java' returned non-zero exit status 1.
Filename:  codeforces_544_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_544_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC107_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC107_C.java' returned non-zero exit status 1.
Filename:  codeforces_450_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_450_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC017_A.java
Filename:  codeforces_682_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_682_B.java' returned non-zero exit status 1.
Filename:  atcoder_ARC062_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ARC062_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC114_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC114_C.java' returned non-zero exit status 1.
Filename:  atcoder_ABC145_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ABC145_B.java' returned non-zero exit status 1.
Filename:  codeforces_61_B.java
Filename:  atcoder_ABC136_B.java
Filename:  atcoder_ARC086_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/atcoder_ARC086_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC124_C.java
Filename:  codeforces_644_B.java
Filename:  codeforces_624_B.java
Filename:  atcoder_AGC027_A.java
Filename:  codeforces_669_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_669_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC135_D.java
Filename:  atcoder_ABC133_B.java
Filename:  codeforces_622_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_622_A.java' returned non-zero exit status 1.
Filename:  codeforces_519_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_519_B.java' returned non-zero exit status 1.
Filename:  codeforces_131_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_131_B.java' returned non-zero exit status 1.
Filename:  codeforces_379_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/codeforces_379_A.java' returned non-zero exit status 1.
../Experiment_Results/intermediate/SR/Translation/use_test/WizardCoder-15B-V1.0/Avatar/Python/Java-sanitized/pass_id.txt
#Success: 26
Success: ['codeforces_274_A.java', 'atcoder_ABC140_D.java', 'atcoder_ABC151_A.java', 'codeforces_607_A.java', 'codeforces_609_B.java', 'atcoder_AGC038_A.java', 'codeforces_154_A.java', 'codeforces_608_A.java', 'atcoder_ABC110_C.java', 'codeforces_546_A.java', 'atcoder_ABC124_A.java', 'atcoder_ABC166_C.java', 'codeforces_11_A.java', 'codeforces_581_A.java', 'codeforces_108_B.java', 'atcoder_AGC006_B.java', 'atcoder_ABC154_A.java', 'codeforces_354_A.java', 'codeforces_203_A.java', 'atcoder_ABC152_C.java', 'codeforces_567_A.java', 'atcoder_ABC043_B.java', 'atcoder_ABC139_B.java', 'atcoder_ABC136_B.java', 'codeforces_242_B.java', 'atcoder_ABC174_C.java']
Fail: ['atcoder_ABC108_B.java', 'atcoder_AGC035_B.java', 'codeforces_242_A.java', 'atcoder_ABC137_D.java', 'codeforces_31_A.java', 'atcoder_ABC122_C.java', 'atcoder_ABC171_B.java', 'codeforces_216_B.java', 'codeforces_624_B.java', 'atcoder_AGC005_B.java', 'codeforces_99_A.java', 'atcoder_ABC119_B.java', 'atcoder_ABC172_D.java', 'atcoder_ABC133_B.java', 'atcoder_ABC140_F.java', 'atcoder_AGC011_C.java', 'atcoder_AGC019_A.java', 'codeforces_581_B.java', 'codeforces_189_A.java', 'codeforces_534_B.java', 'atcoder_AGC034_B.java', 'atcoder_ABC155_D.java', 'atcoder_AGC029_C.java', 'codeforces_333_B.java', 'codeforces_190_A.java', 'codeforces_596_B.java', 'codeforces_340_A.java', 'atcoder_ABC143_A.java', 'codeforces_171_A.java', 'codeforces_95_A.java', 'atcoder_ABC143_D.java', 'codeforces_351_A.java', 'atcoder_ABC174_E.java', 'codeforces_222_A.java', 'codeforces_672_A.java', 'atcoder_ABC150_E.java', 'codeforces_459_B.java', 'codeforces_8_B.java', 'atcoder_AGC027_A.java', 'codeforces_373_B.java', 'atcoder_AGC028_B.java', 'codeforces_265_B.java', 'atcoder_ABC169_D.java', 'atcoder_ABC169_E.java', 'codeforces_387_A.java', 'atcoder_ABC135_D.java', 'atcoder_ABC178_B.java', 'codeforces_474_B.java', 'atcoder_ABC129_E.java', 'atcoder_ABC112_C.java', 'codeforces_404_A.java', 'codeforces_356_A.java', 'codeforces_612_B.java', 'codeforces_400_B.java', 'codeforces_106_B.java', 'atcoder_ABC127_B.java', 'atcoder_ABC051_A.java', 'atcoder_ABC165_C.java', 'atcoder_ABC162_D.java', 'atcoder_ABC132_F.java', 'atcoder_ABC133_E.java', 'atcoder_AGC037_E.java', 'atcoder_ABC167_C.java', 'codeforces_629_B.java', 'codeforces_287_A.java', 'codeforces_653_A.java', 'codeforces_282_B.java', 'codeforces_644_B.java', 'codeforces_61_B.java', 'codeforces_462_B.java', 'atcoder_AGC017_A.java', 'atcoder_AGC027_B.java', 'codeforces_148_B.java', 'atcoder_AGC024_B.java', 'atcoder_ABC169_C.java', 'codeforces_302_A.java', 'codeforces_412_A.java', 'codeforces_408_B.java', 'codeforces_469_A.java', 'atcoder_ABC123_D.java', 'atcoder_ABC106_C.java', 'atcoder_ABC150_C.java', 'atcoder_ABC127_F.java', 'atcoder_ABC124_C.java', 'codeforces_583_B.java', 'codeforces_518_B.java', 'atcoder_ABC126_E.java', 'atcoder_AGC004_B.java', 'atcoder_ABC146_D.java', 'codeforces_617_B.java', 'atcoder_ABC171_E.java', 'atcoder_ABC112_A.java', 'codeforces_637_A.java', 'codeforces_131_B.java', 'atcoder_ABC125_B.java', 'codeforces_334_A.java', 'codeforces_58_B.java', 'codeforces_59_A.java', 'codeforces_37_A.java', 'codeforces_49_A.java', 'atcoder_AGC006_A.java', 'atcoder_ABC147_D.java', 'atcoder_ABC158_A.java', 'atcoder_ABC158_B.java', 'codeforces_268_A.java', 'codeforces_350_B.java', 'atcoder_AGC010_B.java', 'codeforces_67_B.java', 'codeforces_678_A.java', 'atcoder_AGC003_C.java', 'atcoder_ABC125_C.java', 'codeforces_387_B.java', 'codeforces_32_B.java', 'codeforces_450_A.java', 'atcoder_ABC114_C.java', 'atcoder_AGC033_A.java', 'codeforces_272_B.java', 'atcoder_ARC086_B.java', 'atcoder_ABC125_A.java', 'codeforces_678_B.java', 'atcoder_ABC105_D.java', 'codeforces_544_B.java', 'atcoder_ABC122_D.java', 'atcoder_AGC033_B.java', 'codeforces_96_B.java', 'codeforces_514_A.java', 'atcoder_AGC046_A.java', 'codeforces_500_A.java', 'codeforces_519_B.java', 'atcoder_AGC043_B.java', 'atcoder_ABC134_E.java', 'atcoder_ARC102_C.java', 'atcoder_ABC128_C.java', 'codeforces_55_B.java', 'atcoder_ABC178_A.java', 'codeforces_79_A.java', 'codeforces_673_A.java', 'atcoder_ABC104_C.java', 'atcoder_ABC070_B.java', 'codeforces_622_A.java', 'atcoder_AGC046_B.java', 'codeforces_267_A.java', 'codeforces_632_B.java', 'codeforces_445_A.java', 'codeforces_629_A.java', 'codeforces_598_A.java', 'codeforces_669_A.java', 'atcoder_ABC111_C.java', 'codeforces_569_A.java', 'atcoder_ABC168_B.java', 'atcoder_ABC126_D.java', 'codeforces_296_A.java', 'atcoder_AGC025_A.java', 'atcoder_ARC062_B.java', 'codeforces_7_B.java', 'atcoder_ABC170_A.java', 'atcoder_ABC107_D.java', 'codeforces_86_A.java', 'codeforces_621_A.java', 'codeforces_579_A.java', 'atcoder_ABC142_C.java', 'codeforces_397_B.java', 'codeforces_92_A.java', 'codeforces_313_B.java', 'atcoder_ABC164_A.java', 'codeforces_70_B.java', 'codeforces_146_A.java', 'codeforces_134_A.java', 'atcoder_ABC107_C.java', 'atcoder_AGC028_A.java', 'codeforces_682_B.java', 'atcoder_ABC149_C.java', 'codeforces_379_A.java', 'atcoder_ABC109_B.java', 'atcoder_ABC145_B.java', 'codeforces_110_B.java', 'codeforces_665_A.java', 'codeforces_369_B.java', 'codeforces_276_B.java', 'atcoder_ABC042_A.java', 'atcoder_AGC014_D.java', 'codeforces_55_A.java', 'codeforces_23_B.java', 'codeforces_203_B.java', 'codeforces_25_A.java', 'codeforces_56_B.java', 'codeforces_705_B.java', 'atcoder_ABC149_B.java', 'codeforces_421_A.java', 'atcoder_AGC002_A.java', 'atcoder_ABC153_A.java', 'atcoder_ABC167_D.java', 'atcoder_ABC123_B.java', 'atcoder_ABC164_D.java', 'codeforces_299_A.java', 'codeforces_651_A.java', 'codeforces_231_A.java', 'atcoder_ABC132_A.java', 'atcoder_ABC132_F.java', 'codeforces_356_A.java', 'atcoder_AGC029_C.java', 'atcoder_ABC126_E.java', 'codeforces_342_B.java']
