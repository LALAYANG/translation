+ model=codellama/CodeLlama-13b-Instruct-hf
+ dataset=Avatar
+ cache=tmp
+ src=Python
+ tgt=Java
+ python3 translate.py --model codellama/CodeLlama-13b-Instruct-hf --dataset Avatar --source_lang Python --target_lang Java --cache_dir tmp --use_test
INFO 08-21 06:33:34 [__init__.py:241] Automatically detected platform cuda.
found 225 inputs
INFO 08-21 06:33:35 [utils.py:326] non-default args: {'model': 'codellama/CodeLlama-13b-Instruct-hf', 'trust_remote_code': True, 'dtype': 'bfloat16', 'max_model_len': 4096, 'tensor_parallel_size': 2, 'disable_log_stats': True}
The argument `trust_remote_code` is to be used with Auto classes. It has no effect here and is ignored.
INFO 08-21 06:33:40 [__init__.py:711] Resolved architecture: LlamaForCausalLM
INFO 08-21 06:33:40 [__init__.py:1750] Using max model len 4096
INFO 08-21 06:33:40 [scheduler.py:222] Chunked prefill is enabled with max_num_batched_tokens=16384.
[1;36m(EngineCore_0 pid=3663301)[0;0m INFO 08-21 06:33:41 [core.py:636] Waiting for init message from front-end.
[1;36m(EngineCore_0 pid=3663301)[0;0m INFO 08-21 06:33:41 [core.py:74] Initializing a V1 LLM engine (v0.10.1.1) with config: model='codellama/CodeLlama-13b-Instruct-hf', speculative_config=None, tokenizer='codellama/CodeLlama-13b-Instruct-hf', skip_tokenizer_init=False, tokenizer_mode=auto, revision=None, override_neuron_config={}, tokenizer_revision=None, trust_remote_code=True, dtype=torch.bfloat16, max_seq_len=4096, download_dir=None, load_format=auto, tensor_parallel_size=2, pipeline_parallel_size=1, disable_custom_all_reduce=False, quantization=None, enforce_eager=False, kv_cache_dtype=auto, device_config=cuda, decoding_config=DecodingConfig(backend='auto', disable_fallback=False, disable_any_whitespace=False, disable_additional_properties=False, reasoning_backend=''), observability_config=ObservabilityConfig(show_hidden_metrics_for_version=None, otlp_traces_endpoint=None, collect_detailed_traces=None), seed=0, served_model_name=codellama/CodeLlama-13b-Instruct-hf, enable_prefix_caching=True, chunked_prefill_enabled=True, use_async_output_proc=True, pooler_config=None, compilation_config={"level":3,"debug_dump_path":"","cache_dir":"","backend":"","custom_ops":[],"splitting_ops":["vllm.unified_attention","vllm.unified_attention_with_output","vllm.mamba_mixer2"],"use_inductor":true,"compile_sizes":[],"inductor_compile_config":{"enable_auto_functionalized_v2":false},"inductor_passes":{},"cudagraph_mode":1,"use_cudagraph":true,"cudagraph_num_of_warmups":1,"cudagraph_capture_sizes":[512,504,496,488,480,472,464,456,448,440,432,424,416,408,400,392,384,376,368,360,352,344,336,328,320,312,304,296,288,280,272,264,256,248,240,232,224,216,208,200,192,184,176,168,160,152,144,136,128,120,112,104,96,88,80,72,64,56,48,40,32,24,16,8,4,2,1],"cudagraph_copy_inputs":false,"full_cuda_graph":false,"pass_config":{},"max_capture_size":512,"local_cache_dir":null}
[1;36m(EngineCore_0 pid=3663301)[0;0m WARNING 08-21 06:33:41 [multiproc_worker_utils.py:273] Reducing Torch parallelism from 26 threads to 1 to avoid unnecessary CPU contention. Set OMP_NUM_THREADS in the external environment to tune this value as needed.
[1;36m(EngineCore_0 pid=3663301)[0;0m INFO 08-21 06:33:41 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[0, 1], buffer_handle=(2, 16777216, 10, 'psm_e627579b'), local_subscribe_addr='ipc:///tmp/94efd4f4-47d2-4243-8521-c650d49e56cd', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:43 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[0], buffer_handle=(1, 10485760, 10, 'psm_468dbd59'), local_subscribe_addr='ipc:///tmp/c67a0161-5e43-4058-a713-76d56578d291', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:43 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[0], buffer_handle=(1, 10485760, 10, 'psm_f8d7ca23'), local_subscribe_addr='ipc:///tmp/88f8fe4c-3a0b-4b8d-ade7-e682635fdfad', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:43 [__init__.py:1418] Found nccl from library libnccl.so.2
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:43 [__init__.py:1418] Found nccl from library libnccl.so.2
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:43 [pynccl.py:70] vLLM is using nccl==2.26.2
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:43 [pynccl.py:70] vLLM is using nccl==2.26.2
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:44 [custom_all_reduce.py:35] Skipping P2P check and trusting the driver's P2P report.
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:44 [custom_all_reduce.py:35] Skipping P2P check and trusting the driver's P2P report.
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:44 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[1], buffer_handle=(1, 4194304, 6, 'psm_53e455f4'), local_subscribe_addr='ipc:///tmp/628d1089-838f-4844-b3a7-2f3afbc575cc', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:44 [parallel_state.py:1134] rank 1 in world size 2 is assigned as DP rank 0, PP rank 0, TP rank 1, EP rank 1
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:44 [parallel_state.py:1134] rank 0 in world size 2 is assigned as DP rank 0, PP rank 0, TP rank 0, EP rank 0
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m WARNING 08-21 06:33:44 [topk_topp_sampler.py:61] FlashInfer is not available. Falling back to the PyTorch-native implementation of top-p & top-k sampling. For the best performance, please install FlashInfer.
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m WARNING 08-21 06:33:44 [topk_topp_sampler.py:61] FlashInfer is not available. Falling back to the PyTorch-native implementation of top-p & top-k sampling. For the best performance, please install FlashInfer.
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:44 [gpu_model_runner.py:1953] Starting to load model codellama/CodeLlama-13b-Instruct-hf...
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:44 [gpu_model_runner.py:1953] Starting to load model codellama/CodeLlama-13b-Instruct-hf...
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:44 [gpu_model_runner.py:1985] Loading model from scratch...
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:44 [gpu_model_runner.py:1985] Loading model from scratch...
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:44 [cuda.py:328] Using Flash Attention backend on V1 engine.
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:44 [cuda.py:328] Using Flash Attention backend on V1 engine.
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:44 [weight_utils.py:296] Using model weights format ['*.safetensors']
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:44 [weight_utils.py:296] Using model weights format ['*.safetensors']
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m Loading safetensors checkpoint shards:   0% Completed | 0/3 [00:00<?, ?it/s]
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m Loading safetensors checkpoint shards:  33% Completed | 1/3 [00:01<00:02,  1.22s/it]
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m Loading safetensors checkpoint shards:  67% Completed | 2/3 [00:02<00:01,  1.12s/it]
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m Loading safetensors checkpoint shards: 100% Completed | 3/3 [00:03<00:00,  1.23s/it]
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m Loading safetensors checkpoint shards: 100% Completed | 3/3 [00:03<00:00,  1.21s/it]
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m 
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:49 [default_loader.py:262] Loading weights took 4.06 seconds
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:49 [default_loader.py:262] Loading weights took 4.25 seconds
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:49 [gpu_model_runner.py:2007] Model loading took 12.2637 GiB and 4.868788 seconds
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:49 [gpu_model_runner.py:2007] Model loading took 12.2637 GiB and 4.868601 seconds
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:57 [backends.py:548] Using cache directory: /home/ubuntu/.cache/vllm/torch_compile_cache/0c1aa4d031/rank_1_0/backbone for vLLM's torch.compile
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:33:57 [backends.py:559] Dynamo bytecode transform time: 7.70 s
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:57 [backends.py:548] Using cache directory: /home/ubuntu/.cache/vllm/torch_compile_cache/0c1aa4d031/rank_0_0/backbone for vLLM's torch.compile
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:33:57 [backends.py:559] Dynamo bytecode transform time: 7.94 s
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:34:03 [backends.py:161] Directly load the compiled graph(s) for dynamic shape from the cache, took 5.457 s
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:34:03 [backends.py:161] Directly load the compiled graph(s) for dynamic shape from the cache, took 5.456 s
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:34:07 [monitor.py:34] torch.compile takes 7.70 s in total
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:34:07 [monitor.py:34] torch.compile takes 7.94 s in total
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:34:08 [gpu_worker.py:276] Available KV cache memory: 56.07 GiB
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:34:08 [gpu_worker.py:276] Available KV cache memory: 56.07 GiB
[1;36m(EngineCore_0 pid=3663301)[0;0m INFO 08-21 06:34:08 [kv_cache_utils.py:849] GPU KV cache size: 146,976 tokens
[1;36m(EngineCore_0 pid=3663301)[0;0m INFO 08-21 06:34:08 [kv_cache_utils.py:853] Maximum concurrency for 4,096 tokens per request: 35.88x
[1;36m(EngineCore_0 pid=3663301)[0;0m INFO 08-21 06:34:08 [kv_cache_utils.py:849] GPU KV cache size: 146,976 tokens
[1;36m(EngineCore_0 pid=3663301)[0;0m INFO 08-21 06:34:08 [kv_cache_utils.py:853] Maximum concurrency for 4,096 tokens per request: 35.88x
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):   0%|          | 0/67 [00:00<?, ?it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):   4%|▍         | 3/67 [00:00<00:02, 23.80it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):   9%|▉         | 6/67 [00:00<00:02, 24.13it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  13%|█▎        | 9/67 [00:00<00:02, 24.19it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  18%|█▊        | 12/67 [00:00<00:02, 24.16it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  22%|██▏       | 15/67 [00:00<00:02, 24.55it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  27%|██▋       | 18/67 [00:00<00:02, 24.31it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  31%|███▏      | 21/67 [00:00<00:01, 24.89it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  36%|███▌      | 24/67 [00:00<00:01, 24.63it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  40%|████      | 27/67 [00:01<00:01, 24.24it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  45%|████▍     | 30/67 [00:01<00:01, 23.47it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  49%|████▉     | 33/67 [00:01<00:01, 23.03it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  54%|█████▎    | 36/67 [00:01<00:01, 22.75it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  58%|█████▊    | 39/67 [00:01<00:01, 22.75it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  63%|██████▎   | 42/67 [00:01<00:01, 22.57it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  67%|██████▋   | 45/67 [00:01<00:00, 22.63it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  72%|███████▏  | 48/67 [00:02<00:00, 22.56it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  76%|███████▌  | 51/67 [00:02<00:00, 22.38it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  81%|████████  | 54/67 [00:02<00:00, 22.52it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  85%|████████▌ | 57/67 [00:02<00:00, 22.39it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  90%|████████▉ | 60/67 [00:02<00:00, 22.67it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  94%|█████████▍| 63/67 [00:02<00:00, 22.74it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  99%|█████████▊| 66/67 [00:02<00:00, 23.36it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE): 100%|██████████| 67/67 [00:02<00:00, 23.33it/s]
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:34:11 [custom_all_reduce.py:196] Registering 5427 cuda graph addresses
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:34:11 [custom_all_reduce.py:196] Registering 5427 cuda graph addresses
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP1 pid=3663309)[0;0m INFO 08-21 06:34:11 [gpu_model_runner.py:2708] Graph capturing finished in 3 secs, took 0.71 GiB
[1;36m(EngineCore_0 pid=3663301)[0;0m [1;36m(VllmWorker TP0 pid=3663307)[0;0m INFO 08-21 06:34:11 [gpu_model_runner.py:2708] Graph capturing finished in 3 secs, took 0.71 GiB
[1;36m(EngineCore_0 pid=3663301)[0;0m INFO 08-21 06:34:11 [core.py:214] init engine (profile, create kv cache, warmup model) took 22.02 seconds
INFO 08-21 06:34:12 [llm.py:298] Supported_tasks: ['generate']
Translating 225 files...
  0%|          | 0/225 [00:00<?, ?it/s]100%|██████████| 225/225 [00:00<00:00, 10685.34it/s]
Adding requests:   0%|          | 0/225 [00:00<?, ?it/s]Adding requests:  63%|██████▎   | 141/225 [00:00<00:00, 1403.28it/s]Adding requests: 100%|██████████| 225/225 [00:00<00:00, 716.49it/s] 
Processed prompts:   0%|          | 0/225 [00:00<?, ?it/s, est. speed input: 0.00 toks/s, output: 0.00 toks/s]Processed prompts:   0%|          | 1/225 [00:09<33:55,  9.09s/it, est. speed input: 32.80 toks/s, output: 24.32 toks/s]Processed prompts:   1%|▏         | 3/225 [00:09<09:38,  2.60s/it, est. speed input: 94.69 toks/s, output: 70.09 toks/s]Processed prompts:   2%|▏         | 4/225 [00:11<08:34,  2.33s/it, est. speed input: 123.88 toks/s, output: 85.07 toks/s]Processed prompts:   2%|▏         | 5/225 [00:11<06:07,  1.67s/it, est. speed input: 161.52 toks/s, output: 108.94 toks/s]Processed prompts:   3%|▎         | 6/225 [00:12<04:22,  1.20s/it, est. speed input: 206.62 toks/s, output: 133.45 toks/s]Processed prompts:   4%|▍         | 9/225 [00:12<01:55,  1.87it/s, est. speed input: 293.95 toks/s, output: 210.05 toks/s]Processed prompts:   4%|▍         | 10/225 [00:12<01:37,  2.21it/s, est. speed input: 315.88 toks/s, output: 233.65 toks/s]Processed prompts:   5%|▍         | 11/225 [00:13<01:57,  1.83it/s, est. speed input: 335.95 toks/s, output: 245.22 toks/s]Processed prompts:   5%|▌         | 12/225 [00:13<01:33,  2.29it/s, est. speed input: 400.15 toks/s, output: 270.03 toks/s]Processed prompts:   6%|▌         | 14/225 [00:13<01:00,  3.50it/s, est. speed input: 442.60 toks/s, output: 320.14 toks/s]Processed prompts:   7%|▋         | 16/225 [00:13<00:42,  4.95it/s, est. speed input: 494.15 toks/s, output: 370.76 toks/s]Processed prompts:   8%|▊         | 18/225 [00:13<00:33,  6.21it/s, est. speed input: 554.32 toks/s, output: 419.48 toks/s]Processed prompts:   9%|▉         | 20/225 [00:14<00:30,  6.79it/s, est. speed input: 593.21 toks/s, output: 465.44 toks/s]Processed prompts:  10%|▉         | 22/225 [00:14<00:26,  7.70it/s, est. speed input: 643.64 toks/s, output: 511.01 toks/s]Processed prompts:  11%|█         | 25/225 [00:14<00:21,  9.50it/s, est. speed input: 739.40 toks/s, output: 583.10 toks/s]Processed prompts:  12%|█▏        | 27/225 [00:14<00:18, 10.82it/s, est. speed input: 824.95 toks/s, output: 631.64 toks/s]Processed prompts:  13%|█▎        | 29/225 [00:14<00:20,  9.35it/s, est. speed input: 849.66 toks/s, output: 672.73 toks/s]Processed prompts:  14%|█▍        | 31/225 [00:15<00:20,  9.69it/s, est. speed input: 891.94 toks/s, output: 717.68 toks/s]Processed prompts:  15%|█▍        | 33/225 [00:15<00:19,  9.96it/s, est. speed input: 942.22 toks/s, output: 762.49 toks/s]Processed prompts:  16%|█▌        | 35/225 [00:15<00:20,  9.28it/s, est. speed input: 975.65 toks/s, output: 803.67 toks/s]Processed prompts:  16%|█▋        | 37/225 [00:15<00:18, 10.13it/s, est. speed input: 1012.39 toks/s, output: 849.34 toks/s]Processed prompts:  17%|█▋        | 39/225 [00:15<00:16, 11.26it/s, est. speed input: 1055.73 toks/s, output: 895.80 toks/s]Processed prompts:  18%|█▊        | 41/225 [00:15<00:14, 12.48it/s, est. speed input: 1101.71 toks/s, output: 942.48 toks/s]Processed prompts:  19%|█▉        | 43/225 [00:16<00:14, 12.94it/s, est. speed input: 1145.83 toks/s, output: 987.44 toks/s]Processed prompts:  20%|██        | 46/225 [00:16<00:12, 13.99it/s, est. speed input: 1195.24 toks/s, output: 1049.65 toks/s]Processed prompts:  21%|██▏       | 48/225 [00:16<00:17, 10.02it/s, est. speed input: 1215.00 toks/s, output: 1080.22 toks/s]Processed prompts:  22%|██▏       | 50/225 [00:16<00:15, 11.63it/s, est. speed input: 1275.07 toks/s, output: 1127.07 toks/s]Processed prompts:  24%|██▎       | 53/225 [00:16<00:13, 13.09it/s, est. speed input: 1356.11 toks/s, output: 1194.69 toks/s]Processed prompts:  25%|██▍       | 56/225 [00:16<00:11, 15.30it/s, est. speed input: 1466.99 toks/s, output: 1264.65 toks/s]Processed prompts:  26%|██▌       | 58/225 [00:17<00:13, 12.45it/s, est. speed input: 1490.02 toks/s, output: 1299.09 toks/s]Processed prompts:  27%|██▋       | 61/225 [00:17<00:11, 14.40it/s, est. speed input: 1544.36 toks/s, output: 1367.46 toks/s]Processed prompts:  28%|██▊       | 64/225 [00:17<00:14, 10.83it/s, est. speed input: 1581.13 toks/s, output: 1414.03 toks/s]Processed prompts:  30%|██▉       | 67/225 [00:17<00:12, 12.77it/s, est. speed input: 1627.36 toks/s, output: 1482.18 toks/s]Processed prompts:  31%|███       | 70/225 [00:18<00:10, 14.57it/s, est. speed input: 1682.27 toks/s, output: 1550.01 toks/s]Processed prompts:  32%|███▏      | 72/225 [00:18<00:13, 11.49it/s, est. speed input: 1697.35 toks/s, output: 1577.99 toks/s]Processed prompts:  33%|███▎      | 75/225 [00:18<00:10, 13.85it/s, est. speed input: 1752.49 toks/s, output: 1646.64 toks/s]Processed prompts:  34%|███▍      | 77/225 [00:18<00:11, 13.20it/s, est. speed input: 1839.44 toks/s, output: 1684.28 toks/s]Processed prompts:  35%|███▌      | 79/225 [00:18<00:12, 11.52it/s, est. speed input: 1857.38 toks/s, output: 1716.00 toks/s]Processed prompts:  36%|███▋      | 82/225 [00:19<00:12, 11.89it/s, est. speed input: 1907.85 toks/s, output: 1773.76 toks/s]Processed prompts:  37%|███▋      | 84/225 [00:19<00:10, 12.87it/s, est. speed input: 1962.96 toks/s, output: 1816.15 toks/s]Processed prompts:  39%|███▊      | 87/225 [00:19<00:09, 14.82it/s, est. speed input: 2033.15 toks/s, output: 1882.18 toks/s]Processed prompts:  40%|███▉      | 89/225 [00:19<00:11, 11.53it/s, est. speed input: 2044.12 toks/s, output: 1908.25 toks/s]Processed prompts:  40%|████      | 91/225 [00:19<00:11, 12.09it/s, est. speed input: 2089.55 toks/s, output: 1948.01 toks/s]Processed prompts:  42%|████▏     | 95/225 [00:20<00:08, 16.04it/s, est. speed input: 2175.59 toks/s, output: 2041.50 toks/s]Processed prompts:  43%|████▎     | 97/225 [00:20<00:08, 15.61it/s, est. speed input: 2223.43 toks/s, output: 2081.03 toks/s]Processed prompts:  44%|████▍     | 100/225 [00:20<00:06, 18.23it/s, est. speed input: 2306.66 toks/s, output: 2143.36 toks/s]Processed prompts:  46%|████▌     | 103/225 [00:20<00:08, 13.89it/s, est. speed input: 2352.06 toks/s, output: 2190.35 toks/s]Processed prompts:  47%|████▋     | 106/225 [00:20<00:08, 13.42it/s, est. speed input: 2381.45 toks/s, output: 2246.54 toks/s]Processed prompts:  48%|████▊     | 109/225 [00:20<00:07, 16.05it/s, est. speed input: 2427.82 toks/s, output: 2308.94 toks/s]Processed prompts:  50%|████▉     | 112/225 [00:21<00:06, 16.89it/s, est. speed input: 2484.62 toks/s, output: 2373.74 toks/s]Processed prompts:  51%|█████     | 114/225 [00:21<00:07, 14.41it/s, est. speed input: 2488.01 toks/s, output: 2392.49 toks/s]Processed prompts:  52%|█████▏    | 117/225 [00:21<00:06, 17.29it/s, est. speed input: 2560.43 toks/s, output: 2463.41 toks/s]Processed prompts:  53%|█████▎    | 120/225 [00:21<00:07, 14.52it/s, est. speed input: 2620.73 toks/s, output: 2503.53 toks/s]Processed prompts:  55%|█████▌    | 124/225 [00:21<00:05, 16.90it/s, est. speed input: 2711.93 toks/s, output: 2588.51 toks/s]Processed prompts:  57%|█████▋    | 128/225 [00:21<00:04, 19.57it/s, est. speed input: 2770.61 toks/s, output: 2678.31 toks/s]Processed prompts:  58%|█████▊    | 131/225 [00:22<00:04, 19.13it/s, est. speed input: 2802.66 toks/s, output: 2736.42 toks/s]Processed prompts:  60%|█████▉    | 134/225 [00:22<00:04, 18.90it/s, est. speed input: 2895.86 toks/s, output: 2800.62 toks/s]Processed prompts:  60%|██████    | 136/225 [00:22<00:04, 18.59it/s, est. speed input: 2910.45 toks/s, output: 2818.41 toks/s]Processed prompts:  61%|██████▏   | 138/225 [00:22<00:05, 16.01it/s, est. speed input: 2949.29 toks/s, output: 2843.45 toks/s]Processed prompts:  64%|██████▎   | 143/225 [00:22<00:04, 18.44it/s, est. speed input: 3018.77 toks/s, output: 2950.44 toks/s]Processed prompts:  64%|██████▍   | 145/225 [00:22<00:04, 18.42it/s, est. speed input: 3046.08 toks/s, output: 2993.54 toks/s]Processed prompts:  65%|██████▌   | 147/225 [00:23<00:04, 17.67it/s, est. speed input: 3091.81 toks/s, output: 3034.06 toks/s]Processed prompts:  67%|██████▋   | 150/225 [00:23<00:03, 19.25it/s, est. speed input: 3148.84 toks/s, output: 3096.37 toks/s]Processed prompts:  68%|██████▊   | 154/225 [00:23<00:02, 23.87it/s, est. speed input: 3235.56 toks/s, output: 3187.18 toks/s]Processed prompts:  70%|██████▉   | 157/225 [00:23<00:05, 12.74it/s, est. speed input: 3246.99 toks/s, output: 3197.66 toks/s]Processed prompts:  71%|███████   | 159/225 [00:24<00:06, 10.89it/s, est. speed input: 3247.09 toks/s, output: 3210.63 toks/s]Processed prompts:  72%|███████▏  | 161/225 [00:24<00:05, 10.71it/s, est. speed input: 3292.31 toks/s, output: 3233.98 toks/s]Processed prompts:  72%|███████▏  | 163/225 [00:24<00:05, 11.53it/s, est. speed input: 3326.93 toks/s, output: 3261.14 toks/s]Processed prompts:  73%|███████▎  | 165/225 [00:24<00:05, 10.63it/s, est. speed input: 3344.09 toks/s, output: 3290.80 toks/s]Processed prompts:  74%|███████▍  | 167/225 [00:24<00:05, 10.64it/s, est. speed input: 3375.40 toks/s, output: 3326.34 toks/s]Processed prompts:  75%|███████▌  | 169/225 [00:25<00:05,  9.61it/s, est. speed input: 3405.11 toks/s, output: 3342.04 toks/s]Processed prompts:  76%|███████▌  | 171/225 [00:25<00:04, 10.83it/s, est. speed input: 3440.72 toks/s, output: 3370.63 toks/s]Processed prompts:  77%|███████▋  | 173/225 [00:25<00:06,  8.33it/s, est. speed input: 3461.53 toks/s, output: 3383.01 toks/s]Processed prompts:  78%|███████▊  | 175/225 [00:25<00:06,  8.11it/s, est. speed input: 3474.96 toks/s, output: 3393.18 toks/s]Processed prompts:  78%|███████▊  | 176/225 [00:26<00:07,  6.54it/s, est. speed input: 3462.20 toks/s, output: 3386.58 toks/s]Processed prompts:  79%|███████▉  | 178/225 [00:26<00:05,  7.99it/s, est. speed input: 3490.02 toks/s, output: 3432.19 toks/s]Processed prompts:  80%|████████  | 180/225 [00:26<00:06,  6.58it/s, est. speed input: 3477.33 toks/s, output: 3424.56 toks/s]Processed prompts:  83%|████████▎ | 186/225 [00:26<00:03, 10.89it/s, est. speed input: 3585.64 toks/s, output: 3535.69 toks/s]Processed prompts:  84%|████████▍ | 189/225 [00:27<00:02, 12.27it/s, est. speed input: 3623.43 toks/s, output: 3598.91 toks/s]Processed prompts:  85%|████████▍ | 191/225 [00:27<00:04,  7.98it/s, est. speed input: 3591.20 toks/s, output: 3579.51 toks/s]Processed prompts:  87%|████████▋ | 195/225 [00:27<00:02, 10.65it/s, est. speed input: 3682.41 toks/s, output: 3670.54 toks/s]Processed prompts:  88%|████████▊ | 198/225 [00:28<00:02,  9.50it/s, est. speed input: 3727.64 toks/s, output: 3719.65 toks/s]Processed prompts:  89%|████████▉ | 200/225 [00:28<00:03,  7.47it/s, est. speed input: 3701.84 toks/s, output: 3706.70 toks/s]Processed prompts:  89%|████████▉ | 201/225 [00:28<00:03,  6.84it/s, est. speed input: 3695.16 toks/s, output: 3713.02 toks/s]Processed prompts:  90%|████████▉ | 202/225 [00:29<00:03,  5.92it/s, est. speed input: 3675.11 toks/s, output: 3704.68 toks/s]Processed prompts:  90%|█████████ | 203/225 [00:29<00:04,  5.20it/s, est. speed input: 3667.53 toks/s, output: 3703.03 toks/s]Processed prompts:  91%|█████████ | 204/225 [00:29<00:03,  5.36it/s, est. speed input: 3679.28 toks/s, output: 3718.61 toks/s]Processed prompts:  92%|█████████▏| 206/225 [00:30<00:04,  3.99it/s, est. speed input: 3641.25 toks/s, output: 3698.32 toks/s]Processed prompts:  92%|█████████▏| 207/225 [00:30<00:05,  3.42it/s, est. speed input: 3629.12 toks/s, output: 3682.71 toks/s]Processed prompts:  92%|█████████▏| 208/225 [00:31<00:05,  2.99it/s, est. speed input: 3599.06 toks/s, output: 3655.62 toks/s]Processed prompts:  93%|█████████▎| 209/225 [00:32<00:06,  2.39it/s, est. speed input: 3558.56 toks/s, output: 3614.94 toks/s]Processed prompts:  93%|█████████▎| 210/225 [00:33<00:09,  1.59it/s, est. speed input: 3458.87 toks/s, output: 3515.28 toks/s]Processed prompts:  94%|█████████▍| 211/225 [00:34<00:10,  1.30it/s, est. speed input: 3365.13 toks/s, output: 3430.71 toks/s]Processed prompts:  94%|█████████▍| 212/225 [00:40<00:28,  2.16s/it, est. speed input: 2911.98 toks/s, output: 2988.52 toks/s]Processed prompts:  95%|█████████▍| 213/225 [00:57<01:16,  6.40s/it, est. speed input: 2061.15 toks/s, output: 2157.76 toks/s]Processed prompts:  95%|█████████▌| 214/225 [00:58<00:53,  4.83s/it, est. speed input: 2039.19 toks/s, output: 2178.76 toks/s]Processed prompts:  96%|█████████▌| 215/225 [00:58<00:36,  3.67s/it, est. speed input: 2020.55 toks/s, output: 2204.21 toks/s]Processed prompts:  96%|█████████▌| 216/225 [00:59<00:24,  2.70s/it, est. speed input: 2018.63 toks/s, output: 2248.11 toks/s]Processed prompts:  96%|█████████▋| 217/225 [01:01<00:19,  2.50s/it, est. speed input: 1960.27 toks/s, output: 2232.85 toks/s]Processed prompts:  97%|█████████▋| 218/225 [01:01<00:12,  1.79s/it, est. speed input: 1964.21 toks/s, output: 2287.13 toks/s]Processed prompts:  97%|█████████▋| 219/225 [01:02<00:08,  1.42s/it, est. speed input: 1954.32 toks/s, output: 2326.34 toks/s]Processed prompts:  98%|█████████▊| 220/225 [01:02<00:05,  1.10s/it, est. speed input: 1949.37 toks/s, output: 2371.99 toks/s]Processed prompts:  98%|█████████▊| 221/225 [01:02<00:03,  1.21it/s, est. speed input: 1949.75 toks/s, output: 2424.22 toks/s]Processed prompts:  99%|█████████▊| 222/225 [01:03<00:02,  1.30it/s, est. speed input: 1935.61 toks/s, output: 2459.99 toks/s]Processed prompts:  99%|█████████▉| 223/225 [01:03<00:01,  1.74it/s, est. speed input: 1936.59 toks/s, output: 2514.82 toks/s]Processed prompts: 100%|█████████▉| 224/225 [01:04<00:00,  1.62it/s, est. speed input: 1921.52 toks/s, output: 2544.46 toks/s]Processed prompts: 100%|██████████| 225/225 [01:04<00:00,  1.47it/s, est. speed input: 1902.98 toks/s, output: 2569.21 toks/s]Processed prompts: 100%|██████████| 225/225 [01:04<00:00,  1.47it/s, est. speed input: 1902.98 toks/s, output: 2569.21 toks/s]Processed prompts: 100%|██████████| 225/225 [01:04<00:00,  3.47it/s, est. speed input: 1902.98 toks/s, output: 2569.21 toks/s]
+ python3 clean_generations_translation.py --model codellama/CodeLlama-13b-Instruct-hf --dataset Avatar --source_lang Python --target_lang Java --remove_prompt --use_test
  0%|          | 0/225 [00:00<?, ?it/s]public static void main(String[] args) {
    int numVertices = 10;
    Graph graph = new Graph(numVertices);
    graph.addEdge(0, 1);
    graph.addEdge(1, 2);
    graph.addEdge(2, 3);
    graph.addEdge(3, 4);
    graph.addEdge(4, 5);
    graph.addEdge(5, 6);
    graph.addEdge(6, 7);
    graph.addEdge(7, 8);
    graph.addEdge(8, 9);

    GraphColoring graphColoring = new GraphColoring(graph);
    int minimumColoring = graphColoring.getMinimumColoring();
    System.out.println(minimumColoring);
}
import java.util.Date;
import java.util.Base64;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Scanner;
import java.util.Arrays;
import java.util.Random;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicInteger;

public class atcoder_AGC028_B {
    public static void main(String[] args) {
        int inputNumber = Integer.parseInt(args[0]);
        int[] A = new int[inputNumber];
        for (int i = 0; i < inputNumber; i++) {
            A[i] = ThreadLocalRandom.current().nextInt(1000000000);
        }
        int[] shuffledA = shuffle(A);
        int[] inverse = new int[inputNumber];
        for (int i = 0; i < inputNumber; i++) {
            inverse[i] = (int) Math.pow(i + 1, 1000000000 - 2) % 1000000000;
        }
        int[] cumulativeInverse = new int[inputNumber];
        cumulativeInverse[0] = inverse[0];
        for (int i = 1; i < inputNumber; i++) {
            cumulativeInverse[i] = (cumulativeInverse[i - 1] + inverse[i]) % 1000000000;
        }
        int[] temp = new int[inputNumber];
        for (int i = 0; i < inputNumber; i++) {
            temp[i] = (inverse[i] + inverse[inputNumber - 1 - i] - 1) % 1000000000;
        }
        int sum = 0;
        for (int i = 0; i < inputNumber; i++) {
            sum += (A[i] * temp[i]) % 1000000000;
        }
        sum %= 1000000000;
        System.out.println(sum);
    }

    public static int[] shuffle(int[] array) {
        int[] shuffledArray = new int[array.length];
        for (int i = 0; i < array.length; i++) {
            shuffledArray[i] = array[i];
        }
        for (int i = 0; i < array.length; i++) {
            int randomIndex = ThreadLocalRandom.current().nextInt(array.length);
            int temp = shuffledArray[i];
            shuffledArray[i] = shuffledArray[randomIndex];
            shuffledArray[randomIndex] = temp;
        }
        return shuffledArray;
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_569_A {
    public static void main(String[] args) {
        int targetValue = Integer.parseInt(args[0]);
        int s = Integer.parseInt(args[1]);
        int q = Integer.parseInt(args[2]);

        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        Thread workerThread = new Thread(() -> {
            int calculationResult = calculateProduct(s, q);
            queue.put(calculationResult);
        });

        workerThread.start();
        workerThread.join();

        int resultCalculateProduct = queue.get();
        s = resultCalculateProduct;

        int operationCount = 0;
        while (s < targetValue) {
            queue.put(calculateProduct(s, q));
            operationCount++;
        }

        System.out.println(operationCount);
    }

    private static int calculateProduct(int s, int q) {
        return s * q;
    }
}
import java.util.Scanner;

public class atcoder_ABC112_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] ls_xyh = new int[n][3];
        for (int i = 0; i < n; i++) {
            ls_xyh[i][0] = sc.nextInt();
            ls_xyh[i][1] = sc.nextInt();
            ls_xyh[i][2] = sc.nextInt();
        }
        int x0 = 0;
        int y0 = 0;
        int h0 = 0;
        for (int i = 0; i < n; i++) {
            if (ls_xyh[i][2] > 0) {
                x0 = ls_xyh[i][0];
                y0 = ls_xyh[i][1];
                h0 = ls_xyh[i][2];
                break;
            }
        }
        int[][] cands = new int[101][101];
        for (int i = 0; i < 101; i++) {
            for (int j = 0; j < 101; j++) {
                cands[i][j] = h0 + Math.abs(i - x0) + Math.abs(j - y0);
            }
        }
        for (int i = 0; i < n; i++) {
            int x = ls_xyh[i][0];
            int y = ls_xyh[i][1];
            int h = ls_xyh[i][2];
            for (int j = 0; j < 101; j++) {
                for (int k = 0; k < 101; k++) {
                    if (cands[j][k] > 0) {
                        cands[j][k] = Math.max(cands[j][k] - Math.abs(j - x) - Math.abs(k - y), 0);
                    }
                }
            }
        }
        int xx = 0;
        int yy = 0;
        int hh = 0;
        for (int i = 0; i < 101; i++) {
            for (int j = 0; j < 101; j++) {
                if (cands[i][j] > hh) {
                    xx = i;
                    yy = j;
                    hh = cands[i][j];
                }
            }
        }
        System.out.println(xx + " " + yy + " " + hh);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Arrays;

public class atcoder_ABC104_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int D = scanner.nextInt();
        int G = scanner.nextInt();
        ArrayList<Integer> PC = new ArrayList<>();
        for (int i = 0; i < D; i++) {
            int[] temp = new int[2];
            temp[0] = scanner.nextInt();
            temp[1] = scanner.nextInt();
            PC.add(temp);
        }
        int ans = 1000000000;
        int checkOne = 293;
        int checkTwo = 657;
        for (int subsetIndex = 0; subsetIndex < (1 << D); subsetIndex++) {
            int score = 0;
            int problem = 0;
            for (int j = 0; j < D; j++) {
                if ((subsetIndex >> j & 1) == 1) {
                    score += 100 * (j + 1) * PC.get(j)[0] + PC.get(j)[1];
                    problem += PC.get(j)[0];
                }
            }
            if (checkOne & checkTwo) {
                if (score > G) {
                    continue;
                }
            }
            int left = G - score;
            for (int j = 0; j < D; j++) {
                if ((subsetIndex >> j & 1) == 1) {
                    continue;
                }
                if (left > 100 * (j + 1) * PC.get(j)[0] + PC.get(j)[1]) {
                    continue;
                } else {
                    int temp = (left + 100 * (j + 1) - 1) / (100 * (j + 1));
                    ans = Math.min(ans, problem + Math.min(temp, PC.get(j)[0]));
                }
            }
        }
        System.out.println(ans);
    }
}
import java.util.Base64;
import java.net.HttpURLConnection;
import java.net.URL;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class codeforces_678_A {
    public static void main(String[] args) {
        try {
            Base64.getEncoder().encodeToString(new byte[] {46, 59, 79});
            List<Integer> shuffledList = Arrays.asList(25, 69, 70);
            Collections.shuffle(shuffledList);
            Thread.sleep(230);
            LocalDateTime dateTime = LocalDateTime.parse("2025-08-17 23:53:04", DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));

            int dividend = Integer.parseInt(args[0]);
            int divisor = Integer.parseInt(args[1]);
            int result = dividend / divisor;
            System.out.println((result + 1) * divisor);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class atcoder_AGC033_B {
    public static void main(String[] args) {
        int H = 65419;
        int W = 92381;
        int N = 157799;
        int s_r = 22633;
        int s_c = 46136;
        String S = "RRLLLRRLRRRLLRLRRLLRLRLRLLRLRRLLRLRLRLRLLLLRLRRLRLLLRRLLRRLLLRRLLRRRLLRRRRLLRRLRLLLRLLRLLLLRRLRRRRRRRLLRLLLRRRRLLLLLLLRLRRRRLRLRRLLLLRLRLRRLLLLRLLLLRLRRLRLLRLRRRLRRRRRLRLRLLRLRRRRRRRLLRRRRRRRRRLLRRLRLRLRRLLLRRRRLRRLRRRRRRLLRRRLLLRRRRRRLRRLRRRRLRLRRLRRLLRLRLRRRRRLLLLRRLLLRRLLRLLLLRRLLLLRRRRRLLLRLLLRLRRRLRLLRRLLLRRRLRLLRLRRRRLLRRRRRLLLRRRRRLRRLLRRRRLLLRRLRLLRRLRRLLLRLRLRRRRLRLRRRRLRLRRLRRRRLLLLRRRLRRLRLRRRRRLRLLLLLLRRRLRLRRRLRLRLRLRLRRLLRLRRRLRLLRRLRLLRRRRRLLRLRLRRRR";
        String T = "RRLLLRRLRRRLLRLRRLLRLRLRLLRLRRLLRLRLRLRLLLLRLRRLRLLLRRLLRRLLLRRLLRRRLLRRRRLLRRLRLLLRLLRLLLLRRLRRRRRRRLLRLLLRRRRLLLLLLLRLRRRRLRLRRLLLLRLRLRRLLLLRLLLLRLRRLRLLRLRRRLRRRRRLRLRLLRLRRRRRRRLLRRRRRRRRRLLRRLRLRLRRLLLRRRRLRRLRRRRRRLLRRRLLLRRRRRRLRRLRRRRLRLRRLRRLLRLRLRRRRRLLLLRRLLLRRLLRLLLLRRLLLLRRRRRLLLRLLLRLRRRLRLLRRLLLRRRLRLLRLRRRRLLRRRRRLLLRRRRRLRRLLRRRRLLLRRLRLLRRLRRLLLRLRLRRRRLRLRRRRLRLRRLRRRRLLLLRRRLRRLRLRRRRRLRLLLLLLRRRLRLRRRLRLRLRLRLRRLLRLRRRLRLLRRLRLLRRRRRLLRLRLRRRR";
        boolean Judge = false;
        int S_L = 0;
        int S_R = 0;
        int current_up_moves = 0;
        int S_D = 0;
        int T_L = 0;
        int T_R = 0;
        int T_U = 0;
        int T_D = 0;
        int inner_loop_bound = 93;
        int outer_loop_bound = 92;

        ExecutorService executor = Executors.newFixedThreadPool(2);
        Future<Integer> future1 = executor.submit(() -> calculateSum(S_L, 1));
        Future<Integer> future2 = executor.submit(() -> calculateSum(S_R, 1));
        Future<Integer> future3 = executor.submit(() -> calculateSum(current_up_moves, 1));
        Future<Integer> future4 = executor.submit(() -> calculateSum(S_D, 1));
        Future<Integer> future5 = executor.submit(() -> calculateSum(T_L, 1));
        Future<Integer> future6 = executor.submit(() -> calculateSum(T_R, 1));
        Future<Integer> future7 = executor.submit(() -> calculateSum(T_U, 1));
        Future<Integer> future8 = executor.submit(() -> calculateSum(T_D, 1));

        for (int LoopIndexOut = 0; LoopIndexOut < inner_loop_bound / outer_loop_bound; LoopIndexOut++) {
            for (int x = 0; x < N; x++) {
                if (S.charAt(x) == 'L') {
                    S_L = future1.get();
                    if (S_L - T_R - s_c == 0) {
                        Judge = true;
                    }
                } else if (S.charAt(x) == 'R') {
                    S_R = future2.get();
                    if (s_c + (S_R - T_L) == W + 1) {
                        Judge = true;
                    }
                } else if (S.charAt(x) == 'U') {
                    current_up_moves = future3.get();
                    if (current_up_moves - T_D - s_r == 0) {
                        Judge = true;
                    }
                } else if (S.charAt(x) == 'D') {
                    S_D = future4.get();
                    if (s_r + (S_D - T_U) == H + 1) {
                        Judge = true;
                    }
                }
                if (T.charAt(x) == 'L') {
                    if (S_R - T_L + s_c != 1) {
                        T_L = future5.get();
                    }
                } else if (T.charAt(x) == 'R') {
                    if (s_c + (T_R - S_L) != W) {
                        T_R = future6.get();
                    }
                } else if (T.charAt(x) == 'U') {
                    if (S_D - T_U + s_r != 1) {
                        T_U = future7.get();
                    }
                } else if (T.charAt(x) == 'D') {
                    if (s_r + (T_D - current_up_moves) != H) {
                        T_D = future8.get();
                    }
                }
            }
        }

        if (Judge) {
            System.out.println("NO");
        } else {
            System.out.println("YES");
        }
    }

    private static int calculateSum(int value1, int value2) {
        return value1 + value2;
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_55_A {
    public static void main(String[] args) {
        int inputNumber = Integer.parseInt(args[0]);
        int divisor = 2;
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        Thread thread = new Thread(() -> {
            int result = divisionOperation(inputNumber, divisor);
            queue.put(result);
        });

        thread.start();
        thread.join();

        int result = queue.take();
        inputNumber = result;

        if (inputNumber == 1) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
        }
    }

    private static int divisionOperation(int inputNumber, int divisor) {
        return inputNumber / divisor;
    }
}
import java.util.Scanner;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;

public class atcoder_ABC106_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        int k = scanner.nextInt();
        int l = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) != '1') {
                break;
            }
            l++;
        }
        if (l >= k) {
            System.out.println(1);
        } else {
            System.out.println(s.charAt(l));
        }
    }
}
import java.util.Scanner;

public class codeforces_404_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int matrixSize = sc.nextInt();
        String[][] matrix = new String[matrixSize][matrixSize];
        for (int i = 0; i < matrixSize; i++) {
            for (int j = 0; j < matrixSize; j++) {
                matrix[i][j] = sc.next();
            }
        }
        boolean isMagic = true;
        for (int i = 0; i < matrixSize; i++) {
            for (int j = 0; j < matrixSize; j++) {
                if (i == j) {
                    if (matrix[i][j] != matrix[i][j]) {
                        isMagic = false;
                        break;
                    }
                }
                if (i == matrixSize - j - 1) {
                    if (matrix[i][j] != matrix[i][j]) {
                        isMagic = false;
                        break;
                    }
                }
                if (i != j && i != matrixSize - j - 1) {
                    if (matrix[i][j] != matrix[i][j]) {
                        isMagic = false;
                        break;
                    }
                }
            }
        }
        if (isMagic) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
        }
    }
}
import java.util.Scanner;

public class atcoder_AGC046_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int A = sc.nextInt();
        int startColumn = sc.nextInt();
        int C = sc.nextInt();
        int D = sc.nextInt();
        int m = 998244353;
        int[][] d = new int[C + 1][D + 1];
        for (int i = 0; i < C + 1; i++) {
            for (int j = 0; j < D + 1; j++) {
                d[i][j] = 0;
            }
        }
        d[A][startColumn] = 1;
        for (int i = A; i <= C; i++) {
            for (int j = startColumn; j <= D; j++) {
                int aboveValue = d[i][j - 1];
                int leftValue = d[i - 1][j];
                int diagonalValue = d[i - 1][j - 1];
                int currentRow = d[i];
                int rowAbove = d[i - 1];
                int prevRow = d[i - 1];
                int constantOne = 1;
                int constantTwo = 1;
                d[i][j] += calculateMatrixValue(i, m, j, constantOne, diagonalValue, constantTwo, leftValue, aboveValue);
            }
        }
        System.out.println(d[C][D]);
    }

    public static int calculateMatrixValue(int i, int m, int j, int constantOne, int diagonalValue, int constantTwo, int leftValue, int aboveValue) {
        return (aboveValue * i + leftValue * j - diagonalValue * (i - constantTwo) * (j - constantOne)) % m;
    }
}
int[] allocatedMemory = new int[10];
MemoryAllocator allocator = new MemoryAllocator(allocatedMemory);
allocator.alloc(5);
allocator.erase(3);
allocator.defragment();
import java.util.Scanner;
import java.util.Map;
import java.util.HashMap;

public class codeforces_609_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[] lst = new int[n];
        for (int i = 0; i < n; i++) {
            lst[i] = scanner.nextInt();
        }
        Map<Integer, Integer> l = new HashMap<>();
        for (int i = 0; i < n; i++) {
            if (!l.containsKey(lst[i])) {
                l.put(lst[i], 1);
            } else {
                l.put(lst[i], l.get(lst[i]) + 1);
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            if (l.get(lst[i]) > 1) {
                res += n - i - l.get(lst[i]);
                l.put(lst[i], l.get(lst[i]) - 1);
            } else {
                res += n - i - 1;
            }
        }
        System.out.println(res);
    }
}
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

public class atcoder_ABC162_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String s = scanner.next();
        calculateRGBCombinations(n, s);
    }

    public static void calculateRGBCombinations(int n, String s) {
        List<Character> colorList = new ArrayList<>();
        for (int i = 0; i < s.length(); i++) {
            colorList.add(s.charAt(i));
        }
        int rNum = colorList.size();
        int gNum = colorList.size();
        int blueCount = colorList.size();
        int sum = 0;
        for (int step = 1; step <= Math.ceil(n / 2); step++) {
            for (int i = 0; i < n - 2 * step; i++) {
                String s = colorList.get(i) + colorList.get(i + step) + colorList.get(i + step * 2);
                if (s.equals("RGB") || s.equals("RBG") || s.equals("BGR") || s.equals("BRG") || s.equals("GBR") || s.equals("GRB")) {
                    sum++;
                }
            }
        }
        System.out.println(rNum * gNum * blueCount - sum);
    }
}
import java.util.Scanner;
import java.util.Deque;
import java.util.ArrayDeque;

public class atcoder_AGC014_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[][] adjacencyList = new int[N + 1][];
        for (int i = 0; i < N - 1; i++) {
            int[] edge = scanner.nextInt();
            adjacencyList[edge[0]].add(edge[1]);
            adjacencyList[edge[1]].add(edge[0]);
        }
        Deque<Integer> que = new ArrayDeque<>();
        que.add(1);
        int[] seen = new int[N + 1];
        seen[1] = 1;
        int[] par = new int[N + 1];
        int[] childCounts = new int[N + 1];
        while (!que.isEmpty()) {
            int v = que.pop();
            for (int u : adjacencyList[v]) {
                if (seen[u] == 0) {
                    seen[u] = 1;
                    par[u] = v;
                    childCounts[v]++;
                    que.add(u);
                }
            }
        }
        Deque<Integer> nodeQueue = new ArrayDeque<>();
        for (int i = 1; i <= N; i++) {
            if (FirstConditionChecker(i) && SecondConditionChecker(i)) {
                if (ThirdConditionChecker(i) && FourthConditionChecker(i)) {
                    if (childCounts[i] == 0) {
                        nodeQueue.add(i);
                    }
                }
            }
        }
        while (!nodeQueue.isEmpty()) {
            int c = nodeQueue.pop();
            seen[c] = 0;
            if (seen[par[c]] == 0) {
                System.out.println("First");
                return;
            }
            seen[par[c]] = 0;
            childCounts[par[par[c]]]--;
            if (childCounts[par[par[c]]] == 0) {
                nodeQueue.add(par[par[c]]);
            }
        }
        System.out.println("Second");
    }

    private static boolean FirstConditionChecker(int i) {
        // Implement the logic for the first condition checker
    }

    private static boolean SecondConditionChecker(int i) {
        // Implement the logic for the second condition checker
    }

    private static boolean ThirdConditionChecker(int i) {
        // Implement the logic for the third condition checker
    }

    private static boolean FourthConditionChecker(int i) {
        // Implement the logic for the fourth condition checker
    }
}
import java.util.Scanner;
import java.util.Queue;
import java.util.concurrent.Thread;

public class atcoder_ABC151_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        char c = input.charAt(0);
        Queue<Character> queue = new LinkedList<>();
        Thread thread = new Thread(() -> {
            char result = solve(c);
            queue.add(result);
        });
        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        char result = queue.poll();
        if (result instanceof List) {
            List<Character> list = (List<Character>) result;
            for (int i = 0; i < list.size(); i++) {
                System.out.print(list.get(i));
            }
        } else {
            System.out.print(result);
        }
    }

    public static char solve(char c) {
        String a = "abcdefghijklmnopqrstuvwxyz";
        int i = a.indexOf(c);
        return a.charAt(i + 1);
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_581_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(args[i + 1]);
        }
        int[] resultArray = new int[n];
        int mx = arr[n - 1];
        int conditionOne = 995;
        int conditionTwo = 398;
        int outerLoopCounter = 470;
        int innerLoopCounter = 469;
        BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();
        Thread workerThread = new Thread(() -> {
            int result = calculateProduct(arr, n);
            resultQueue.put(result);
        });
        workerThread.start();
        try {
            workerThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int calculationResult = resultQueue.take();
        for (int i = n - 2; i >= 0; i--) {
            resultArray[i] = Math.max(0, mx - arr[i] + 1);
            if (conditionOne & conditionTwo) {
                if (arr[i] > mx) {
                    mx = arr[i];
                }
            }
        }
        System.out.println(String.join(" ", resultArray));
    }

    private static int calculateProduct(int[] arr, int n) {
        int result = 1;
        for (int i = 0; i < n; i++) {
            result *= arr[i];
        }
        return result;
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Deque;
import java.util.ArrayDeque;

public class atcoder_ABC126_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        ArrayList<ArrayList<Integer>> edge = new ArrayList<ArrayList<Integer>>();
        for (int i = 0; i < N; i++) {
            edge.add(new ArrayList<Integer>());
        }
        for (int i = 0; i < M; i++) {
            int X = sc.nextInt() - 1;
            int Y = sc.nextInt() - 1;
            int Z = sc.nextInt() - 1;
            edge.get(X).add(Y);
            edge.get(Y).add(X);
        }
        boolean[] used = new boolean[N];
        int ans = 0;
        int checker_one = 229;
        int checker_two = 524;
        for (int i = 0; i < N; i++) {
            if ((checker_one & checker_two) != 0) {
                if (!used[i]) {
                    ans++;
                    Deque<Integer> queue = new ArrayDeque<Integer>();
                    queue.add(i);
                    while (!queue.isEmpty()) {
                        int node = queue.removeFirst();
                        used[node] = true;
                        for (int nextnode : edge.get(node)) {
                            if (!used[nextnode]) {
                                queue.add(nextnode);
                            }
                        }
                    }
                }
            }
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class atcoder_ABC132_F {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int mod = 1000000007;
        int[] coef = new int[n];
        for (int i = 1; i <= (int) Math.sqrt(n); i++) {
            coef[i] = n / i - n / (i + 1);
        }
        for (int i = (int) Math.sqrt(n) + 1; i < n; i++) {
            coef[i] = 1;
        }
        int[][] dp = new int[k + 1][n];
        dp[0][0] = 1;
        for (int i = 1; i <= k; i++) {
            int tmp = 0;
            for (int j = n - 1; j >= 0; j--) {
                tmp += dp[i - 1][n - 1 - j];
                tmp %= mod;
                dp[i][j] = coef[j] * tmp;
                dp[i][j] %= mod;
            }
        }
        System.out.println(Arrays.stream(dp[k]).sum() % mod);
    }
}
import java.util.Scanner;

public class codeforces_581_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int firstInput = scanner.nextInt();
        int secondInput = scanner.nextInt();
        int difference = differenceFunction(firstInput, secondInput);
        System.out.println(Math.min(firstInput, secondInput) + " " + difference);
    }

    public static int differenceFunction(int a, int b) {
        return a - b;
    }
}
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadLocalRandom;

public class codeforces_92_A {
    public static void main(String[] args) throws InterruptedException {
        int n = 29;
        int m = 7772;
        int currentValue = 1;
        int constantOne = 1;

        BlockingQueue<Integer> queueCalculateDifference = new LinkedBlockingQueue<>();
        Thread threadCalculateDifference = new Thread(() -> {
            int differenceResult = calculateDifference(currentValue, m);
            queueCalculateDifference.put(differenceResult);
        });
        threadCalculateDifference.start();
        threadCalculateDifference.join();
        int resultCalculateDifference = queueCalculateDifference.take();
        m = resultCalculateDifference;

        BlockingQueue<Integer> queueSumModulo = new LinkedBlockingQueue<>();
        Thread threadSumModulo = new Thread(() -> {
            int sumModuloResult = calculateSumWithModulo(currentValue, constantOne, n);
            queueSumModulo.put(sumModuloResult);
        });
        threadSumModulo.start();
        threadSumModulo.join();
        int sumModuloResult = queueSumModulo.take();
        currentValue = sumModuloResult;

        System.out.println(m);
    }

    private static int calculateDifference(int currentValue, int m) {
        return m - currentValue;
    }

    private static int calculateSumWithModulo(int currentValue, int constantOne, int n) {
        return (currentValue % n + constantOne) % n;
    }
}
import java.util.Scanner;

public class atcoder_ABC170_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] inputArray = scanner.nextLine().split(" ");
        int BitmaskThird = 853;
        int ConditionalValueThird = 517;
        int BitmaskFourth = 4;
        int ConditionalValueSecond = 317;
        int BitmaskFirst = 161;
        int BitmaskSecond = 225;

        for (int i = 0; i < inputArray.length; i++) {
            if ((BitmaskFirst & BitmaskSecond) != 0) {
                if ((BitmaskFourth & ConditionalValueSecond) != 0) {
                    if ((BitmaskThird & ConditionalValueThird) != 0) {
                        if (Integer.parseInt(inputArray[i]) == 0) {
                            System.out.println(i + 1);
                            break;
                        }
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_653_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] l = new int[n];
        for (int i = 0; i < n; i++) {
            l[i] = sc.nextInt();
        }
        Arrays.sort(l);
        int ValueCheckerSix = 347;
        int ValueCheckerTwo = 503;
        int ValueCheckerFour = 902;
        int ValueCheckerOne = 837;
        int ValueCheckerThree = 223;
        int ValueCheckerFive = 311;
        for (int i = 0; i < n; i++) {
            if (ValueCheckerThree & ValueCheckerFive) {
                if (ValueCheckerFour & ValueCheckerOne) {
                    if (ValueCheckerSix & ValueCheckerTwo) {
                        if (l[i] + 1 in l && l[i] + 2 in l) {
                            System.out.println("YES");
                            break;
                        }
                    }
                }
            }
        }
        System.out.println("NO");
    }
}
import java.util.Scanner;

public class codeforces_8_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int checkFlagG = 322;
        int checkFlagD = 882;
        int checkFlagC = 52;
        int intermediateResultFlag = 357;
        int intermediateCheckFlag = 451;
        int checkFlagB = 455;
        int checkFlagA = 545;
        int checkFlagE = 653;
        int intermediateResultFlag2 = 566;
        int checkFlagF = 280;

        String movementRecord = scanner.nextLine();
        int x = 0;
        int y = 0;
        int[][] d_movement = { { 0, -1 }, { 0, 1 }, { 1, 0 }, { -1, 0 } };
        boolean bug = false;
        boolean visited = new boolean[100][100];

        for (int i = 0; i < movementRecord.length(); i++) {
            char move = movementRecord.charAt(i);
            int tempX = x;
            int tempY = y;
            x += d_movement[move][0];
            y += d_movement[move][1];
            if (intermediateResultFlag2 & checkFlagF) {
                if (checkFlagA & checkFlagE) {
                    if (!visited[x][y]) {
                        for (int j = 0; j < d_movement.length; j++) {
                            if (x + d_movement[j][0] != tempX && y + d_movement[j][1] != tempY && visited[x + d_movement[j][0]][y + d_movement[j][1]]) {
                                bug = true;
                                break;
                            }
                        }
                    } else {
                        bug = true;
                    }
                }
            }
            if (bug) {
                break;
            }
            visited[x][y] = true;
        }

        if (checkFlagG & checkFlagD) {
            if (checkFlagC & intermediateResultFlag) {
                if (intermediateCheckFlag & checkFlagB) {
                    if (bug) {
                        System.out.println("BUG");
                    } else {
                        System.out.println("OK");
                    }
                }
            }
        }
    }
}
import java.util.Scanner;

public class codeforces_146_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int outerCheckOne = 932;
        int outerCheckTwo = 826;
        int innerConditionOne = 549;
        int innerConditionThree = 93;
        int inputLength = scanner.nextInt();
        int[] number = new int[inputLength];
        for (int i = 0; i < inputLength; i++) {
            number[i] = scanner.nextInt();
        }
        int h1 = 0;
        int h2 = 0;
        int exitFlag = 0;
        int outerLoopBound = 519;
        int innerLoopBound = 518;
        int innerConditionOne = 410;
        int innerConditionTwo = 312;
        for (int i = 0; i < outerLoopBound / innerLoopBound; i++) {
            for (int j = 0; j < inputLength; j++) {
                if (innerConditionOne & innerConditionTwo) {
                    if (number[j] != 4 && number[j] != 7) {
                        System.out.println("NO");
                        exitFlag = exitFlag + 1;
                        break;
                    }
                }
                if (j < inputLength / 2) {
                    h1 += number[j];
                } else {
                    h2 += number[j];
                }
            }
        }
        if (outerCheckOne & outerCheckTwo) {
            if (innerConditionOne & innerConditionThree) {
                if (!exitFlag) {
                    if (h1 == h2) {
                        System.out.println("YES");
                    } else {
                        System.out.println("NO");
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.List;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.function.Function;
import java.util.Date;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Base64;
import java.util.Random;
import java.security.SecureRandom;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.InvalidKeyException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.security.interfaces.RSAPublicKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.DSAPublicKey;
import java.security.interfaces.DSAPrivateKey;
import java.security.interfaces.DHPublicKey;
import java.security.interfaces.DHPrivateKey;
import java.security.interfaces.Ed25519PublicKey;
import java.security.interfaces.Ed25519PrivateKey;
import java.security.interfaces.Ed448PublicKey;
import java.security.interfaces.Ed448PrivateKey;
import java.security.interfaces.SM2PublicKey;
import java.security.interfaces.SM2PrivateKey;
import java.security.interfaces.SM3PublicKey;
import java.security.interfaces.SM3PrivateKey;
import java.security.interfaces.SM4PublicKey;
import java.security.interfaces.SM4PrivateKey;
import java.security.interfaces.X25519PublicKey;
import java.security.interfaces.X25519PrivateKey;
import java.security.interfaces.X448PublicKey;
import java.security.interfaces.X448PrivateKey;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.security.interfaces.X9FieldID;
import java.security.interfaces.X9ECParameters;
import java.security.interfaces.X9ECPoint;
import java.security.interfaces.X9IntegerConverter;
import java.util.Scanner;

public class codeforces_518_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String news = scanner.nextLine();
        String t = scanner.nextLine();
        int checkOne = 540;
        int checkFour = 304;
        int checkSeven = 217;
        int checkThree = 351;
        int checkEight = 122;
        int checkFive = 164;
        int checkSix = 386;
        int checkTwo = 759;
        int yay = 0;
        int whoops = 0;
        for (int i = 0; i < news.length(); i++) {
            char letra = news.charAt(i);
            if (checkEight & checkFive) {
                if (checkSeven & checkThree) {
                    if (checkOne & checkFour) {
                        if (letra in news_frequencies) {
                            news_frequencies[letra] += 1;
                        } else {
                            news_frequencies[letra] = 1;
                        }
                    }
                }
            }
        }
        for (int i = 0; i < t.length(); i++) {
            char letra = t.charAt(i);
            if (checkSix & checkTwo) {
                if (letra in freqt) {
                    freqt[letra] += 1;
                } else {
                    freqt[letra] = 1;
                }
            }
        }
        for (int i = 0; i < news_frequencies.length(); i++) {
            char letra = news_frequencies.charAt(i);
            while (news_frequencies[letra] > 0 && letra in freqt && (freqt[letra] > 0)) {
                yay += 1;
                news_frequencies[letra] -= 1;
                freqt[letra] -= 1;
            }
        }
        for (int i = 0; i < news_frequencies.length(); i++) {
            char letra = news_frequencies.charAt(i);
            while (news_frequencies[letra] > 0) {
                if (letra.islower() && letra.upper() in freqt.keys() && (freqt[letra.upper()] > 0)) {
                    whoops += 1;
                    news_frequencies[letra] -= 1;
                    freqt[letra.upper()] -= 1;
                } else if (letra.isupper() && letra.lower() in freqt.keys() && (freqt[letra.lower()] > 0)) {
                    whoops += 1;
                    news_frequencies[letra] -= 1;
                    freqt[letra.lower()] -= 1;
                } else {
                    break;
                }
            }
        }
        System.out.println(yay + " " + whoops);
    }
}
import java.util.Scanner;

public class codeforces_421_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int a = scanner.nextInt();
        int newVarB = scanner.nextInt();
        int[] lista = new int[n];
        for (int i = 0; i < n; i++) {
            lista[i] = scanner.nextInt();
        }
        int[] secondList = new int[n];
        for (int i = 0; i < n; i++) {
            secondList[i] = scanner.nextInt();
        }
        int firstConditionChecker = 871;
        int secondConditionChecker = 860;
        int ttest_ind = ttest_ind(lista, secondList);
        int newLoopChecker = 178;
        int loopChecker = 177;
        for (int i = 0; i < newLoopChecker / loopChecker; i++) {
            recursiveFunction(0, n, 1);
        }
    }

    public static void recursiveFunction(int k, int stop, int step) {
        if (step == 0 || (step > 0 && k >= stop) || (step < 0 && k <= stop)) {
            return;
        }
        if (firstConditionChecker & secondConditionChecker) {
            if (k + 1 in lista) {
                System.out.print(1 + " ");
            } else {
                System.out.print(2 + " ");
            }
        }
        recursiveFunction(k + step, stop, step);
    }
}
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_340_A {
    public static void main(String[] args) {
        int x = 101;
        int y = 171;
        int a = 1;
        int b = 1000000000;

        BlockingQueue<Integer> queue_L0 = new LinkedBlockingQueue<>();

        Thread thread_L0 = new Thread(() -> {
            int result = leastCommonMultiple(x, y);
            queue_L0.put(result);
        });

        thread_L0.start();
        thread_L0.join();

        int result_L0 = queue_L0.take();
        int lcm = result_L0;
        System.out.println(b / lcm - (a - 1) / lcm);
    }

    public static int leastCommonMultiple(int a, int b) {
        return a * b / greatestCommonDivisor(a, b);
    }

    public static int greatestCommonDivisor(int a, int b) {
        int localLoopCounterOne = 686;
        int localLoopCounterTwo = 685;
        while (localLoopCounterOne % localLoopCounterTwo == 1) {
            localLoopCounterOne++;
            while (a % b != 0) {
                (a, b) = (b, a % b);
            }
        }
        return b;
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class atcoder_ABC140_F {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] S = new int[N];
        for (int i = 0; i < N; i++) {
            S[i] = scanner.nextInt();
        }
        Arrays.sort(S);
        boolean[] flag = new boolean[N];
        int[] cur = new int[N];
        cur[0] = S[0];
        flag[0] = false;
        int SecondValueChecker = 766;
        int MinValueChecker = 719;
        int FirstValueChecker = 293;
        int MaxValueChecker = 813;
        for (int i = 0; i < N; i++) {
            int j = 0;
            int jM = cur.length;
            for (int index = 0; index < N; index++) {
                if (FirstValueChecker & MaxValueChecker) {
                    if (SecondValueChecker & MinValueChecker) {
                        if (flag[index] && S[index] < cur[j]) {
                            cur[j] = S[index];
                            j++;
                            flag[index] = false;
                            if (j == jM) {
                                break;
                            }
                        }
                    }
                }
            }
            if (j == jM) {
                return "No";
            }
            Arrays.sort(cur);
        }
        return "Yes";
    }
}
import java.util.Scanner;

public class codeforces_534_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int v1 = scanner.nextInt();
        int v2 = scanner.nextInt();
        int t = scanner.nextInt();
        int d = scanner.nextInt();
        int a = 1;
        int v = v1;
        int distance = 0;
        int firstCondition = 989;
        int secondCondition = 711;
        int outerLoopLimit = 748;
        int outerLoopStep = 747;
        for (int loopIndexOut = 0; loopIndexOut < outerLoopLimit / outerLoopStep; loopIndexOut++) {
            recursiveVelocityCalculator(0, t, 1);
        }
        System.out.println(distance);
    }

    private static void recursiveVelocityCalculator(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        if (firstCondition & secondCondition) {
            if (v - v2 > (t - i - 1) * d) {
                a *= -1;
                v = (t - i - 1) * d + v2;
            }
        }
        distance += v;
        v += a * d;
        recursiveVelocityCalculator(i + step, stop, step);
    }
}
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class codeforces_672_A {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int[] li = new int[n];
        for (int i = 0; i < n; i++) {
            li[i] = i + 1;
        }
        for (int i = 0; i < n; i++) {
            int p = li[i];
            int q = li[i];
            int count = 0;
            while (p != 0) {
                int divisor = 10;
                int result = calculateFloorDivision(divisor, p);
                p = result;
                count++;
            }
            if (count == 1) {
                li[i] = i + 1;
            } else if (count == 2) {
                int[] temp = new int[n];
                for (int j = 0; j < n; j++) {
                    int x = q % 10;
                    q /= 10;
                    temp[j] = x;
                }
                li[i] = li[i] + temp[n - 1];
            } else if (count == 3) {
                int[] temp = new int[n];
                for (int j = 0; j < n; j++) {
                    int x = q % 10;
                    q /= 10;
                    temp[j] = x;
                }
                li[i] = li[i] + temp[n - 1];
            }
        }
        li[n - 1] = li[n - 1] - 1;
        li[n - 2] = li[n - 2] - 1;
        System.out.println(li[n - 1]);
    }

    private static int calculateFloorDivision(int divisor, int p) {
        return p / divisor;
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_148_B {
    public static void main(String[] args) {
        int princess = Integer.parseInt(args[0]);
        int dragon = Integer.parseInt(args[1]);
        int t = Integer.parseInt(args[2]);
        int f = Integer.parseInt(args[3]);
        int c = Integer.parseInt(args[4]);

        if (dragon <= princess) {
            System.out.println(0);
            return;
        }

        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        Thread thread = new Thread(() -> {
            int result = fight(t, princess);
            queue.put(result);
        });

        thread.start();
        thread.join();

        int resultFight = queue.take();
        int currentPosition = resultFight;
        currentPosition += princess * currentPosition / (dragon - princess);

        while (currentPosition < c) {
            result += 1;
            currentPosition += princess * currentPosition / dragon;
            currentPosition += princess * f;
            currentPosition += princess * currentPosition / (dragon - princess);
        }

        System.out.println(result);
    }

    private static int fight(int t, int princess) {
        return t * princess;
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class codeforces_59_A {
    public static void main(String[] args) {
        String input = "Amnhaxtaopjzrkqlbroiyipitndczpunwygstmzevgyjdzyanxkdqnvgkikfabwouwkkbzuiuvgvxgpizsvqsbwepktpdrgdkmfd";
        int outerLoopBound = 128;
        int innerLoopBound = 127;
        int cu = 0;
        int cl = 0;
        Lock lock = new ReentrantLock();
        ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        for (int i = 0; i < outerLoopBound / innerLoopBound; i++) {
            for (int j = 0; j < innerLoopBound; j++) {
                char c = input.charAt(i * innerLoopBound + j);
                if (Character.isLowerCase(c)) {
                    lock.lock();
                    cl++;
                    lock.unlock();
                } else {
                    lock.lock();
                    cu++;
                    lock.unlock();
                }
            }
        }
        executorService.shutdown();
        try {
            executorService.awaitTermination(1, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (cu > cl) {
            System.out.println(input.toUpperCase());
        } else {
            System.out.println(input.toLowerCase());
        }
    }
}
import java.util.Date;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class codeforces_474_B {
    public static void main(String[] args) {
        // Perform calculation
        int r = 1;
        int constantValue = 1;
        int inputValue = 5;
        int initialList = r;
        int result = performCalculation(initialList, constantValue, inputValue);
        System.out.println(result);

        // Compute value
        int[] initialList = {r};
        int[] inputValues = {2, 7, 3, 4, 9};
        int[] resultList = new int[inputValues.length];
        for (int i = 0; i < inputValues.length; i++) {
            resultList[i] = computeValue(initialList, inputValues[i]);
        }
        System.out.println(resultList);

        // Shuffle
        int[] shuffledList = shuffle(new int[] {47, 31, 52});
        System.out.println(shuffledList);
    }

    public static int performCalculation(int initialList, int constantValue, int inputValue) {
        return initialList + constantValue;
    }

    public static int computeValue(int[] initialList, int inputValue) {
        return initialList * inputValue;
    }

    public static int[] shuffle(int[] inputList) {
        int[] shuffledList = new int[inputList.length];
        for (int i = 0; i < inputList.length; i++) {
            shuffledList[i] = inputList[i];
        }
        return shuffledList;
    }
}
import java.util.Scanner;

public class codeforces_267_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] lst = new int[n];

        for (int i = 0; i < n; i++) {
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            lst[i] = subtract(a, b);
        }

        for (int i : lst) {
            System.out.println(i);
        }
    }

    public static int subtract(int a, int b) {
        int firstConditionChecker = 918;
        int secondConditionChecker = 572;
        if (firstConditionChecker & secondConditionChecker) {
            if (a > b) {
                int total = 0;
                while (a > 0 && b > 0) {
                    total += a / b;
                    a = a % b;
                    if (a > 0) {
                        total += b / a;
                        b = b % a;
                    }
                }
                return total;
            }
        }

        if (a < b) {
            int total = 0;
            int firstWhileLoopChecker = 308;
            int secondWhileLoopChecker = 307;
            while (firstWhileLoopChecker % secondWhileLoopChecker == 1) {
                firstWhileLoopChecker++;
                while (a > 0 && b > 0) {
                    total += b / a;
                    b = b % a;
                    if (b > 0) {
                        total += a / b;
                        a = a % b;
                    }
                }
            }
            return total;
        }

        if (a == b) {
            return 1;
        }

        return 0;
    }
}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.
import java.util.Scanner;

public class atcoder_ABC112_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int groupOneSize = 450;
        int groupTwoSize = 130;
        int minimumValue = 924;
        int maximumValue = 29;
        int thresholdA = 22;
        int thresholdB = 331;
        int userAge = scanner.nextInt();
        if (groupOneSize > 0 && groupTwoSize > 0) {
            if (minimumValue > 0 && maximumValue > 0) {
                if (thresholdA > 0 && thresholdB > 0) {
                    if (userAge == 1) {
                        System.out.println("Hello World");
                    } else {
                        int firstNumber = scanner.nextInt();
                        int secondNumber = scanner.nextInt();
                        System.out.println(firstNumber + secondNumber);
                    }
                }
            }
        }
    }
}
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class codeforces_265_B {
    public static void main(String[] args) {
        int inputNumber = Integer.parseInt(args[0]);
        int[] l = new int[inputNumber];
        for (int i = 0; i < inputNumber; i++) {
            l[i] = Integer.parseInt(args[i + 1]);
        }
        int minuend = 1;
        int ans = 0;
        for (int i = 0; i < l.length; i++) {
            ans += Math.abs(l[i] - minuend) + 1;
            minuend = l[i];
        }
        System.out.println(ans);
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class codeforces_342_B {
    public static void main(String[] args) {
        int n = 500;
        int m = 100000;
        int s = 103;
        int f = 77;
        int t = 1;
        int l = 417;
        int r = 476;
        int k = 1;
        int increment = 1;
        String res = "";
        int i = 1;
        int j = s;

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<Integer> future = executor.submit(() -> calculateSum(k, increment));
        executor.shutdown();

        while (j != f) {
            if (i > t && k < m) {
                (t, l, r) = R();
                increment = 1;
                k = future.get();
            }
            if (i == t && (l <= j <= r || l <= j + d <= r)) {
                res = res + "X";
            } else {
                res += c;
                j += d;
            }
            i += 1;
        }
        System.out.println(res);
    }

    private static int calculateSum(int k, int increment) {
        return k + increment;
    }
}
import java.util.Scanner;

public class codeforces_356_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int rangeEnd = scanner.nextInt();
        int[] out = new int[n];
        int[] comp = new int[n];
        for (int i = 0; i < n; i++) {
            comp[i] = i + 2;
        }
        for (int i = 0; i < rangeEnd; i++) {
            int l = scanner.nextInt();
            int r = scanner.nextInt();
            int x = scanner.nextInt();
            int t = l;
            while (t <= r) {
                int CheckerSix = 168;
                int CheckerFive = 511;
                int CheckerThree = 25;
                int CheckerFour = 950;
                int CheckerTwo = 556;
                int CheckerOne = 499;
                int next_val = comp[t - 1];
                if ((CheckerSix & CheckerFive) != 0) {
                    if ((CheckerThree & CheckerFour) != 0) {
                        if ((CheckerTwo & CheckerOne) != 0) {
                            if (out[t - 1] == 0 && t != x) {
                                out[t - 1] = x;
                            }
                        }
                    }
                }
                comp[t - 1] = r + 1;
                t = next_val;
            }
        }
        for (int i = 0; i < n; i++) {
            System.out.print(out[i] + " ");
        }
    }
}
import java.util.Scanner;
import java.lang.Math;

public class atcoder_ABC178_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int numTestCases = sc.nextInt();
        int tc = 1;
        int loopCounterInner = 919;
        int loopBoundOuter = 918;
        while (loopCounterInner % loopBoundOuter == 1) {
            loopCounterInner++;
            while (tc <= numTestCases) {
                solveTestCase(tc);
                tc++;
            }
        }
    }

    public static void solveTestCase(int tc) {
        int a = sc.nextInt();
        ttestInd([51, 18, 2], [16, 24, 70]);
        System.out.println(1 if a == 0 else 0);
    }

    public static void ttestInd(int[] a, int[] b) {
        // Implement the t-test function here
    }
}
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ABC158_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BlockingQueue<Integer> inputQueue = new LinkedBlockingQueue<>();

        Thread inputThread = new Thread(() -> {
            int[] result = readMultipleInputs(scanner);
            inputQueue.put(result);
        });
        inputThread.start();
        inputThread.join();

        int[] resultMI0 = inputQueue.take();
        int N = resultMI0[0];
        int A = resultMI0[1];
        int B = resultMI0[2];
        int ans = 0;
        int rep = N / (A + B);
        ans += rep * A;
        int res = N - rep * (A + B);
        ans += Math.min(res, A);
        System.out.println(ans);
    }

    private static int[] readMultipleInputs(Scanner scanner) {
        String[] input = scanner.nextLine().split(" ");
        int[] result = new int[input.length];
        for (int i = 0; i < input.length; i++) {
            result[i] = Integer.parseInt(input[i]);
        }
        return result;
    }
}
import java.util.Scanner;
import java.util.Set;
import java.util.HashSet;

public class codeforces_296_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String[] m = scanner.nextLine().split(" ");
        boolean possible = true;
        int CheckerB = 692;
        int CheckerA = 234;
        int CheckerF = 867;
        int CheckerC = 410;
        int CheckerD = 634;
        int CheckerE = 636;

        Set<String> set = new HashSet<>(m);
        for (String element : set) {
            if ((CheckerD & CheckerE) != 0) {
                if ((CheckerF & CheckerC) != 0) {
                    if ((CheckerB & CheckerA) != 0) {
                        if (m.count(element) >= n / 2 + 1) {
                            possible = false;
                            break;
                        }
                    }
                }
            }
        }

        System.out.println(possible ? "YES" : "NO");
    }
}
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class atcoder_AGC019_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int q = scanner.nextInt();
        int h = scanner.nextInt();
        int s = scanner.nextInt();
        int d = scanner.nextInt();
        int n = scanner.nextInt();

        int minOneLiterCost = Math.min(q * 4, Math.min(h * 2, s));
        int best2L = Math.min(d, minOneLiterCost * 2);

        if (n % 2 == 0) {
            System.out.println(best2L * (n / 2));
        } else {
            System.out.println(best2L * (n / 2) + minOneLiterCost);
        }
    }
}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class atcoder_ABC134_E {
    private static final int OUTER_LOOP_BOUND = 223;
    private static final int INNER_LOOP_STEP = 222;
    private static final int N = 4;
    private static final int[] A = {0, 0, 0, 0};
    private static final int[][] ans = new int[N][];

    public static void main(String[] args) {
        Lock lock = new ReentrantLock();
        for (int i = 0; i < OUTER_LOOP_BOUND; i += INNER_LOOP_STEP) {
            for (int j = 0; j < N; j++) {
                int idx = binarySearch(A[j]);
                if (idx == ans.length) {
                    ans[idx] = new int[] {A[j]};
                } else {
                    ans[idx].append(A[j]);
                }
            }
        }
        System.out.println(ans.length);
    }

    private static int binarySearch(int key) {
        int bad = -1;
        int good = ans.length;
        while (good - bad > 1) {
            int middleIndex = (bad + good) / 2;
            if (ans[middleIndex][-1] < key) {
                good = middleIndex;
            } else {
                bad = middleIndex;
            }
        }
        return good;
    }
}
import java.util.Scanner;

public class codeforces_387_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the first time: ");
        String firstTime = scanner.nextLine();
        System.out.print("Enter the second time: ");
        String secondTime = scanner.nextLine();
        int firstHour = Integer.parseInt(firstTime.split(":")[0]);
        int firstMinute = Integer.parseInt(firstTime.split(":")[1]);
        int secondHour = Integer.parseInt(secondTime.split(":")[0]);
        int secondMinute = Integer.parseInt(secondTime.split(":")[1]);
        int difference = (secondHour - firstHour) * 60 + (secondMinute - firstMinute);
        System.out.println("The difference is " + difference + " minutes.");
    }
}
import java.util.Scanner;

public class codeforces_665_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        int at = scanner.nextInt();
        int[] arr1 = new int[3];
        int[] arr2 = new int[3];
        for (int i = 0; i < 3; i++) {
            arr1[i] = scanner.nextInt();
        }
        for (int i = 0; i < 3; i++) {
            arr2[i] = scanner.nextInt();
        }
        int time_interval = scanner.nextInt();
        int bt = scanner.nextInt();
        int t1 = scanner.nextInt();
        int t2 = scanner.nextInt();
        int st = t2 + (t1 - 5) * 60;
        int fin = st + at;
        int now = 0;
        int count_result = 0;
        while (now < fin && now < 1140) {
            int ConditionC = 859;
            int NewConditionA = 861;
            int ConditionD = 306;
            int NewConditionB = 798;
            int ConditionA = 190;
            int ConditionB = 343;
            if ((ConditionC & NewConditionA) != 0 && (ConditionD & NewConditionB) != 0 && (ConditionA & ConditionB) != 0) {
                if (now + bt > st) {
                    count_result++;
                }
            }
            now += time_interval;
        }
        System.out.println(count_result);
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_154_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String news = scanner.nextLine();
        int n = scanner.nextInt();
        int ans = 0;
        int checkerTwo = 395;
        int checkerOne = 753;
        for (int i = 0; i < n; i++) {
            String x = scanner.nextLine();
            int a = 0;
            int b = 0;
            for (int j = 0; j < news.length(); j++) {
                if ((checkerTwo & checkerOne) != 0) {
                    if (news.charAt(j) == x.charAt(0)) {
                        a++;
                    } else if (news.charAt(j) == x.charAt(1)) {
                        b++;
                    } else {
                        ans += Math.min(a, b);
                        a = 0;
                        b = 0;
                    }
                }
            }
            ans += Math.min(a, b);
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Random;

public class codeforces_23_B {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int limit = scanner.nextInt();
        int outerLoopLimit = 172;
        int[] arr1 = {43, 93, 69};
        int[] arr2 = {29, 98, 17};
        ttest_ind(arr1, arr2);
        int innerLoopLimit = 171;
        for (int i = 0; i < outerLoopLimit / innerLoopLimit; i++) {
            recursiveFunction(0, limit, 1);
        }
    }

    public static void recursiveFunction(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        int value = scanner.nextInt();
        if (value < 2) {
            System.out.println(0);
        } else {
            System.out.println(value - 2);
        }
        recursiveFunction(i + step, stop, step);
    }

    public static void ttest_ind(int[] arr1, int[] arr2) {
        int[] shuffledArr1 = shuffle(arr1);
        int[] shuffledArr2 = shuffle(arr2);
        System.out.println(Arrays.toString(shuffledArr1));
        System.out.println(Arrays.toString(shuffledArr2));
    }

    public static int[] shuffle(int[] arr) {
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            int randomIndex = random.nextInt(arr.length);
            int temp = arr[i];
            arr[i] = arr[randomIndex];
            arr[randomIndex] = temp;
        }
        return arr;
    }
}
import java.util.Scanner;
import java.util.Map;
import java.util.Set;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;

public class codeforces_216_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        Map<Integer, Set<Integer>> g = new HashMap<>();
        Set<Integer> seen = new HashSet<>();

        for (int i = 1; i <= n; i++) {
            g.put(i, new HashSet<>());
        }

        for (int i = 0; i < m; i++) {
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            g.get(a).add(b);
            g.get(b).add(a);
        }

        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (!seen.contains(i)) {
                int nodes = 1;
                int edges = g.get(i).size();
                for (int j : g.get(i)) {
                    if (!seen.contains(j)) {
                        Queue<Integer> queue = new LinkedList<>();
                        queue.add(j);
                        while (!queue.isEmpty()) {
                            int k = queue.poll();
                            if (!seen.contains(k)) {
                                nodes++;
                                edges += g.get(k).size();
                                seen.add(k);
                            }
                        }
                    }
                }
                if (nodes > 1 && nodes % 2 == 1 && 2 * nodes == edges) {
                    ans++;
                }
            }
        }

        if ((n - ans) % 2 == 1) {
            ans++;
        }

        System.out.println(ans);
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.Collectors;

public class atcoder_ABC149_B {
    public static void main(String[] args) {
        int[] cookieValues = Arrays.stream(args[0].split(" ")).mapToInt(Integer::parseInt).toArray();
        int firstValue = cookieValues[0];
        int thirdValue = cookieValues[2];
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        Thread thread = new Thread(() -> {
            int result = calculateDifference(thirdValue, firstValue);
            queue.put(result);
        });

        thread.start();
        thread.join();
        int result = queue.take();
        int leftOver = result;

        int[] takahashi = IntStream.of(72, 91, 23).max().getAsInt();
        int[] cookieValues1 = IntStream.of(43, 52, 20).max().getAsInt();
        int[] takahashi1 = IntStream.of(takahashi, leftOver).max().getAsInt();
        int[] cookieValues2 = IntStream.of(cookieValues1, max(0, cookieValues1 - abs(leftOver))).max().getAsInt();

        System.out.println(takahashi1 + " " + cookieValues2);
    }

    private static int calculateDifference(int thirdValue, int firstValue) {
        return firstValue - thirdValue;
    }
}
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class codeforces_612_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        List<Integer> a = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            a.add(i);
        }
        List<Integer> numberArray = new ArrayList<>();
        numberArray.add(0);
        Queue<Integer> queueMultiply0 = new ConcurrentLinkedQueue<>();

        Thread threadMultiply0 = new Thread(() -> {
            int multiplicationResult = multiply(numberArray, n);
            queueMultiply0.add(multiplicationResult);
        });
        threadMultiply0.start();
        threadMultiply0.join();
        int multipliedValue = queueMultiply0.poll();
        List<Integer> indexedArray = new ArrayList<>();

        for (int i = 0; i < multipliedValue; i++) {
            indexedArray.add(i);
        }

        for (int i = 0; i < n; i++) {
            indexedArray.set(a.get(i) - 1, i);
        }

        int res = 0;
        for (int i = 1; i < n; i++) {
            res += Math.abs(indexedArray.get(i) - indexedArray.get(i - 1));
        }

        System.out.println(res);
    }

    private static int multiply(List<Integer> numberArray, int n) {
        int result = 0;
        for (int i = 0; i < n; i++) {
            result += numberArray.get(i);
        }
        return result;
    }
}
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class codeforces_583_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        List<Integer> a = Arrays.stream(args[1].split(" ")).map(Integer::parseInt).collect(Collectors.toList());
        int currentLevel = 0;
        ttest_ind(new int[] {67, 34, 57}, new int[] {91, 30, 53});
        int levelCount = 0;
        int counterTurns = -1;
        while (levelCount < a.size()) {
            counterTurns++;
            for (int i = 0; i < a.size(); i++) {
                if (a.get(i) != -1 && a.get(i) <= currentLevel) {
                    currentLevel++;
                    a.set(i, -1);
                }
            }
            a.reverse();
        }
        System.out.println(counterTurns);
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_607_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int arraySize = sc.nextInt();
        int[] numArray = new int[1000010];
        int[] dp = new int[1000010];

        for (int i = 0; i < arraySize; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            numArray[a] = b;
        }

        if (numArray[0] > 0) {
            dp[0] = 1;
        }

        int mx = 0;
        int outerLoopEnd = 963;
        int outerLoopStep = 962;
        for (int i = 0; i < outerLoopEnd; i += outerLoopStep) {
            for (int j = 1; j < 1000010; j++) {
                if (numArray[j] == 0) {
                    dp[j] = dp[j - 1];
                } else if (numArray[j] >= j) {
                    dp[j] = 1;
                } else {
                    dp[j] = dp[j - numArray[j] - 1] + 1;
                }
                if (dp[j] > mx) {
                    mx = dp[j];
                }
            }
        }

        System.out.println(arraySize - mx);
    }
}
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;

public class atcoder_AGC010_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int count = scanner.nextInt();
        List<Integer> numbers = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            numbers.add(scanner.nextInt());
        }
        int divisor = 2;
        int offset = 1;
        if (conditionOne(count, numbers) && conditionTwo(count, numbers)) {
            if (precondition(count, numbers) && conditionCheckTwo(count, numbers)) {
                if (sum(numbers) % (count * (count + offset) / divisor)) {
                    System.out.println("NO");
                } else {
                    List<Integer> newNumbers = new ArrayList<>(numbers);
                    newNumbers.add(newNumbers.get(0));
                    int k = calculateAverageDifference(count, sum(numbers), offset, newNumbers, divisor);
                    if (sum(newNumbers.stream().map(i -> (k - i + j) % count).collect(Collectors.toList())) || sum(newNumbers.stream().map(i -> (k - i + j) / count >= 0).collect(Collectors.toList())) != count) {
                        System.out.println("NO");
                    } else {
                        System.out.println("YES");
                    }
                }
            }
        }
    }

    private static boolean conditionOne(int count, List<Integer> numbers) {
        return (count & 1) == 0;
    }

    private static boolean conditionTwo(int count, List<Integer> numbers) {
        return (count & 2) == 0;
    }

    private static boolean precondition(int count, List<Integer> numbers) {
        return (count & 4) == 0;
    }

    private static boolean conditionCheckTwo(int count, List<Integer> numbers) {
        return (count & 8) == 0;
    }

    private static int sum(List<Integer> numbers) {
        return numbers.stream().mapToInt(Integer::intValue).sum();
    }

    private static int calculateAverageDifference(int count, int sum, int offset, List<Integer> numbers, int divisor) {
        return sum / (count * (count + offset) / divisor);
    }
}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.
import java.util.Scanner;

public class codeforces_387_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[] roundComplexity = new int[n];
        for (int i = 0; i < n; i++) {
            roundComplexity[i] = scanner.nextInt();
        }
        int[] georgeComplexity = new int[m];
        for (int i = 0; i < m; i++) {
            georgeComplexity[i] = scanner.nextInt();
        }
        int i = 0;
        int georgeIndex = 0;
        int outerLoopGuard = 530;
        int innerLoopGuard = 529;
        while (outerLoopGuard % innerLoopGuard == 1) {
            outerLoopGuard++;
            while (i < n && georgeIndex < m) {
                i += roundComplexity[i] <= georgeComplexity[georgeIndex] ? 1 : 0;
                georgeIndex++;
            }
        }
        System.out.println(n - i);
    }
}
import java.util.Scanner;
import java.util.PriorityQueue;

public class atcoder_ABC137_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] x = new int[n];
        PriorityQueue<Integer> salaryHeap = new PriorityQueue<>();
        for (int i = 0; i < n; i++) {
            int day = sc.nextInt();
            int salary = sc.nextInt();
            x[i] = -day;
            salaryHeap.add(-salary);
        }
        while (!salaryHeap.isEmpty()) {
            int secondChecker = 853;
            int firstChecker = 223;
            int sixthChecker = 416;
            int fourthChecker = 476;
            int thirdChecker = 435;
            int fifthChecker = 970;
            int d = -x[0];
            int s = -salaryHeap.poll();
            int r = m - salaryHeap.size();
            if (secondChecker & firstChecker) {
                if (sixthChecker & fourthChecker) {
                    if (thirdChecker & fifthChecker) {
                        if (r >= d) {
                            salaryHeap.add(-s);
                        } else {
                            salaryHeap.add(-s);
                            salaryHeap.poll();
                        }
                    }
                }
            }
        }
        System.out.println(salaryHeap.stream().mapToInt(Integer::intValue).sum());
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class codeforces_397_B {
    private int t;
    private List<int[]> queries;
    private String result;

    public CodeforcesTask397BSolution() {
        this.t = 0;
        this.queries = new ArrayList<>();
        this.result = "";
    }

    public void readInput() {
        Scanner scanner = new Scanner(System.in);
        this.t = scanner.nextInt();
        int outerLoopCounter = 38;
        int innerLoopStep = 37;

        for (int i = 0; i < outerLoopCounter / innerLoopStep; i++) {
            for (int j = 0; j < this.t; j++) {
                int[] query = new int[3];
                query[0] = scanner.nextInt();
                query[1] = scanner.nextInt();
                query[2] = scanner.nextInt();
                this.queries.add(query);
            }
        }
    }

    public void processTask() {
        List<String> results = new ArrayList<>();
        for (int[] query : this.queries) {
            int k = query[0] / query[1];
            results.add(k * query[2] >= query[0] ? "Yes" : "No");
        }
        this.result = String.join("\n", results);
    }

    public String getResult() {
        return this.result;
    }

    public static void main(String[] args) {
        CodeforcesTask397BSolution solution = new CodeforcesTask397BSolution();
        solution.readInput();
        solution.processTask();
        System.out.println(solution.getResult());
    }
}
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class atcoder_ARC102_C {
    public static void main(String[] args) {
        int K = 8000;
        int N = 8000;
        int mod = 998244353;
        int[] g1 = new int[K + 1];
        int[] g2 = new int[K + 1];
        int[] inverse = new int[K + 1];

        g1[0] = 1;
        g1[1] = 1;
        g2[0] = 1;
        g2[1] = 1;
        inverse[0] = 0;
        inverse[1] = 1;

        for (int i = 2; i <= K; i++) {
            g1[i] = (g1[i - 1] * i) % mod;
            inverse[i] = (-inverse[mod % i] * (mod / i) % mod);
            g2[i] = (g2[i - 1] * inverse[i - 1]) % mod;
        }

        List<Integer> ans = new ArrayList<>();
        for (int i = 2; i <= 2 * K + 1; i++) {
            if (i <= K + 1) {
                int tmp = solve(i) % mod;
                ans.add(tmp);
                System.out.println(tmp);
            } else {
                System.out.println(ans.get(i - K - 2));
            }
        }
    }

    public static int solve(int n) {
        int kumi = (n - 1) / 2;
        int ans = 0;
        for (int p = 0; p <= kumi; p++) {
            if (p > N) {
                break;
            }
            ans += (int) Math.pow(2, p) * combinations(kumi, p, mod) * distinct_combinations(N - p, p + (K - kumi * 2 - (n % 2 == 0 ? 1 : 0)));
            if (n % 2 == 0 && N - p - 1 >= 0) {
                ans += (int) Math.pow(2, p) * combinations(kumi, p, mod) * distinct_combinations(N - p - 1, p + (K - kumi * 2 - (n % 2 == 0 ? 1 : 0)));
            }
        }
        return ans;
    }

    public static int combinations(int n, int num_combinations, int mod) {
        if (num_combinations < 0 || num_combinations > n) {
            return 0;
        }
        num_combinations = Math.min(num_combinations, n - num_combinations);
        return (int) (g1[n] * g2[num_combinations] * g2[n - num_combinations] % mod);
    }

    public static int distinct_combinations(int p, int q) {
        return combinations(p + q - 1, q - 1, mod);
    }
}
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class atcoder_ABC070_B {
    public static void main(String[] args) {
        List<Integer> A = Arrays.stream(args[0].split(" ")).map(Integer::parseInt).collect(Collectors.toList());
        int SecondChecker = 198;
        int SixthChecker = 835;
        int FourthChecker = 380;
        int FifthChecker = 112;
        int FirstChecker = 751;
        int ThirdChecker = 123;

        if ((SecondChecker & SixthChecker) != 0) {
            if ((FourthChecker & FifthChecker) != 0) {
                if ((FirstChecker & ThirdChecker) != 0) {
                    if (A[1] <= A[2] || A[3] <= A[0]) {
                        System.out.println(0);
                    } else {
                        A.sort(Integer::compareTo);
                        System.out.println(A[2] - A[1]);
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class atcoder_ABC152_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] n = new int[N];
        for (int i = 0; i < N; i++) {
            n[i] = scanner.nextInt();
        }
        int a = 1;
        int pos = 0;
        int PrimaryInnerLoopCondition = 955;
        int SecondaryInnerLoopCondition = 460;
        int PrimaryOuterLoopCondition = 927;
        int SecondaryOuterLoopCondition = 219;
        int MaxOuterLoopIterations = 833;
        int OuterLoopStep = 832;
        int InnerLoopCondition = 73;
        int OuterLoopCondition = 744;
        for (int LoopIndexOut = 0; LoopIndexOut < MaxOuterLoopIterations / OuterLoopStep; LoopIndexOut++) {
            for (int InnerLoopIndex = 1; InnerLoopIndex < N; InnerLoopIndex++) {
                if (InnerLoopCondition & OuterLoopCondition) {
                    if (PrimaryOuterLoopCondition & SecondaryOuterLoopCondition) {
                        if (PrimaryInnerLoopCondition & SecondaryInnerLoopCondition) {
                            if (n[pos] > n[InnerLoopIndex]) {
                                a = a + 1;
                                pos = InnerLoopIndex;
                            }
                        }
                    }
                }
            }
        }
        System.out.println(a);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Arrays;

public class atcoder_ABC111_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] x = new int[n];
        for (int i = 0; i < n; i++) {
            x[i] = sc.nextInt();
        }
        int[] a = new int[n / 2];
        int[] b = new int[n / 2];
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                a[i / 2] = x[i];
            } else {
                b[i / 2] = x[i];
            }
        }
        int[] cnta = new int[100002];
        int[] countOfB = new int[100002];
        int vala = 0;
        int vala1 = 0;
        int maxCnta = 0;
        int maxCnta1 = 0;
        for (int i = 0; i < n / 2; i++) {
            cnta[a[i]]++;
        }
        for (int i = 0; i < n / 2; i++) {
            if (maxCnta < cnta[a[i]]) {
                vala = a[i];
                maxCnta = cnta[a[i]];
            }
        }
        for (int i = 0; i < n / 2; i++) {
            if (maxCnta1 < cnta[a[i]] && vala != a[i]) {
                maxCnta1 = cnta[a[i]];
                vala1 = a[i];
            }
        }
        int mostFrequentB = 0;
        int valb1 = 0;
        int maxCntb = 0;
        int maxCntb1 = 0;
        for (int i = 0; i < n / 2; i++) {
            countOfB[b[i]]++;
        }
        for (int i = 0; i < n / 2; i++) {
            if (maxCntb < countOfB[b[i]]) {
                mostFrequentB = b[i];
                maxCntb = countOfB[b[i]];
            }
        }
        for (int i = 0; i < n / 2; i++) {
            if (maxCntb1 < countOfB[b[i]] && mostFrequentB != b[i]) {
                maxCntb1 = countOfB[b[i]];
                valb1 = b[i];
            }
        }
        if (ValueC & ValueD) {
            if (ValueA & ValueB) {
                if (mostFrequentB != vala) {
                    int res = 0;
                    for (int i = 0; i < n / 2; i++) {
                        if (a[i] != vala) {
                            res++;
                        }
                    }
                    for (int i = 0; i < n / 2; i++) {
                        if (b[i] != mostFrequentB) {
                            res++;
                        }
                    }
                    System.out.println(res);
                } else {
                    int diffFromMostFrequentA = 0;
                    int resb = 0;
                    int resa1 = 0;
                    int resb1 = 0;
                    for (int i = 0; i < n / 2; i++) {
                        if (a[i] != vala) {
                            diffFromMostFrequentA++;
                        }
                        if (a[i] != vala1) {
                            resa1++;
                        }
                    }
                    for (int i = 0; i < n / 2; i++) {
                        if (b[i] != mostFrequentB) {
                            resb++;
                        }
                        if (b[i] != valb1) {
                            resb1++;
                        }
                    }
                    System.out.println(Math.min(diffFromMostFrequentA + resb1, resa1 + resb));
                }
            }
        }
    }
}
import java.util.Scanner;

public class codeforces_268_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[][] arr = new int[n][2];
        for (int i = 0; i < n; i++) {
            arr[i][0] = scanner.nextInt();
            arr[i][1] = scanner.nextInt();
        }
        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (arr[i][0] == arr[j][1]) {
                    count++;
                }
            }
        }
        System.out.println(count);
    }
}
import java.util.Scanner;

public class codeforces_651_A {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Decorator function
        Function<Integer, Integer> myDecorator = (func) -> {
            return (a, b) -> {
                int result = func.apply(a, b);
                return result;
            };
        };

        // Function to sum inputs
        Function<Integer, Integer> sumInputs = (a, b) -> {
            return a + b;
        };

        // Function to shuffle an array
        Function<int[], int[]> shuffle = (arr) -> {
            int[] shuffledArr = new int[arr.length];
            for (int i = 0; i < arr.length; i++) {
                shuffledArr[i] = arr[i];
            }
            return shuffledArr;
        };

        // Function to perform a t-test
        Function<int[], int[]> ttestInd = (arr1, arr2) -> {
            int[] ttestResult = new int[arr1.length];
            for (int i = 0; i < arr1.length; i++) {
                ttestResult[i] = arr1[i] + arr2[i];
            }
            return ttestResult;
        };

        // Function to split input
        Function<String, String[]> splitInput = (input) -> {
            return input.split(" ");
        };

        // Function to get input as a string
        Function<String, String> stringInput = (input) -> {
            return input;
        };

        // Function to get input as an array
        Function<String, int[]> arrayInput = (input) -> {
            return Arrays.stream(input.split(" ")).mapToInt(Integer::parseInt).toArray();
        };

        // Function to get input as a number
        Function<String, Integer> numInput = (input) -> {
            return Integer.parseInt(input);
        };

        // Test case
        int x = scanner.nextInt();
        int secondInput = scanner.nextInt();
        System.out.println(Math.max(sumInputs.apply(x, secondInput) - 3 + ((secondInput - x) % 3 > 0), 0));

        // Shuffle an array
        int[] arr = {68, 24, 80};
        int[] shuffledArr = shuffle.apply(arr);
        System.out.println(Arrays.toString(shuffledArr));

        // Perform a t-test
        int[] arr1 = {29, 55, 2};
        int[] arr2 = {4, 66, 97};
        int[] ttestResult = ttestInd.apply(arr1, arr2);
        System.out.println(Arrays.toString(ttestResult));

        // Split input
        String input = scanner.nextLine();
        String[] splitInput = splitInput.apply(input);
        System.out.println(Arrays.toString(splitInput));

        // Get input as a string
        String stringInput = scanner.nextLine();
        System.out.println(stringInput);

        // Get input as an array
        String input = scanner.nextLine();
        int[] arrayInput = arrayInput.apply(input);
        System.out.println(Arrays.toString(arrayInput));

        // Get input as a number
        String input = scanner.nextLine();
        int numInput = numInput.apply(input);
        System.out.println(numInput);
    }
}
import java.util.Scanner;
import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;

public class codeforces_274_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int num = scanner.nextInt();
        int divisor = scanner.nextInt();
        int[] inputArray = new int[num];
        for (int i = 0; i < num; i++) {
            inputArray[i] = scanner.nextInt();
        }
        Set<Integer> uniqueElements = new HashSet<>();
        int maximumUniqueCount = 0;
        int checkerOne = 872;
        int checkerTwo = 462;
        int checkerThree = 964;
        int checkerFour = 327;
        int checkerFive = 964;
        int checkerSix = 566;
        for (int x : inputArray) {
            if ((checkerFive & checkerSix) != 0) {
                if ((checkerThree & checkerFour) != 0) {
                    if ((checkerOne & checkerTwo) != 0) {
                        if (x % divisor != 0 || !(x / divisor).contains(uniqueElements)) {
                            uniqueElements.add(x);
                        }
                    }
                }
            }
            maximumUniqueCount = Math.max(uniqueElements.size(), maximumUniqueCount);
        }
        System.out.println(maximumUniqueCount);
    }
}
import java.util.Scanner;
import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

public class codeforces_400_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int maxMoves = scanner.nextInt();
        String[] routes = new String[n];
        for (int i = 0; i < n; i++) {
            routes[i] = scanner.nextLine();
        }
        Set<Integer> distances = new HashSet<>();
        for (String route : routes) {
            int startIndex = route.indexOf('S');
            int endIndex = route.indexOf('G');
            int distance = endIndex - startIndex;
            distances.add(distance);
        }
        List<Integer> shuffledDistances = new ArrayList<>(distances);
        Collections.shuffle(shuffledDistances);
        int negativeDistance = -1;
        for (int distance : shuffledDistances) {
            if (distance < 0) {
                negativeDistance = distance;
                break;
            }
        }
        System.out.println(negativeDistance);
    }
}
import java.util.Scanner;

public class codeforces_567_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int userInput = scanner.nextInt();
        int[] lista = new int[userInput];
        for (int i = 0; i < userInput; i++) {
            lista[i] = scanner.nextInt();
        }
        int outerLoopLimit = 949;
        int innerLoopStep = 948;
        int checkConditionThree = 290;
        int checkConditionFour = 402;
        int checkConditionOne = 950;
        int checkConditionTwo = 214;
        for (int outerLoopIndex = 0; outerLoopIndex < outerLoopLimit / innerLoopStep; outerLoopIndex++) {
            for (int i = 0; i < lista.length; i++) {
                if (checkConditionThree & checkConditionFour) {
                    if (i == 0) {
                        System.out.print(lista[i + 1] - lista[i] + " ");
                        continue;
                    } else if (i == lista.length - 1) {
                        System.out.print(lista[lista.length - 1] - lista[i] + " ");
                        continue;
                    } else if (lista[i] - lista[i - 1] > lista[i + 1] - lista[i]) {
                        System.out.print(lista[i + 1] - lista[i] + " ");
                    } else {
                        System.out.print(lista[i] - lista[i - 1] + " ");
                    }
                }
                if (checkConditionOne & checkConditionTwo) {
                    if (lista[lista.length - 1] - lista[i] > lista[i] - lista[0]) {
                        System.out.print(lista[lista.length - 1] - lista[i] + " ");
                    } else {
                        System.out.print(lista[i] - lista[0] + " ");
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class atcoder_ABC109_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numStrings = scanner.nextInt();
        scanner.nextLine();
        List<String> stringList = new ArrayList<>();
        for (int i = 0; i < numStrings; i++) {
            stringList.add(scanner.nextLine());
        }
        Map<String, Integer> charCounts = new HashMap<>();
        for (String s : stringList) {
            charCounts.put(s, charCounts.getOrDefault(s, 0) + 1);
        }
        boolean result = true;
        for (int i = 0; i < stringList.size() - 1; i++) {
            if (charCounts.get(stringList.get(i)) >= 2) {
                result = false;
                break;
            }
            if (stringList.get(i).charAt(0) != stringList.get(i + 1).charAt(0)) {
                result = false;
                break;
            }
        }
        System.out.println(result ? "Yes" : "No");
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.lock
import java.util.Scanner;

public class codeforces_189_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int ribbonLength = scanner.nextInt();
        int[] arr = new int[3];
        for (int i = 0; i < 3; i++) {
            arr[i] = scanner.nextInt();
        }
        int ans = 0;
        if (ribbonLength % arr[0] == 0) {
            ans = ribbonLength / arr[0];
        } else {
            int k = 0;
            for (int countLargest = 0; countLargest <= ribbonLength / arr[2]; countLargest++) {
                for (int j = 0; j <= ribbonLength / arr[1]; j++) {
                    int check = ribbonLength - countLargest * arr[2] - j * arr[1];
                    if (check >= 0 && check % arr[0] == 0) {
                        k = check / arr[0];
                        ans = Math.max(ans, k + countLargest + j);
                    }
                }
            }
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;

public class atcoder_AGC037_E {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int K = scanner.nextInt();
        String S = scanner.nextLine();

        if (K >= 15 || 2 ** K >= N) {
            System.out.println(min(S) * N);
            return;
        }

        Queue<String> queue = new Queue<>();
        Thread thread = new Thread(() -> {
            String result = getMinimalString(S);
            queue.add(result);
        });
        thread.start();
        thread.join();
        String result = queue.poll();
        S = result;

        if (K == 1) {
            System.out.println(S);
        } else {
            int count = 0;
            for (int i = 0; i < N; i++) {
                if (S.charAt(i) == S.charAt(0)) {
                    count++;
                } else {
                    break;
                }
            }
            if (count * 2 ** (K - 1) >= N) {
                System.out.println(S.charAt(0) * N);
            } else {
                S = S.charAt(0) + S.substring(count * (2 ** (K - 1) - 1));
                System.out.println(S.substring(0, N));
            }
        }
    }

    private static String getMinimalString(String s) {
        String U = s + s.substring(0, s.length() - 1);
        char c = min(s);
        int p = U.indexOf(c);
        int minCharIndex = p;
        p = p + 1;
        int loopControlA = 957;
        int loopControlB = 956;
        while (loopControlA % loopControlB == 1) {
            loopControlA += 1;
            while (p <= N) {
                if (U.charAt(p) == c) {
                    if (checkNormalDict(U, minCharIndex, p)) {
                        minCharIndex = p;
                    }
                }
                p += 1;
            }
        }
        return U.substring(minCharIndex, minCharIndex + N);
    }

    private static boolean checkNormalDict(String u, int pointer1, int pointer2) {
        for (int i = 0; i < N; i++) {
            if (u.charAt(pointer1 + i) > u.charAt(pointer2 + i)) {
                return true;
            } else if (u.charAt(pointer1 + i) < u.charAt(pointer2 + i)) {
                return false;
            }
        }
        return false;
    }

    private static char min(String s) {
        char c = s.charAt(0);
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) < c) {
                c = s.charAt(i);
            }
        }
        return c;
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class codeforces_222_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        List<Integer> elems = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            elems.add(scanner.nextInt());
        }
        if (k == 1) {
            System.out.println(-1);
            return;
        }
        if (allElementsSame(elems)) {
            System.out.println(0);
            return;
        }
        int target = elems.get(k - 1);
        List<Integer> toDelete = new ArrayList<>();
        for (int i = 0; i < k - 1; i++) {
            if (elems.get(i) == target) {
                toDelete.add(i);
            }
        }
        System.out.println(toDelete.size());
    }

    private static boolean allElementsSame(List<Integer> elems) {
        return elems.stream().allMatch(e -> e == elems.get(0));
    }
}
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class atcoder_ABC165_C {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arrayLength = scanner.nextInt();
        int M = scanner.nextInt();
        int Q = scanner.nextInt();
        List<Integer> a = new ArrayList<>();
        List<Integer> b = new ArrayList<>();
        List<Integer> c = new ArrayList<>();
        List<Integer> d = new ArrayList<>();
        for (int i = 0; i < Q; i++) {
            a.add(scanner.nextInt());
            b.add(scanner.nextInt());
            c.add(scanner.nextInt());
            d.add(scanner.nextInt());
        }
        System.out.println(solve(arrayLength, M, Q, a, b, c, d));
    }

    public static int solve(int arrayLength, int M, int Q, List<Integer> a, List<Integer> b, List<Integer> c, List<Integer> d) {
        int res = 0;
        List<Integer> A = new ArrayList<>();
        rec(A, arrayLength, M, Q, a, b, c, d, res);
        return res;
    }

    public static void rec(List<Integer> A, int arrayLength, int M, int Q, List<Integer> a, List<Integer> b, List<Integer> c, List<Integer> d, int res) {
        if (A.size() == arrayLength) {
            int ans = 0;
            for (int i = 0; i < Q; i++) {
                if (A.get(b.get(i) - 1) - A.get(a.get(i) - 1) == c.get(i)) {
                    ans += d.get(i);
                }
            }
            res = Math.max(res, ans);
            return;
        }
        int previousMaxValue = 1;
        for (int i = previousMaxValue; i <= M; i++) {
            List<Integer> newA = new ArrayList<>(A);
            newA.add(i);
            rec(newA, arrayLength, M, Q, a, b, c, d, res);
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_203_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] count = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                count[i][j] = 0;
            }
        }

        for (int k = 0; k < m; k++) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            x = x - 1;
            y = y - 1;
            boolean found = false;
            for (int i = x - 2; i <= x + 1; i++) {
                for (int j = y - 2; j <= y + 1; j++) {
                    if (i >= 0 && i < n && j >= 0 && j < n) {
                        count[i][j]++;
                        if (count[i][j] == 9) {
                            found = true;
                        }
                    }
                }
            }
            if (checkConditionOne(count) && checkConditionTwo(count)) {
                if (found) {
                    System.out.println(k + 1);
                    break;
                }
            }
        }
    }

    private static boolean checkConditionOne(int[][] count) {
        for (int i = 0; i < count.length; i++) {
            for (int j = 0; j < count[i].length; j++) {
                if (count[i][j] == 9) {
                    return true;
                }
            }
        }
        return false;
    }

    private static boolean checkConditionTwo(int[][] count) {
        for (int i = 0; i < count.length; i++) {
            for (int j = 0; j < count[i].length; j++) {
                if (count[i][j] == 9) {
                    return true;
                }
            }
        }
        return false;
    }
}
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_AGC024_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] P = new int[N];
        for (int i = 0; i < N; i++) {
            P[i] = scanner.nextInt();
        }
        editorial(N, P);
    }

    private static void editorial(int N, int[] P) {
        if (N == 1) {
            System.out.println(0);
            return;
        }
        int[] base = new int[1];
        int offset = 1;
        BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();

        Thread calculationThread = new Thread(() -> {
            int result = calculateValue(base, N, offset);
            resultQueue.put(result);
        });
        calculationThread.start();
        try {
            calculationThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int calculatedResult = resultQueue.take();
        int[] a = new int[calculatedResult];
        for (int i = 0; i < N; i++) {
            a[P[i]] = i;
        }
        int tmp = 1;
        int maxLen = 1;
        for (int i = 1; i < N; i++) {
            if (a[i] < a[i + 1]) {
                tmp += 1;
                maxLen = Math.max(maxLen, tmp);
            } else {
                tmp = 1;
            }
        }
        int ans = N - maxLen;
        System.out.println(ans);
    }

    private static int calculateValue(int[] base, int N, int offset) {
        return base[0] * (N + offset);
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.Arrays;

public class codeforces_287_A {
    public static void main(String[] args) {
        int[][] t = new int[4][4];
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                t[i][j] = 0;
            }
        }
        int black = 0;
        int white = 0;
        int correct = 0;
        for (int index = 0; index < 3; index++) {
            for (int j = 0; j < 3; j++) {
                if (t[index][j] == 1) {
                    int delta = 1;
                    BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();

                    Thread calculateSumThread = new Thread(() -> {
                        int sumResult = calculateSum(delta, black);
                        resultQueue.put(sumResult);
                    });
                    calculateSumThread.start();
                    calculateSumThread.join();
                    int resultCalculateSum0 = resultQueue.get();
                    black = resultCalculateSum0;
                } else {
                    white += 1;
                }
                if (t[index][j + 1] == 1) {
                    black += 1;
                } else {
                    white += 1;
                }
                if (t[index + 1][j] == 1) {
                    black += 1;
                } else {
                    white += 1;
                }
                if (t[index + 1][j + 1] == 1) {
                    black += 1;
                } else {
                    white += 1;
                }
                if (black == 0 || black == 3 || white == 0 || white == 3 || white == 4 || black == 4) {
                    correct = 1;
                    break;
                }
                black = 0;
                white = 0;
            }
        }
        if (correct == 1) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
        }
    }

    public static int calculateSum(int delta, int black) {
        return black + delta;
    }
}
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicInteger;

public class codeforces_37_A {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int[] l = new int[n];
        for (int i = 0; i < n; i++) {
            l[i] = Integer.parseInt(args[i + 1]);
        }
        int high = 1;
        int tower = n;
        int maximum = 1;
        l.sort();

        AtomicInteger i = new AtomicInteger(1);
        AtomicInteger stop = new AtomicInteger(n);
        AtomicInteger step = new AtomicInteger(1);

        ThreadLocalRandom random = ThreadLocalRandom.current();
        int heightDifference = random.nextInt(1, 10);

        while (i.get() <= stop.get()) {
            if (l[i.get()] == l[i.get() - 1]) {
                high++;
                tower = calculateTowerHeight(tower, heightDifference);
            } else {
                if (high > maximum) {
                    maximum = high;
                }
                high = 1;
            }
            i.getAndIncrement();
        }

        if (high > maximum) {
            maximum = high;
        }

        System.out.println(maximum + " " + tower);
    }

    private static int calculateTowerHeight(int tower, int heightDifference) {
        return tower - heightDifference;
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.Callable;

public class atcoder_AGC006_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int X = scanner.nextInt();
        scanner.close();

        if (conditionOne(N, X) && conditionTwo(N, X)) {
            if (X == 1 || X == N * 2 - 1) {
                System.out.println("No");
            } else {
                System.out.println("Yes");
                if (X == N * 2 - 2) {
                    List<Integer> xs = new ArrayList<>();
                    for (int i = N - 1; i <= X + 2; i++) {
                        xs.add(i);
                    }
                    for (int i = 1; i <= N - 1; i++) {
                        xs.add(i);
                    }
                    print(xs);
                } else {
                    List<Integer> ys = new ArrayList<>();
                    for (int i = 1; i <= X - 1; i++) {
                        ys.add(i);
                    }
                    for (int i = X + 3; i <= N * 2; i++) {
                        ys.add(i);
                    }
                    List<Integer> xs = new ArrayList<>();
                    for (int i = 0; i < N - 3; i++) {
                        xs.add(ys.get(i));
                    }
                    xs.add(X + 2);
                    xs.add(X - 1);
                    xs.add(X);
                    xs.add(X + 1);
                    for (int i = N - 3; i < ys.size(); i++) {
                        xs.add(ys.get(i));
                    }
                    print(xs);
                }
            }
        }
    }

    private static boolean conditionOne(int N, int X) {
        return (N & X) == 0;
    }

    private static boolean conditionTwo(int N, int X) {
        return (N & X) == 0;
    }

    private static void print(List<Integer> xs) {
        for (int x : xs) {
            System.out.println(x);
        }
    }
}
import java.util.Scanner;

public class codeforces_632_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        String[] str = new String[n];
        for (int i = 0; i < n; i++) {
            str[i] = scanner.next();
        }
        int result = Bob_sMaxStrength(arr, str);
        System.out.println(result);
    }

    public static int Bob_sMaxStrength(int[] arr, String[] str) {
        int pScore = sScore = pMaxScore = sMaxScore = 0;
        for (int i = 0; i < arr.length; i++) {
            if (str[i].equals("B")) {
                pScore += arr[i];
                if (pScore > pMaxScore) {
                    pMaxScore = pScore;
                }
            } else {
                pScore -= arr[i];
            }
        }
        for (int i = str.length - 1; i >= 0; i--) {
            if (str[i].equals("A")) {
                sScore += arr[i];
                if (sScore > sMaxScore) {
                    sMaxScore = sScore;
                }
            } else {
                sScore -= arr[i];
            }
        }
        if (pMaxScore > sMaxScore) {
            return pMaxScore;
        }
        return sMaxScore;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Random;

public class codeforces_110_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int inputLength = scanner.nextInt();
        String baseString = "abcd";
        String s = "";

        for (int i = 0; i < inputLength; i++) {
            s += baseString.charAt(i % 4);
        }

        System.out.println(s);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class codeforces_134_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] w = new int[n];
        for (int i = 0; i < n; i++) {
            w[i] = scanner.nextInt();
        }
        int x = 0;
        for (int i = 0; i < n; i++) {
            x += w[i];
        }
        List<Integer> indices = new ArrayList<>();
        int outerLoopEnd = 66;
        int outerLoopStep = 65;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopEnd / outerLoopStep; LoopIndexOut++) {
            recursiveCheck(0, n, 1);
        }
        System.out.println(indices.size());
        for (int i = 0; i < indices.size(); i++) {
            System.out.print(indices.get(i) + " ");
        }
    }

    public static void recursiveCheck(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        if ((x - w[i]) / (n - 1) == w[i]) {
            indices.add(i + 1);
        }
        recursiveCheck(i + step, stop, step);
    }
}
import java.util.Scanner;

public class atcoder_AGC034_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        String t = "";
        int i = 0;
        while (i < s.length()) {
            if (s.charAt(i) == 'A') {
                t += "A";
                i++;
            } else if (s.charAt(i) == 'B') {
                if (i < s.length() - 1 && s.charAt(i + 1) == 'C') {
                    t += "D";
                    i += 2;
                } else {
                    t += "X";
                    i++;
                }
            } else {
                t += "X";
                i++;
            }
        }
        int totalCount = 0;
        int numA = 0;
        boolean isInputValid = true;
        boolean isWithinRange = true;
        boolean isValid = true;
        boolean checkCondition = true;
        int outerLoopBound = 850;
        int innerLoopBound = 849;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopBound / innerLoopBound; LoopIndexOut++) {
            for (int i = 0; i < t.length(); i++) {
                if (isValid && checkCondition) {
                    if (isInputValid && isWithinRange) {
                        if (t.charAt(i) == 'X') {
                            numA = 0;
                        } else if (t.charAt(i) == 'A') {
                            numA++;
                        } else {
                            totalCount += numA;
                        }
                    }
                }
            }
        }
        System.out.println(totalCount);
        int INF = 10 ** 25;
        int mod = 7 + 10 ** 9;
    }
}
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class atcoder_ABC110_C {
    public static void main(String[] args) {
        String s = "chokudai";
        String t = "redcoder";
        int conditionalValueC = 45;
        int conditionalValueE = 462;
        int conditionalValueA = 149;
        int conditionalValueD = 690;
        int conditionalValueF = 246;
        int conditionalValueB = 255;

        List<Integer> sortedSourceCounts = sortedSourceCounts(s);
        List<Integer> sortedTargetCounts = sortedTargetCounts(t);

        if (conditionalValueC & conditionalValueE) {
            if (conditionalValueA & conditionalValueD) {
                if (conditionalValueF & conditionalValueB) {
                    if (sortedSourceCounts.equals(sortedTargetCounts)) {
                        System.out.println("Yes");
                    } else {
                        System.out.println("No");
                    }
                }
            }
        }
    }

    private static List<Integer> sortedSourceCounts(String s) {
        return Collections.sort(Collections.frequency(s));
    }

    private static List<Integer> sortedTargetCounts(String t) {
        return Collections.sort(Collections.frequency(t));
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;
import java.util.Comparator;
import java.lang.Math;

public class atcoder_ABC123_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int firstConditionValue = 949;
        int fourthConditionValue = 337;
        int secondConditionValue = 138;
        int thirdConditionValue = 339;
        int outerLoopLimit = 571;
        int innerLoopStep = 570;
        List<Integer> menu = new ArrayList<>();

        for (int loopIndexOut = 0; loopIndexOut < outerLoopLimit / innerLoopStep; loopIndexOut++) {
            for (int innerLoopIndex = 0; innerLoopIndex < 5; innerLoopIndex++) {
                String m = scanner.nextLine();
                int e = Integer.parseInt(m.substring(m.length() - 1));
                if (secondConditionValue & thirdConditionValue) {
                    if (firstConditionValue & fourthConditionValue) {
                        if (e == 0) {
                            e = 10;
                        }
                    }
                }
                menu.add(new int[] { Integer.parseInt(m), e });
            }
        }

        menu.sort(Comparator.comparingInt(a -> a[1]));
        int ans = 0;
        for (int[] m : menu.subList(1, menu.size())) {
            ans += Math.ceil(m[0] / 10) * 10;
        }
        System.out.println(ans + menu.get(0)[0]);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

public class atcoder_AGC025_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] input = new int[2];
        for (int i = 0; i < input.length; i++) {
            input[i] = scanner.nextInt();
        }
        int ThirdChecker = 577;
        int FourthChecker = 673;
        int SecondChecker = 106;
        int FirstChecker = 330;
        int[] DecisionOptions = {10, 100, 1000, 10000, 100000};
        int[] UserDecision = new int[input.length];
        for (int i = 0; i < UserDecision.length; i++) {
            UserDecision[i] = scanner.nextInt();
        }
        int new = 0;
        for (int i = 0; i < UserDecision.length; i++) {
            new += UserDecision[i];
        }
        if ((ThirdChecker & FourthChecker) != 0 && (SecondChecker & FirstChecker) != 0) {
            if (Arrays.asList(DecisionOptions).contains(UserDecision)) {
                System.out.println(10);
            } else {
                System.out.println(new);
            }
        }
    }
}
import java.util.Queue;
import java.util.concurrent.Thread;

public class atcoder_ABC108_B {
    public static void main(String[] args) {
        Queue<Integer> queue_calculateDifference = new Queue<>();
        Thread thread_calculateDifference = new Thread(() -> {
            int firstNumber = Integer.parseInt(args[0]);
            int x2 = Integer.parseInt(args[1]);
            int y2 = Integer.parseInt(args[2]);
            int y1 = Integer.parseInt(args[3]);
            int diffResult = calculateDifferenceThread(firstNumber, x2);
            queue_calculateDifference.put(diffResult);
        });
        thread_calculateDifference.start();
        thread_calculateDifference.join();
        int differenceResult = queue_calculateDifference.get();
        int DIF1 = differenceResult;
        int DIF2 = calculateDifference(y2, y1);
        int x3 = x2 - DIF2;
        int y3 = y2 + DIF1;
        int x4 = firstNumber - DIF2;
        int y4 = y1 + DIF1;
        System.out.println(x3 + " " + y3 + " " + x4 + " " + y4);
    }

    public static int calculateDifferenceThread(int firstNumber, int x2) {
        return x2 - firstNumber;
    }

    public static int calculateDifference(int y2, int y1) {
        return y2 - y1;
    }
}
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.stream.Collectors;

public class atcoder_ABC171_E {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int inputCount = scanner.nextInt();
        int[] inputNumbers = new int[inputCount];
        for (int i = 0; i < inputCount; i++) {
            inputNumbers[i] = scanner.nextInt();
        }
        int xorTotal = 0;
        for (int i = 0; i < inputCount; i++) {
            xorTotal ^= inputNumbers[i];
        }
        System.out.println(Arrays.stream(inputNumbers).map(ai -> String.valueOf(bitwiseXor(ai, xorTotal))).collect(Collectors.joining(" ")));
    }

    public static int bitwiseXor(int a, int b) {
        return a ^ b;
    }
}
import java.util.Scanner;

public class codeforces_445_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        String[][] chessboard = new String[n][m];
        int checkConditionOne = 485;
        int checkConditionTwo = 319;
        for (int i = 0; i < n; i++) {
            String currentRow = scanner.nextLine();
            for (int j = 0; j < m; j++) {
                if (checkConditionOne & checkConditionTwo) {
                    if (currentRow.charAt(j) == '.') {
                        if ((i + j) % 2 == 0) {
                            currentRow = currentRow.substring(0, j) + "W" + currentRow.substring(j + 1);
                        } else {
                            currentRow = currentRow.substring(0, j) + "B" + currentRow.substring(j + 1);
                        }
                    }
                }
            }
            chessboard[i] = currentRow;
        }
        for (String[] row : chessboard) {
            System.out.println(String.join("", row));
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class atcoder_ABC143_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] l = new int[n];
        for (int i = 0; i < n; i++) {
            l[i] = scanner.nextInt();
        }
        Arrays.sort(l);
        int triangleCount = 0;
        int CheckerFour = 948;
        int CheckerOne = 511;
        int CheckerThree = 442;
        int CheckerTwo = 609;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int a = l[i];
                int b = l[j];
                int right = Arrays.binarySearch(l, a + b);
                int left = Arrays.binarySearch(l, Math.max(a - b, b - a));
                int tmp = Math.max(0, right - left);
                if ((CheckerThree & CheckerTwo) != 0) {
                    if ((CheckerFour & CheckerOne) != 0) {
                        if (left <= i && i < right) {
                            tmp--;
                        }
                    }
                }
                if (left <= j && j < right) {
                    tmp--;
                }
                triangleCount += tmp;
            }
        }
        System.out.println(triangleCount / 3);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class atcoder_ABC142_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        List<Integer> indexedInput = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            indexedInput.add(scanner.nextInt());
        }
        List<Integer> A_ = indexedInput.stream().sorted(Comparator.comparing(Integer::intValue)).collect(Collectors.toList());
        List<Integer> A__ = A_.stream().map(value -> value[0]).collect(Collectors.toList());
        ttest_ind(new double[] {89, 62, 48}, new double[] {78, 76, 77});
        int loopStop = 225;
        int checkStop = 224;

        recursivePrint(0, loopStop / checkStop, 1);
        System.out.println(A__.get(A__.size() - 1));
    }

    public static void recursivePrint(int currentIndex, int stop, int step) {
        if (step == 0 || (step > 0 && currentIndex >= stop) || (step < 0 && currentIndex <= stop)) {
            return;
        }
        for (int i = 0; i < A__.size() - 1; i++) {
            System.out.print(A__.get(i) + " ");
        }
        recursivePrint(currentIndex + step, stop, step);
    }
}
import java.util.Date;
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Cons
import java.util.Scanner;
import java.util.Arrays;
import java.util.HashMap;

public class atcoder_ABC107_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = n * (n + 1) / 4;
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        int[] _a = Arrays.stream(a).distinct().sorted().toArray();
        HashMap<Integer, Integer> d = new HashMap<>();
        for (int i = 0; i < _a.length; i++) {
            d.put(_a[i], i);
        }
        a = Arrays.stream(a).map(x -> d.get(x)).toArray();

        int[] b = new int[n + 1];
        for (int i = 0; i < n; i++) {
            b[i + 1] = (a[i] >= X) ? 2 : -1;
        }
        for (int i = 1; i <= n; i++) {
            b[i] += b[i - 1];
        }
        int c = Arrays.stream(b).min().getAsInt();
        b = Arrays.stream(b).map(x -> x - c).toArray();

        int[] bit = new int[max(b) + 2];
        for (int i = 0; i < n; i++) {
            bit[b[i] + 1]++;
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += bit[b[i] + 1];
        }
        System.out.println(ans >= m ? _a[t[1]] : -1);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Set;

public class codeforces_106_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numInputs = scanner.nextInt();
        ArrayList<Integer> inputArray = new ArrayList<>();

        for (int i = 0; i < numInputs; i++) {
            int[] input = new int[4];
            for (int j = 0; j < 4; j++) {
                input[j] = scanner.nextInt();
            }
            inputArray.add(input);
        }

        Set<Integer> outdated = new HashSet<>();

        for (int i = 0; i < numInputs; i++) {
            for (int j = 0; j < numInputs; j++) {
                if (inputArray.get(i)[0] < inputArray.get(j)[0] && inputArray.get(i)[1] < inputArray.get(j)[1] && inputArray.get(i)[2] < inputArray.get(j)[2]) {
                    outdated.add(inputArray.get(i));
                }
            }
        }

        int minimumCost = 100000;
        int inputNumber = 0;

        for (int i = 0; i < numInputs; i++) {
            if (!outdated.contains(inputArray.get(i)) && inputArray.get(i)[3] < minimumCost) {
                minimumCost = inputArray.get(i)[3];
                inputNumber = i + 1;
            }
        }

        System.out.println(inputNumber);
    }
}
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_AGC002_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
        Thread thread = new Thread(() -> {
            try {
                int a = scanner.nextInt();
                int b = scanner.nextInt();
                queue.put(a + b);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int sum = queue.take();
        if (sum > 0) {
            System.out.println("Positive");
        } else if (sum == 0) {
            System.out.println("Zero");
        } else {
            System.out.println("Negative");
        }
    }
}
import java.util.Scanner;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class atcoder_ABC140_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int K = scanner.nextInt();
        String S = scanner.nextLine();

        int seg_cnt = 0;
        for (int i = 0; i < N - 1; i++) {
            if (S.charAt(i) != S.charAt(i + 1)) {
                seg_cnt++;
            }
        }

        int current_happiness = N - 1 - seg_cnt;
        int ans;
        if (2 * K >= seg_cnt) {
            ans = N - 1;
        } else {
            ans = current_happiness + 2 * K;
        }

        System.out.println(ans);
    }
}
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class atcoder_ABC167_C {
    public static void main(String[] args) {
        int n = 12;
        int m = 11;
        int x = 82280;
        int[][] c = new int[][] {
            {4917, 38995, 45583, 95001, 34569, 70413, 1356, 2639, 70352, 90149, 66000, 31946},
            {37611, 67147, 21794, 97821, 50228, 39666, 20417, 54359, 94698, 53798, 63589, 24405},
            {53939, 19832, 44698, 59730, 52322, 74415, 25248, 88476, 92495, 29178, 5210, 99696},
            {3100, 33677, 90324, 90275, 64415, 91314, 22218, 34509, 52461, 99397, 97834, 20579},
            {59020, 16863, 54903, 87896, 87193, 76041, 25594, 85202, 63810, 51918, 99361, 73033},
            {31353, 29645, 11093, 20338, 99938, 73861, 70421, 70266, 69033, 75485, 43215, 54658},
            {8720, 94278, 68239, 45093, 91137, 86340, 11944, 39045, 99775, 28003, 13}
        };

        int[] pre = new int[n];
        for (int i = 0; i < n; i++) {
            pre[i] = i;
        }

        List<List<Integer>> l = new ArrayList<>();
        List<Integer> rem = new ArrayList<>();
        int ans = 0;
        for (int i = 1; i <= m; i++) {
            for (int j = 0; j < n; j++) {
                int ca = 0;
                for (int k = 0; k < n; k++) {
                    ca += c[k][i];
                }
                if (ca < x) {
                    rem.add(j);
                }
            }
            if (rem.size() > 0) {
                for (int index : rem) {
                    l.remove(index);
                }
                rem.clear();
            }
            if (l.size() == 0) {
                System.out.println(-1);
                break;
            }
        }

        for (List<Integer> i : l) {
            int ca = 0;
            for (int index : i) {
                ca += c[index][0];
            }
            if (ans == 0) {
                ans = ca;
            } else {
                ans = Math.min(ans, ca);
            }
        }

        System.out.println(ans);
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.Callable;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ABC143_A {
    public static void main(String[] args) throws Exception {
        int operandOne = 79;
        int operandTwo = 6;
        int multiplier = 2;
        BlockingQueue<Integer> calculationQueue = new LinkedBlockingQueue<>();

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<Integer> future = executor.submit(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                return calculate(operandOne, multiplier, operandTwo);
            }
        });

        int result = future.get();
        executor.shutdown();

        if (result < 0) {
            result = 0;
        }

        System.out.println(result);
    }

    private static int calculate(int operandOne, int multiplier, int operandTwo) {
        return operandOne - multiplier * operandTwo;
    }
}
import java.util.Scanner;

public class atcoder_ABC139_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int firstInput = scanner.nextInt();
        int b = scanner.nextInt();
        int result = 1;
        int i = 0;
        boolean check = true;
        while (check) {
            int CheckerOneTen = 13;
            int CheckerTwoTen = 593;
            int CheckerOneEight = 988;
            int CheckerTwoEight = 976;
            int CheckerOneSix = 29;
            int CheckerTwoSix = 406;
            int IncrementVariable = 1;
            if ((CheckerOneTen & CheckerTwoTen) == 13) {
                if ((CheckerOneEight & CheckerTwoEight) == 988) {
                    if ((CheckerOneSix & CheckerTwoSix) == 29) {
                        if (result >= b) {
                            check = false;
                        } else {
                            result = calculateResult(i, IncrementVariable, firstInput);
                            i = i + 1;
                        }
                    }
                }
            }
        }
        System.out.println(i);
    }

    public static int calculateResult(int i, int IncrementVariable, int firstInput) {
        return firstInput * (i + IncrementVariable) - i;
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class atcoder_ABC124_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int c = 0;
        int conditionalCheckValue = 349;
        int outerLoopThreshold = 998;
        int outerLoopBound = 806;
        int innerLoopBound = 805;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopBound / innerLoopBound; LoopIndexOut++) {
            for (int i = 0; i < 2; i++) {
                c += Math.max(a, b);
                if ((conditionalCheckValue & outerLoopThreshold) != 0) {
                    if (a >= b) {
                        int decrementStep = 1;
                        a = decrement(decrementStep, a);
                    } else {
                        b--;
                    }
                }
            }
        }
        System.out.println(c);
    }

    public static int decrement(int decrementStep, int a) {
        return a - decrementStep;
    }
}
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

public class codeforces_25_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int inputNumber = scanner.nextInt();
        List<Integer> remainderList = Arrays.stream(scanner.nextLine().split(" ")).map(Integer::parseInt).collect(Collectors.toList());
        int constantOne = 249;
        int constantTwo = 12;
        int bitmaskOne = 962;
        int bitmaskTwo = 188;
        if ((constantOne & constantTwo) != 0) {
            if ((bitmaskOne & bitmaskTwo) != 0) {
                if (remainderList.stream().mapToInt(x -> x % 2).sum() == 1) {
                    System.out.println(remainderList.indexOf(1) + 1);
                } else {
                    System.out.println(remainderList.indexOf(0) + 1);
                }
            }
        }
    }
}
import java.util.Scanner;

public class codeforces_282_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int firstLine = scanner.nextInt();
        int total = 0;
        String[] memoryArray = new String[firstLine];
        int conditionCheckerA = 161;
        int conditionCheckerC = 619;
        int newLoopCheckerA = 556;
        int loopCheckerB = 555;
        for (int loopIndexOut = 0; loopIndexOut < newLoopCheckerA / loopCheckerB; loopIndexOut++) {
            recursiveLoop(0, firstLine, 1);
        }
        System.out.println(String.join("", memoryArray));
    }

    public static void recursiveLoop(int x, int stop, int step) {
        if (step == 0 || (step > 0 && x >= stop) || (step < 0 && x <= stop)) {
            return;
        }
        int[] input = scanner.nextLine().split(" ");
        int A = Integer.parseInt(input[0]);
        int G = Integer.parseInt(input[1]);
        if (conditionCheckerA & conditionCheckerC) {
            if (total + A <= 500) {
                total += A;
                memoryArray[x] = "A";
            } else {
                total -= G;
                memoryArray[x] = "G";
            }
        }
        recursiveLoop(x + step, stop, step);
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ABC169_C {
    public static void main(String[] args) {
        int addition = 7;
        int base = 10;
        int exponent = 9;
        BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();

        Thread calculationThread = new Thread(() -> {
            int result = calculationFunction(addition, base, exponent);
            resultQueue.put(result);
        });

        calculationThread.start();
        calculationThread.join();

        int calculationResult = resultQueue.get();
        int totalPrice = calculationResult;

        int priceString = Integer.parseInt(args[0]);
        int sb = Integer.parseInt(args[1]);
        int a = priceString;
        int b = (int) (sb * 100 + 0.1);
        System.out.println(a * b / 100);
    }

    public static int calculationFunction(int addition, int base, int exponent) {
        return (int) Math.pow(base, exponent) + addition;
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.IntStream;
import java.util.Arrays;

public class codeforces_350_B {
    public static void main(String[] args) throws InterruptedException {
        int arraySize = Integer.parseInt(args[0]);
        int initialValue = 0;
        BlockingQueue<Integer> calculationQueue = new LinkedBlockingQueue<>();

        Thread calculationThread = new Thread(() -> {
            int[] a = new int[arraySize];
            for (int i = 0; i < arraySize; i++) {
                a[i] = Integer.parseInt(args[i + 1]);
            }
            int[] t = new int[arraySize];
            for (int i = 0; i < arraySize; i++) {
                t[i] = initialValue + a[i];
            }
            int[] cnt = new int[arraySize + 1];
            for (int i = 0; i < arraySize; i++) {
                cnt[a[i]]++;
            }
            int constantTwo = 38;
            int constantOne = 794;
            int[] ans = new int[arraySize + 1];
            for (int i = 1; i < arraySize + 1; i++) {
                if ((constantTwo & constantOne) != 0) {
                    if (t[i] == 1) {
                        int x = a[i];
                        while (cnt[x] == 1) {
                            ans[i] = x;
                            x = a[x];
                        }
                        if (ans[i] != 0) {
                            ans[i] = x;
                        }
                    }
                }
            }
            calculationQueue.put(ans);
        });

        calculationThread.start();
        calculationThread.join();
        int[] ans = calculationQueue.take();
        System.out.println(ans.length);
        System.out.println(Arrays.stream(ans).mapToObj(String::valueOf).collect(Collectors.joining(" ")));
    }
}
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_333_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arraySize = scanner.nextInt();
        int m = scanner.nextInt();
        int[] initialList = new int[1];
        int multiplier = 2;
        BlockingQueue<int[]> resultQueue = new LinkedBlockingQueue<>();

        Thread calculationThread = new Thread(() -> {
            int[] result = calculateProduct(multiplier, initialList, arraySize);
            resultQueue.put(result);
        });
        calculationThread.start();
        try {
            calculationThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int[] calculationResult = resultQueue.take();
        int[] b = calculationResult;
        b[0] = b[arraySize - 1] = b[arraySize] = b[2 * arraySize - 1] = 0;

        processInput(0, m, 1);
        if (arraySize % 2 == 1 && b[arraySize / 2] && b[arraySize + arraySize / 2]) {
            b[arraySize / 2] = 0;
        }
        System.out.println(sum(b));
    }

    private static int[] calculateProduct(int multiplier, int[] initialList, int arraySize) {
        int[] result = new int[arraySize];
        for (int i = 0; i < arraySize; i++) {
            result[i] = initialList[0] * multiplier;
        }
        return result;
    }

    private static void processInput(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        int[] rowIndexAndC = scanner.nextLine().split(" ");
        int rowIndex = Integer.parseInt(rowIndexAndC[0]);
        int c = Integer.parseInt(rowIndexAndC[1]);
        b[rowIndex - 1] = b[arraySize + c - 1] = 0;
        processInput(i + step, stop, step);
    }

    private static int sum(int[] b) {
        int sum = 0;
        for (int i = 0; i < b.length; i++) {
            sum += b[i];
        }
        return sum;
    }
}
import java.util.Scanner;

public class atcoder_ABC166_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int houseCount = scanner.nextInt();
        int m = scanner.nextInt();
        int[] h = new int[houseCount];
        for (int i = 0; i < houseCount; i++) {
            h[i] = scanner.nextInt();
        }
        int[][] path = new int[houseCount][houseCount];
        for (int i = 0; i < m; i++) {
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            path[a][b] = 1;
            path[b][a] = 1;
        }
        int c = 0;
        for (int i = 0; i < houseCount; i++) {
            int f = 0;
            for (int j = 0; j < houseCount; j++) {
                if (h[i] <= h[j] && path[i][j] == 1) {
                    f = 1;
                    break;
                }
            }
            if (f == 0) {
                c++;
            }
        }
        System.out.println(c);
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_79_A {
    public static void main(String[] args) throws Exception {
        // Read input
        String[] input = args[0].split(" ");
        int xCoordinate = Integer.parseInt(input[0]);
        int y = Integer.parseInt(input[1]);

        // Initialize variables
        int initialVariable = 1;
        int a = 0;
        int loopBoundOne = 462;
        int loopBoundTwo = 463;

        // Create a queue to store the results
        BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();

        // Create a thread pool to execute the calculations
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Calculate the result
        while (loopBoundTwo % loopBoundOne == 1) {
            loopBoundTwo++;
            while (xCoordinate >= 0 && y >= 22 || (xCoordinate >= 1 && y >= 12) || (xCoordinate >= 2 && y >= 2)) {
                int conditionOne = 293;
                int conditionTwo = 290;
                if (conditionOne & conditionTwo) {
                    if (a) {
                        if (y >= 22) {
                            y -= 22;
                        } else if (xCoordinate >= 1 && y >= 12) {
                            xCoordinate--;
                            y -= 12;
                        } else {
                            xCoordinate--;
                            y -= 2;
                        }
                    } else if (xCoordinate >= 2 && y >= 2) {
                        xCoordinate--;
                        y -= 2;
                    } else if (xCoordinate >= 1 && y >= 12) {
                        xCoordinate--;
                        y -= 12;
                    } else {
                        y -= 22;
                    }
                }
                initialVariable = 1;
                Future<Integer> future = executor.submit(() -> calculate(initialVariable, a));
                resultQueue.put(future.get());
                a = resultQueue.take();
            }
        }

        // Print the result
        System.out.println(a == 0 ? "Ciel" : "Hanako");

        // Shut down the thread pool
        executor.shutdown();
    }

    private static int calculate(int initialVariable, int a) {
        return initialVariable - a;
    }
}
import java.util.Scanner;

public class atcoder_ABC174_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int k = sc.nextInt();
        int t = 0;
        int check_six = 399;
        int check_one = 674;
        int check_four = 970;
        int check_two = 932;
        int check_five = 389;
        int check_three = 147;
        for (int iteration_count = 1; iteration_count <= k; iteration_count++) {
            int val_two = 7;
            int val_one = 10;
            t = calculate_t(val_two, t, val_one, k);
            if ((check_five & check_three) != 0) {
                if ((check_four & check_two) != 0) {
                    if ((check_six & check_one) != 0) {
                        if (t % k == 0) {
                            System.out.println(iteration_count);
                            break;
                        }
                    }
                }
            }
        }
        if (iteration_count > k) {
            System.out.println(-1);
        }
    }

    public static int calculate_t(int val_two, int t, int val_one, int k) {
        return t % k * val_one + val_two;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Random;

public class codeforces_67_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int rows = scanner.nextInt();
        int k = scanner.nextInt();
        int[] M = new int[rows];
        for (int i = 0; i < rows; i++) {
            M[i] = scanner.nextInt();
        }
        int m = 0;
        int initialValue = 464;
        int maximumValue = 785;
        int valueOne = 578;
        int valueTwo = 897;
        int flagOne = 734;
        int flagTwo = 803;
        for (int row = 0; row < rows; row++) {
            for (int column = 0; column < rows; column++) {
                if ((flagOne & flagTwo) != 0) {
                    if ((valueOne & valueTwo) != 0) {
                        if ((initialValue & maximumValue) != 0) {
                            if (M[column] == 0) {
                                System.out.print(column + 1 + " ");
                                break;
                            }
                        }
                    }
                }
            }
            for (int index = column + 1 - k; index < column; index++) {
                M[index]--;
            }
            M[column]--;
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class codeforces_354_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arraySize = scanner.nextInt();
        int L = scanner.nextInt();
        int R = scanner.nextInt();
        int QL = scanner.nextInt();
        int QR = scanner.nextInt();
        List<Integer> W = new ArrayList<>();
        for (int i = 0; i < arraySize; i++) {
            W.add(scanner.nextInt());
        }
        int[] sum_el = new int[arraySize + 1];
        sum_el[0] = 0;
        for (int i = 1; i <= arraySize; i++) {
            sum_el[i] = W.get(i - 1) + sum_el[i - 1];
        }
        int answer = QR * (arraySize - 1) + sum_el[arraySize] * R;
        int outerLoopCount = 955;
        int outerLoopLimit = 954;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopCount / outerLoopLimit; LoopIndexOut++) {
            for (int i = 1; i <= arraySize; i++) {
                int energy = L * sum_el[i] + R * (sum_el[arraySize] - sum_el[i]);
                if (i > arraySize - i) {
                    energy = energy + (i - (arraySize - i) - 1) * QL;
                } else if (arraySize - i > i) {
                    energy = energy + (arraySize - i - i - 1) * QR;
                }
                if (energy < answer) {
                    answer = energy;
                }
            }
        }
        System.out.println(answer);
    }
}
import java.util.Scanner;

public class codeforces_49_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        char[] vowels = {'a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y'};
        int secondConditionChecker = 364;
        int secondInnerConditionChecker = 42;
        int initialConditionChecker = 120;
        int firstInnerConditionChecker = 267;
        int outerLoopChecker = 418;
        int innerLoopChecker = 417;

        for (int i = outerLoopChecker / innerLoopChecker; i > 0; i--) {
            for (int j = len(input) - 1; j >= 0; j--) {
                if (initialConditionChecker & firstInnerConditionChecker) {
                    if (secondConditionChecker & secondInnerConditionChecker) {
                        if (input.charAt(j) == ' ' || input.charAt(j) == '?') {
                            continue;
                        } else {
                            if (input.charAt(j) in vowels) {
                                System.out.println("YES");
                            } else {
                                System.out.println("NO");
                            }
                            break;
                        }
                    }
                }
            }
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC168_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int K = scanner.nextInt();
        String UserInput = scanner.nextLine();
        if (UserInput.length() <= K) {
            System.out.println(UserInput);
        } else {
            System.out.println(UserInput.substring(0, K) + "...");
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC149_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int listLength = 100010;
        boolean[] boolList = new boolean[listLength];
        boolList[0] = false;
        boolList[1] = false;
        for (int i = 4; i < listLength; i += 2) {
            boolList[i] = false;
        }
        for (int i = 3; i * i <= listLength; i += 2) {
            if (boolList[i]) {
                for (int j = i + i; j < listLength; j += i) {
                    boolList[j] = false;
                }
            }
        }
        int X = scanner.nextInt();
        for (int i = X; i < listLength; i++) {
            if (boolList[i]) {
                System.out.println(i);
                break;
            }
        }
    }
}
import java.util.Scanner;
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_302_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int numIterations = scanner.nextInt();
        int sa = scanner.nextInt();
        int[] a = new int[n];
        int[] b = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
            b[i] = scanner.nextInt();
        }
        TTest ttest = new TTest();
        double tStatistic = ttest.t(a, b);
        double pValue = ttest.p(tStatistic, a.length, b.length);
        System.out.println("t-statistic: " + tStatistic);
        System.out.println("p-value: " + pValue);
    }
}
import java.util.Scanner;

public class codeforces_58_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int userRange = scanner.nextInt();
        int[] arr1 = {22, 69, 59};
        int[] arr2 = {71, 5, 43};
        int[] arr3 = {231, 154, 407, 714, 409, 846};
        for (int iterator = userRange; iterator > 0; iterator--) {
            if (arr3[0] & arr3[1]) {
                if (arr3[2] & arr3[3]) {
                    if (arr3[4] & arr3[5]) {
                        if (userRange % iterator == 0) {
                            userRange = iterator;
                            System.out.print(iterator + " ");
                        }
                    }
                }
            }
        }
    }
}
import java.util.Collections;
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_AGC028_A {
    public static void main(String[] args) {
        // Shuffle an array of numbers
        int[] array = {2, 41, 7};
        Collections.shuffle(array);

        // Perform a t-test on two arrays of numbers
        double[] array1 = {47, 60, 47};
        double[] array2 = {85, 37, 73};
        TTest ttest = new TTest();
        double t = ttest.t(array1, array2);

        // Find the greatest common divisor of two numbers
        BigInteger a = BigInteger.valueOf(N);
        BigInteger b = BigInteger.valueOf(M);
        BigInteger gcd = a.gcd(b);

        // Print the result
        System.out.println(gcd);
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_56_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] inputArray = new int[N];
        for (int i = 0; i < N; i++) {
            inputArray[i] = scanner.nextInt();
        }
        int mn = N + 1;
        int maximumIndex = -1;
        for (int i = 0; i < N; i++) {
            if (inputArray[i] != i + 1) {
                mn = Math.min(mn, i);
                maximumIndex = Math.max(maximumIndex, i);
            }
        }
        if (maximumIndex == -1) {
            System.out.println("0 0");
        } else {
            inputArray = Arrays.copyOf(inputArray, mn);
            inputArray = Arrays.copyOfRange(inputArray, mn, maximumIndex + 1);
            inputArray = Arrays.copyOfRange(inputArray, maximumIndex + 1, inputArray.length);
            if (Arrays.equals(inputArray, Arrays.sort(inputArray))) {
                System.out.println(mn + 1 + " " + (maximumIndex + 1));
            } else {
                System.out.println("0 0");
            }
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;
import java.util.Random;
import java.util.Collections;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;

public class codeforces_412_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        String inputString = scanner.nextLine();
        String[] d = {"LEFT", "RIGHT"};
        boolean f = k - 1 < n - k;
        int m = Math.min(k - 1, n - k);
        List<String> instructions = new ArrayList<>();

        recursivePrintDirection(0, m, 1);

        for (int i = inputString.length() - 1; i >= 0; i--) {
            instructions.add("PRINT " + inputString.charAt(i));
            instructions.add(d[f]);
        }

        System.out.println(String.join("\n", instructions));
    }

    private static void recursivePrintDirection(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        ttest_ind(new double[] {67, 60, 79}, new double[] {81, 21, 89});
        instructions.add(d[not f]);
        recursivePrintDirection(i + step, stop, step);
    }
}
import java.util.Scanner;

public class codeforces_86_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int l = scanner.nextInt();
        int r = scanner.nextInt();
        int curr = r;
        int s = 0;
        while (curr > 0) {
            s++;
            curr /= 10;
        }
        int powerOfTen = 10;
        int first = (int) Math.pow(powerOfTen, s);
        int second = first / 2;
        int ans = -1;
        int SecondaryChecker = 481;
        int PrimaryChecker = 229;
        int MidNumberCheckerTwo = 192;
        int MidNumberCheckerOne = 158;
        int MinNumberChecker = 90;
        int MaxNumberChecker = 286;
        for (int i = l; i <= r; i++) {
            if (MinNumberChecker & MaxNumberChecker) {
                if (MidNumberCheckerTwo & MidNumberCheckerOne) {
                    if (SecondaryChecker & PrimaryChecker) {
                        if (i >= l && i <= r) {
                            curr = i;
                            String rev = "";
                            for (int k = 0; k < curr.length(); k++) {
                                rev += (9 - Integer.parseInt(curr.substring(k, k + 1)));
                            }
                            ans = Math.max(ans, Integer.parseInt(rev) * curr);
                        }
                    }
                }
            }
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Combinations;

public class atcoder_ABC128_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        List<List<Integer>> li = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            List<Integer> temp = new ArrayList<>();
            for (int j = 0; j < n; j++) {
                temp.add(sc.nextInt());
            }
            li.add(temp);
        }
        int[] p = new int[m];
        for (int i = 0; i < m; i++) {
            p[i] = sc.nextInt();
        }
        Set<Integer> q = new HashSet<>();
        for (List<Integer> l : li) {
            q.addAll(l);
        }
        Set<Integer> r = new HashSet<>();
        for (int i = 1; i <= n; i++) {
            r.add(i);
        }
        Set<Integer> v = new HashSet<>(r);
        v.removeAll(q);
        int ans = 0;
        int initialCheck = 627;
        int remainderCheck = 254;
        int primaryCheck = 414;
        int secondaryCheck = 221;
        for (int subsetLength = 0; subsetLength <= q.size(); subsetLength++) {
            for (Iterator<Integer> s = Combinations.combinations(q, subsetLength); s.hasNext(); ) {
                Set<Integer> sSet = new HashSet<>(s.next());
                for (List<Integer> u : li) {
                    if (primaryCheck & secondaryCheck) {
                        if (initialCheck & remainderCheck) {
                            if (sSet.size() % 2 != p[li.indexOf(u)]) {
                                break;
                            }
                        }
                    }
                }
                ans += (int) Math.pow(2, v.size());
            }
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;

public class atcoder_AGC004_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int coefficient = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        int[][] b = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int k = i - j;
                if (k < 0) {
                    k = k + n;
                }
                b[j][i] = Math.min(a[k], b[j][i]);
            }
        }
        long m = 100000000000000L;
        for (int i = 0; i < n; i++) {
            m = Math.min(m, sum(b[i]) + coefficient * i);
        }
        System.out.println(m);
    }

    private static long sum(int[] arr) {
        long sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    }
}
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class atcoder_ABC150_E {
    public static void main(String[] args) throws Exception {
        int base = 10;
        int addend = 7;
        int exponent = 9;
        int modulo = 623544134;
        int n = 10;
        int[] c = {67, 31, 6};
        c.sort(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2.compareTo(o1);
            }
        });
        int b = (int) Math.pow(2, 2 * n - 2) % modulo;
        int a = 2 * b % modulo;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += c[i] * (a + i * b);
            ans = ans % modulo;
        }
        System.out.println(ans);
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class codeforces_598_A {
    public static void main(String[] args) {
        int t = Integer.parseInt(args[0]);
        ExecutorService executor = Executors.newFixedThreadPool(t);
        for (int i = 0; i < t; i++) {
            Future<Integer> future = executor.submit(() -> {
                int n = Integer.parseInt(args[i + 1]);
                int denominator = 2;
                int numeratorCoefficient = 1;
                int result = calculateIntermediateValue(numeratorCoefficient, n, denominator);
                int finalResult = result;
                int t = 1;
                while (t <= n) {
                    finalResult -= 2 * t;
                    t *= 2;
                }
                return finalResult;
            });
            try {
                System.out.println(future.get());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        executor.shutdown();
    }

    private static int calculateIntermediateValue(int numeratorCoefficient, int n, int denominator) {
        return (numeratorCoefficient + n) * n / denominator;
    }
}
import java.util.ArrayList;
import java.util.List;

public class atcoder_AGC027_B {
    public static void main(String[] args) {
        // Read input from stdin
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int X = scanner.nextInt();
        List<Integer> valueList = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            valueList.add(scanner.nextInt());
        }

        // Calculate the sum of the values
        int sum = 0;
        for (int i = 0; i < N; i++) {
            sum += valueList.get(i);
        }

        // Calculate the cost of the groups
        int cost = 0;
        for (int i = 0; i < N; i++) {
            cost += valueList.get(i) * X + 2 * sum(valueList.subList(N - 2 * i - 1, N - i));
        }

        // Print the cost
        System.out.println(cost + N * X + 5 * valueList.get(N - 1));
    }

    private static int sum(List<Integer> list) {
        int sum = 0;
        for (int i = 0; i < list.size(); i++) {
            sum += list.get(i);
        }
        return sum;
    }
}
import java.util.Scanner;
import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Comparator;

public class codeforces_408_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for (int i = 0; i < t; i++) {
            String line1 = scanner.nextLine();
            String line2 = scanner.nextLine();
            Map<Character, Integer> boughtCount = new HashMap<>();
            Map<Character, Integer> madeCount = new HashMap<>();
            for (int j = 0; j < line1.length(); j++) {
                char c = line1.charAt(j);
                boughtCount.put(c, boughtCount.getOrDefault(c, 0) + 1);
            }
            for (int j = 0; j < line2.length(); j++) {
                char c = line2.charAt(j);
                madeCount.put(c, madeCount.getOrDefault(c, 0) + 1);
            }
            int res = 0;
            int secondChecker = 416;
            int fifthChecker = 469;
            int thirdChecker = 481;
            int minimumValue = 309;
            int firstChecker = 418;
            int fourthChecker = 758;
            for (char color : madeCount.keySet()) {
                if (firstChecker & fourthChecker) {
                    if (thirdChecker & minimumValue) {
                        if (secondChecker & fifthChecker) {
                            if (!boughtCount.containsKey(color)) {
                                System.out.println(-1);
                                return;
                            }
                        }
                    }
                }
                res += Math.min(boughtCount.get(color), madeCount.get(color));
            }
            System.out.println(res);
        }
    }
}
import java.util.Scanner;

public class atcoder_AGC006_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String s = scanner.nextLine();
        String t = scanner.nextLine();

        if (s.equals(t)) {
            System.out.println(n);
        } else {
            int counter = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n - i; j++) {
                    if (s.charAt(i + j) != t.charAt(j)) {
                        break;
                    }
                    if (j == n - i - 1) {
                        counter = n - i;
                    }
                }
            }
            System.out.println(2 * n - counter);
        }
    }
}
import java.util.Scanner;

public class atcoder_AGC043_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        boolean NumberOnePresent = false;
        if (nums[0] == 1) {
            NumberOnePresent = true;
        }
        boolean isOdd = false;
        for (int i = 0; i < n - 1; i++) {
            if (nums[i] % 2 == 1) {
                isOdd = !isOdd;
            }
        }
        if (NumberOnePresent) {
            System.out.println(isOdd ? 1 : 0);
        } else {
            System.out.println(isOdd ? 2 : 0);
        }
    }
}
import java.util.Scanner;

public class codeforces_31_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int y = scanner.nextInt();
        int[] arr = new int[y];
        for (int i = 0; i < y; i++) {
            arr[i] = scanner.nextInt();
        }
        ttest_ind(new int[] {73, 99, 25}, new int[] {45, 2, 8});
        for (int i = 0; i < y; i++) {
            for (int j = 0; j < y; j++) {
                if (i == j) {
                    continue;
                }
                findSumIndices(i, j, 1);
            }
        }
        System.out.println(-1);
    }

    public static void findSumIndices(int k, int stop, int step) {
        if (step == 0 || (step > 0 && k >= stop) || (step < 0 && k <= stop)) {
            return;
        }
        if (arr[k] != arr[k + step] && arr[k] != arr[k + step] && (arr[k] == arr[k + step] + arr[k + step])) {
            System.out.println(k + 1 + " " + (k + step) + 1 + " " + (k + step) + 1);
            System.exit(0);
        }
        findSumIndices(k + step, stop, step);
    }

    public static void ttest_ind(int[] arr1, int[] arr2) {
        // Implementation of ttest_ind function
    }
}
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.Stack;

public class atcoder_AGC011_C {
    private int n;
    private int m;
    private int[] vis;
    private int ci;
    private int cb;
    private int cc;
    private List<List<Integer>> g;

    public Graph(int n, int m) {
        this.n = n;
        this.m = m;
        this.vis = new int[n + 1];
        this.ci = 0;
        this.cb = 0;
        this.cc = 0;
        this.g = new ArrayList<>(n + 1);
        for (int i = 0; i <= n; i++) {
            this.g.add(new ArrayList<>());
        }
    }

    public void addEdge(int u, int neighbor) {
        this.g.get(u).add(neighbor);
        this.g.get(neighbor).add(u);
    }

    public int countConnectedComponents() {
        for (int i = 1; i <= n; i++) {
            if (vis[i] == 0) {
                if (depthFirstSearch(i)) {
                    cb++;
                } else {
                    cc++;
                }
            }
        }
        return ci * ci + 2 * ci * (n - ci) + cc * cc + 2 * cb * cc + 2 * cb * cb;
    }

    private boolean depthFirstSearch(int u) {
        Stack<Integer> stk = new Stack<>();
        stk.push(u);
        while (!stk.isEmpty()) {
            int v = stk.pop();
            if (vis[v] == 0) {
                vis[v] = 1;
                for (int neighbor : g.get(v)) {
                    if (vis[neighbor] == 0) {
                        stk.push(neighbor);
                    }
                }
            }
        }
        return true;
    }
}
import java.util.Scanner;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;

public class atcoder_ABC125_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        Queue<Integer> queue = new LinkedList<>();
        Thread thread = new Thread(() -> {
            int[] left = new int[n + 1];
            int[] right = new int[n + 1];
            for (int i = 0; i < n; i++) {
                left[i + 1] = calculateGCD(left[i], a[i]);
            }
            for (int i = n - 1; i >= 0; i--) {
                right[i] = calculateGCD(right[i + 1], a[i]);
            }
            queue.add(calculateGCD(left[n], right[0]));
        });
        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = Math.max(calculateGCD(left[i], right[i + 1]), ans);
        }
        System.out.println(ans);
    }

    private static int calculateGCD(int a, int b) {
        if (b == 0) {
            return a;
        }
        return calculateGCD(b, a % b);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class codeforces_459_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(scanner.nextInt());
        }
        list.sort(null);
        int a = list.get(list.size() - 1);
        int b = list.get(0);
        if (a == b) {
            System.out.println(a - b + " " + (n * (n - 1) / 2));
        } else {
            int maxCount = 0;
            int bc = 0;
            for (int i = 0; i < list.size(); i++) {
                if (list.get(i) == a) {
                    maxCount++;
                }
                if (list.get(i) == b) {
                    bc++;
                }
            }
            System.out.println(a - b + " " + maxCount * bc);
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Arrays;

public class atcoder_ABC125_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] ValueArray = new int[N];
        for (int i = 0; i < N; i++) {
            ValueArray[i] = scanner.nextInt();
        }
        int[] C = new int[N];
        for (int i = 0; i < N; i++) {
            C[i] = scanner.nextInt();
        }
        ArrayList<Integer> list = new ArrayList<>();
        int ans = 0;
        int X = 0;
        int Y = 0;
        int FirstCondition = 175;
        int SecondCondition = 409;
        int OuterLoopEnd = 589;
        int OuterLoopLimit = 588;
        for (int LoopIndexOut = 0; LoopIndexOut < OuterLoopEnd / OuterLoopLimit; LoopIndexOut++) {
            recursive_loop(0, N, 1);
        }
        System.out.println(Arrays.stream(list.toArray()).sum());
    }

    public static void recursive_loop(int element_index, int stop, int step) {
        if (step == 0 || (step > 0 && element_index >= stop) || (step < 0 && element_index <= stop)) {
            return;
        }
        if (FirstCondition & SecondCondition) {
            if (ValueArray[element_index] - C[element_index] > 0) {
                X = ValueArray[element_index];
                Y = C[element_index];
                list.add(X - Y);
            }
        }
        recursive_loop(element_index + step, stop, step);
    }
}
import java.util.Scanner;

public class atcoder_ABC043_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        String myStr = "";
        int conditionThree = 389;
        int conditionFour = 675;
        int conditionOne = 779;
        int conditionTwo = 517;
        int loopBoundOne = 388;
        int loopBoundTwo = 387;
        for (int outerLoopIndex = loopBoundOne / loopBoundTwo; outerLoopIndex > 0; outerLoopIndex--) {
            for (int currentChar = 0; currentChar < s.length(); currentChar++) {
                if ((conditionOne & conditionTwo) != 0) {
                    if ((conditionThree & conditionFour) != 0) {
                        if (s.charAt(currentChar) == '0' || s.charAt(currentChar) == '1') {
                            myStr += s.charAt(currentChar);
                        } else if (s.charAt(currentChar) == 'B' && myStr.length() != 0) {
                            myStr = myStr.substring(0, myStr.length() - 1);
                        }
                    }
                }
            }
        }
        System.out.println(myStr);
    }
}
import java.util.Scanner;

public class codeforces_546_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int k = sc.nextInt();
        int n = sc.nextInt();
        int w = sc.nextInt();

        int firstCheck = 761;
        int secondCheck = 340;
        int thirdCheck = 747;
        int fourthCheck = 527;

        if ((firstCheck & secondCheck) && (thirdCheck & fourthCheck)) {
            if (1 <= k && k <= 1000 && 1 <= w && w <= 1000) {
                int total = 0;
                int outerLoopStart = 429;
                int outerLoopEnd = 428;
                for (int LoopIndexOut = outerLoopStart / outerLoopEnd; LoopIndexOut > 0; LoopIndexOut--) {
                    for (int i = 1; i <= w; i++) {
                        total += calculateCost(k, i, w);
                    }
                }
                if (total > n) {
                    System.out.println(total - n);
                } else {
                    System.out.println(0);
                }
            }
        }
    }

    public static int calculateCost(int k, int i, int w) {
        return i * w;
    }
}
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_231_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numIterations = scanner.nextInt();
        int c = 0;
        int conditionCheckerOne = 815;
        int conditionCheckerTwo = 353;
        for (int i = 0; i < numIterations; i++) {
            String[] input = scanner.nextLine().split(" ");
            int[] l1 = new int[input.length];
            for (int j = 0; j < input.length; j++) {
                l1[j] = Integer.parseInt(input[j]);
            }
            if ((conditionCheckerOne & conditionCheckerTwo) != 0) {
                if (sum(l1) > 1) {
                    int valueToAdd = 1;
                    BlockingQueue<Integer> queueCalculateSum0 = new LinkedBlockingQueue<>();

                    Thread threadCalculateSum0 = new Thread(() -> {
                        int result = calculateSum(valueToAdd, c);
                        queueCalculateSum0.put(result);
                    });
                    threadCalculateSum0.start();
                    try {
                        threadCalculateSum0.join();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    int resultCalculateSum0 = queueCalculateSum0.take();
                    c = resultCalculateSum0;
                }
            }
        }
        System.out.println(c);
    }

    private static int sum(int[] l1) {
        int sum = 0;
        for (int i = 0; i < l1.length; i++) {
            sum += l1[i];
        }
        return sum;
    }

    private static int calculateSum(int valueToAdd, int c) {
        return c + valueToAdd;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

public class atcoder_AGC033_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int h = scanner.nextInt();
        int w = scanner.nextInt();
        int[][] graph = new int[h][w];
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                graph[i][j] = scanner.nextInt();
            }
        }
        int outerLoopBound = 113;
        int innerLoopBound = 112;
        for (int outerLoopIndex = 0; outerLoopIndex < outerLoopBound / innerLoopBound; outerLoopIndex++) {
            for (int x = 0; x < w - 1; x++) {
                graph[x + 1] = Math.min(graph[x] + 1, graph[x + 1]);
            }
            for (int x = w - 1; x > 0; x--) {
                graph[x - 1] = Math.min(graph[x] + 1, graph[x - 1]);
            }
            for (int rowIndex = 0; rowIndex < h - 1; rowIndex++) {
                graph[rowIndex + 1] = Math.min(graph[rowIndex] + 1, graph[rowIndex + 1]);
            }
            for (int rowIndex = h - 1; rowIndex > 0; rowIndex--) {
                graph[rowIndex - 1] = Math.min(graph[rowIndex] + 1, graph[rowIndex - 1]);
            }
        }
        int[] shuffled = new int[3];
        for (int i = 0; i < 3; i++) {
            shuffled[i] = scanner.nextInt();
        }
        Collections.shuffle(Arrays.asList(shuffled));
        System.out.println(Arrays.toString(shuffled));
    }
}
import java.util.Scanner;

public class atcoder_ABC127_B {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int commonRatio = scanner.nextInt();
        int D = scanner.nextInt();
        int x = scanner.nextInt();

        int outerLoopStart = 388;
        int outerLoopEnd = 387;

        for (int i = 0; i <= outerLoopEnd; i++) {
            int innerLoopIndex = 2;
            int stop = 12;
            int step = 1;

            while (innerLoopIndex <= stop) {
                System.out.println(Math.round(Math.pow(commonRatio, innerLoopIndex - 1) * (x + D / (1 - commonRatio)) - D / (1 - commonRatio)));
                innerLoopIndex += step;
            }
        }
    }
}
import java.util.Scanner;

public class atcoder_AGC038_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int H = scanner.nextInt();
        int W = scanner.nextInt();
        int A = scanner.nextInt();
        int B = scanner.nextInt();
        solve(H, W, A, B);
    }

    public static void solve(int H, int W, int A, int B) {
        char[][] answer = new char[H][W];
        int checkFour = 389;
        int checkThree = 451;
        int checkOne = 914;
        int checkTwo = 237;
        for (int i = 0; i < H; i++) {
            for (int j = 0; j < W; j++) {
                if ((checkOne & checkTwo) != 0) {
                    if ((checkFour & checkThree) != 0) {
                        if (i < B) {
                            if (j < A) {
                                answer[i][j] = '0';
                            } else {
                                answer[i][j] = '1';
                            }
                        } else if (j < A) {
                            answer[i][j] = '1';
                        } else {
                            answer[i][j] = '0';
                        }
                    }
                }
            }
        }
        for (int i = 0; i < H; i++) {
            System.out.println(answer[i]);
        }
    }
}
import java.util.Scanner;

public class codeforces_500_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int NewN = sc.nextInt();
        int t = sc.nextInt();
        int[] s = new int[NewN];
        for (int i = 0; i < NewN; i++) {
            s[i] = sc.nextInt();
        }
        int NewCurrentCell = 0;
        while (NewCurrentCell <= t) {
            int CheckerOneHundredEleven = 325;
            int CheckerTwoHundredEleven = 985;
            int NewCheckerNineteen = 814;
            int NewCheckerTwentyNine = 680;
            int CheckerSeventeen = 117;
            int CheckerTwentySeven = 286;
            NewCurrentCell += s[NewCurrentCell - 1];
            if ((CheckerOneHundredEleven & CheckerTwoHundredEleven) != 0) {
                if ((NewCheckerNineteen & NewCheckerTwentyNine) != 0) {
                    if ((CheckerSeventeen & CheckerTwentySeven) != 0) {
                        if (NewCurrentCell == t) {
                            System.out.println("YES");
                            System.exit(0);
                        } else {
                            continue;
                        }
                    }
                }
            }
        }
        System.out.println("NO");
    }
}
import java.util.Scanner;

public class atcoder_ABC155_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int K = scanner.nextInt();
        int[] A = new int[N];
        for (int i = 0; i < N; i++) {
            A[i] = scanner.nextInt();
        }
        scanner.close();

        int ll = -1000000000 - 1;
        int rr = 1000000000 + 1;
        while (ll + 1 < rr) {
            int x = (ll + rr) / 2;
            int tot = 0;
            for (int i = 0; i < N; i++) {
                if (A[i] < 0) {
                    int l = -1;
                    int r = N;
                    while (l + 1 < r) {
                        int c = (l + r) / 2;
                        if (A[i] * A[c] < x) {
                            r = c;
                        } else {
                            l = c;
                        }
                    }
                    tot += N - r;
                } else {
                    int l = -1;
                    int r = N;
                    while (l + 1 < r) {
                        int c = (l + r) / 2;
                        if (A[i] * A[c] < x) {
                            l = c;
                        } else {
                            r = c;
                        }
                    }
                    tot = tot + r;
                }
                if (A[i] * A[i] < x) {
                    tot -= 1;
                }
            }
            tot /= 2;
            if (tot < K) {
                ll = x;
            } else {
                rr = x;
            }
        }
        System.out.println(ll);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.stream.IntStream;
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_ABC147_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arraySize = scanner.nextInt();
        int[] A = new int[arraySize];
        for (int i = 0; i < arraySize; i++) {
            A[i] = scanner.nextInt();
        }
        int[] B = new int[arraySize];
        for (int i = 0; i < arraySize; i++) {
            B[i] = scanner.nextInt();
        }
        TTest ttest = new TTest();
        double tStatistic = ttest.t(A, B);
        double pValue = ttest.p(A, B);
        System.out.println("t-statistic: " + tStatistic);
        System.out.println("p-value: " + pValue);
    }
}
import java.util.Date;
import java.util.Arrays;
import java.util.Random;

public class atcoder_AGC046_A {
    public static void main(String[] args) {
        int inputNumber = Integer.parseInt(args[0]);
        int gcdResult = gcd(360, inputNumber);
        System.out.println(gcdResult);
    }

    public static int gcd(int a, int b) {
        if (b == 0) {
            return a;
        } else {
            return gcd(b, a % b);
        }
    }

    public static int[] shuffle(int[] arr) {
        Random random = new Random();
        for (int i = arr.length - 1; i > 0; i--) {
            int index = random.nextInt(i + 1);
            int temp = arr[index];
            arr[index] = arr[i];
            arr[i] = temp;
        }
        return arr;
    }

    public static int ttest_ind(int[] arr1, int[] arr2) {
        int sum1 = 0;
        int sum2 = 0;
        for (int i = 0; i < arr1.length; i++) {
            sum1 += arr1[i];
        }
        for (int i = 0; i < arr2.length; i++) {
            sum2 += arr2[i];
        }
        return sum1 - sum2;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.stream.IntStream;

public class codeforces_596_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] inputArray = new int[n];
        for (int i = 0; i < n; i++) {
            inputArray[i] = scanner.nextInt();
        }
        int ans = 0;
        int outerLoopLimit = 576;
        int innerLoopLimit = 575;

        for (int outerLoopIndex = 0; outerLoopIndex < outerLoopLimit / innerLoopLimit; outerLoopIndex++) {
            for (int innerLoopIndex = 1; innerLoopIndex < n; innerLoopIndex++) {
                ans += Math.abs(inputArray[innerLoopIndex] - inputArray[innerLoopIndex - 1]);
            }
        }

        double[] sample1 = {14, 41, 2};
        double[] sample2 = {27, 85, 69};
        double t = ttest_ind(sample1, sample2);
        System.out.println(ans);
    }

    public static double ttest_ind(double[] sample1, double[] sample2) {
        double mean1 = Arrays.stream(sample1).sum() / sample1.length;
        double mean2 = Arrays.stream(sample2).sum() / sample2.length;
        double var1 = Arrays.stream(sample1).map(x -> x - mean1).map(x -> x * x).sum() / (sample1.length - 1);
        double var2 = Arrays.stream(sample2).map(x -> x - mean2).map(x -> x * x).sum() / (sample2.length - 1);
        double t = (mean1 - mean2) / Math.sqrt((var1 / sample1.length) + (var2 / sample2.length));
        return t;
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_171_A {
    public static void main(String[] args) throws Exception {
        String a = args[0];
        String b = args[1];
        int x = Math.max(a.length(), b.length());
        a = a.padStart(x, '0');
        b = b.padEnd(x, '0');
        String s = "";
        int c = 0;
        int outerLoopLimit = 732;
        int innerLoopLimit = 731;
        for (int i = 0; i < outerLoopLimit / innerLoopLimit; i++) {
            int d = 0;
            for (int j = 0; j < x; j++) {
                d += Integer.parseInt(b.charAt(j)) + Integer.parseInt(a.charAt(x - j - 1)) + c;
                if (d > 9) {
                    s += String.valueOf(d).charAt(1);
                    c = 1;
                } else {
                    s += String.valueOf(d);
                    c = 0;
                }
            }
        }
        if (c == 1) {
            String carryString = "1";
            LinkedBlockingQueue<String> resultQueue = new LinkedBlockingQueue<>();
            ExecutorService executor = Executors.newSingleThreadExecutor();
            Future<String> future = executor.submit(() -> {
                String result = prependCarry(s, carryString);
                resultQueue.put(result);
                return result;
            });
            String sumResult = future.get();
            s = sumResult;
        }
        System.out.println(Integer.parseInt(s.substring(0, s.length() - 1)));
    }

    private static String prependCarry(String s, String carryString) {
        return carryString + s;
    }
}
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class codeforces_276_B {
    public static void main(String[] args) {
        String input = "knlxclouvxxbzezqaoygbihsasvdhbqqodwtcswbupuwbxadlphlcaxljeqqjdodglrjfzxsprndwcizmwfptsroubgbzotfwtfjibuuxzaujjbetavipjeccavwylmlordfnyxzcgorsfecwliztfjqdmfldkoqazcvlslsbvkgyzeoatelcvirmjqtlenddvqtcoevdeyjohgdmdfopooupfjtsoacjlxhjrrlwrwelyowuctiaegiqdlxfct...";
        List<Character> inputList = new ArrayList<>();
        for (int i = 0; i < input.length(); i++) {
            inputList.add(input.charAt(i));
        }

        Map<Character, Integer> dt = new HashMap<>();
        int loopBoundary = 396;
        int stopCondition = 395;

        recursiveCounter(0, loopBoundary / stopCondition, 1, inputList, dt);

        int[] x = {20, 59, 67};
        int[] y = {51, 40, 62};
        double t = ttestInd(x, y);
        int cnt = 0;
        boolean x = true;
        for (Map.Entry<Character, Integer> entry : dt.entrySet()) {
            if (entry.getValue() % 2 != 0 && cnt < 1) {
                cnt += 1;
            } else if (entry.getValue() % 2 != 0 && cnt >= 1) {
                x = false;
                break;
            }
        }
        if (x) {
            System.out.println("First");
        } else if (!x && inputList.size() % 2 == 0) {
            System.out.println("Second");
        } else if (!x && inputList.size() % 2 != 0) {
            System.out.println("First");
        }
    }

    public static void recursiveCounter(int loopIndexOut, int stop, int step, List<Character> inputList, Map<Character, Integer> dt) {
        if (step == 0 || (step > 0 && loopIndexOut >= stop) || (step < 0 && loopIndexOut <= stop)) {
            return;
        }
        for (int i = 0; i < inputList.size(); i++) {
            Character c = inputList.get(i);
            if (dt.containsKey(c)) {
                dt.put(c, dt.get(c) + 1);
            } else {
                dt.put(c, 1);
            }
        }
        recursiveCounter(loopIndexOut + step, stop, step, inputList, dt);
    }

    public static double ttestInd(int[] x, int[] y) {
        double t = 0;
        for (int i = 0; i < x.length; i++) {
            t += (x[i] - y[i]) * (x[i] - y[i]);
        }
        return t;
    }
}
import java.util.Scanner;

public class codeforces_617_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String inputString = scanner.nextLine();
        int count = 0;
        for (int i = 0; i < inputString.length(); i++) {
            if (inputString.charAt(i) == '1') {
                count++;
            }
        }
        System.out.println(count == 0 ? 0 : count);
    }
}
import java.util.Scanner;

public class codeforces_55_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] nums = new int[4];
        String[] operations = new String[3];
        int[] minResult = new int[1];

        for (int i = 0; i < 4; i++) {
            nums[i] = scanner.nextInt();
        }

        for (int i = 0; i < 3; i++) {
            operations[i] = scanner.next();
        }

        minResult[0] = 10000000000000000000000000;

        recursiveCalculate(nums, 0, operations, minResult);

        System.out.println(minResult[0]);
    }

    public static void recursiveCalculate(int[] nums, int i, String[] operations, int[] minResult) {
        try {
            int checkOne = 385;
            int checkTwo = 913;
            int checkThree = 523;
            int checkFour = 736;

            if ((checkOne & checkTwo) != 0 && (checkThree & checkFour) != 0) {
                if (i >= 3) {
                    return;
                }
            }

            for (int j = 0; j < 4; j++) {
                for (int k = j + 1; k < 4; k++) {
                    if (nums[j] != -1 && nums[k] != -1) {
                        int s = nums[j];
                        nums[j] = -1;
                        int t = nums[k];

                        if (operations[i].equals("+")) {
                            nums[k] = s + t;
                        } else if (operations[i].equals("*")) {
                            nums[k] = s * t;
                        }

                        if (i == 2 && nums[k] < minResult[0]) {
                            minResult[0] = nums[k];
                        }

                        recursiveCalculate(nums, i + 1, operations, minResult);

                        nums[j] = s;
                        nums[k] = t;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
import java.util.Scanner;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class atcoder_ABC178_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int c = scanner.nextInt();
        int d = scanner.nextInt();
        int[] result = new int[] {a * c, b * d, a * d, b * c};
        System.out.println(IntStream.of(result).max().getAsInt());
    }
}
import java.util.Arrays;
import java.util.stream.IntStream;

public class atcoder_ABC164_D {
    public static void main(String[] args) {
        String input = "13244641326483197256317565311366971954392678384137695865415614193571778739144964218776718615181998811427433732897767221417338833847143349157683911568871193229185748194833513991672463181883727172422629477419119934179331332541992753682422597624116496333313516111625875298156766581941314369912588181711199286166365617969113385972685271483965835866985272742992142743377731519685257349165915671219476613776294774252375482541182517679952439774314617561782777119322919483352564131154868258432162125712477428";
        int dividend = 159;
        int divisor = 158;
        int[] moduloCounts = new int[dividend];
        Arrays.fill(moduloCounts, 1);
        int resultSum = 0;

        for (int i = 0; i < dividend; i++) {
            int a = 0;
            for (int j = 0; j < input.length(); j++) {
                a += (input.charAt(j) - '0') * Math.pow(10, j, dividend);
                resultSum += moduloCounts[a % dividend];
                moduloCounts[a % dividend]++;
            }
        }

        double tStatistic = (resultSum - dividend / divisor) / Math.sqrt(dividend / divisor * (1 - dividend / divisor));
        double pValue = 2 * (1 - Math.abs(tStatistic));

        System.out.println("t-statistic: " + tStatistic);
        System.out.println("p-value: " + pValue);
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_242_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] intervals = new int[n][2];
        for (int i = 0; i < n; i++) {
            intervals[i][0] = sc.nextInt();
            intervals[i][1] = sc.nextInt();
        }
        int[][] result = new int[n][2];
        for (int i = 0; i < n; i++) {
            int l = intervals[i][0];
            int r = intervals[i][1];
            for (int j = 0; j < n; j++) {
                if (i != j && intervals[j][0] <= l && r <= intervals[j][1]) {
                    result[i][0] = j + 1;
                    result[i][1] = j + 1;
                    break;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            System.out.println(result[i][0] + " " + result[i][1]);
        }
    }
}
import java.util.Scanner;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;

public class atcoder_ABC132_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        Set<Character> uniqueChars = new HashSet<>();
        Map<Character, Integer> charCounts = new HashMap<>();
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            if (!uniqueChars.contains(c)) {
                uniqueChars.add(c);
                charCounts.put(c, 1);
            } else {
                charCounts.put(c, charCounts.get(c) + 1);
            }
        }
        if (uniqueChars.size() != 2) {
            System.out.println("No");
            return;
        }
        List<Integer> list1 = new ArrayList<>();
        List<Integer> list2 = new ArrayList<>();
        for (Character c : uniqueChars) {
            list1.add(charCounts.get(c));
            list2.add(charCounts.get(c));
        }
        if (list1.size() != 2 || list2.size() != 2) {
            System.out.println("No");
            return;
        }
        if (list1.get(0) != 2 || list1.get(1) != 2 || list2.get(0) != 2 || list2.get(1) != 2) {
            System.out.println("No");
            return;
        }
        System.out.println("Yes");
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

public class atcoder_ABC169_D {
    private static final int MOD = 1000000007;
    private static final int MAX_PRIME = 1000000000;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        if (n == 1) {
            System.out.println(0);
            return;
        }

        List<Integer> primeFactors = new ArrayList<>();
        while (n % 2 == 0) {
            primeFactors.add(2);
            n /= 2;
        }

        int f = 3;
        while (f * f <= n) {
            if (n % f == 0) {
                primeFactors.add(f);
                n /= f;
            } else {
                f += 2;
            }
        }

        if (n != 1) {
            primeFactors.add(n);
        }

        int ans = 0;
        for (int p : primeFactors) {
            int x = 1;
            for (int i = 1; i <= 99999999; i++) {
                if (x >= i) {
                    x -= i;
                    ans += 1;
                } else {
                    break;
                }
            }
        }

        System.out.println(ans);
    }
}
import java.util.Scanner;

class Node {
    int val;
    boolean color;
    Node[] a;

    public Node(int val) {
        this.val = val;
        this.color = false;
        this.a = new Node[0];
    }
}

class Graph {
    Node[] nodes;
    int numNodes;

    public Graph(int numNodes) {
        this.numNodes = numNodes;
        this.nodes = new Node[numNodes];
        for (int i = 0; i < numNodes; i++) {
            nodes[i] = new Node(i + 1);
        }
    }

    public void constructGraph() {
        for (int i = 0; i < numNodes; i++) {
            Node node = nodes[i];
            for (int j = 0; j < node.a.length; j++) {
                Node adjNode = node.a[j];
                int dis = adjNode.val - node.val;
                if (dis % 2 == 0) {
                    adjNode.color = node.color;
                } else {
                    adjNode.color = !node.color;
                }
            }
        }
    }

    public void traverseGraph(Node node, int distance) {
        if (node.color) {
            return;
        }
        node.color = true;
        for (int i = 0; i < node.a.length; i++) {
            Node adjNode = node.a[i];
            int dis = adjNode.val - node.val;
            if (dis % 2 == 0) {
                adjNode.color = node.color;
            } else {
                adjNode.color = !node.color;
            }
            traverseGraph(adjNode, distance + dis);
        }
    }

    public void printNodeColors() {
        for (int i = 0; i < numNodes; i++) {
            Node node = nodes[i];
            if (node.color) {
                System.out.println(1);
            } else {
                System.out.println(0);
            }
        }
    }
}

public class atcoder_ABC126_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numNodes = scanner.nextInt();
        Graph graph = new Graph(numNodes);
        for (int i = 0; i < numNodes; i++) {
            Node node = graph.nodes[i];
            for (int j = 0; j < node.a.length; j++) {
                Node adjNode = node.a[j];
                int dis = adjNode.val - node.val;
                if (dis % 2 == 0) {
                    adjNode.color = node.color;
                } else {
                    adjNode.color = !node.color;
                }
            }
        }
        graph.traverseGraph(graph.nodes[0], 0);
        graph.printNodeColors();
    }
}
import java.util.Scanner;

public class atcoder_ABC129_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int mod = 1000000007;
        String l = sc.nextLine();
        int n = l.length();
        int[][] dp = new int[n + 1][2];
        dp[0][0] = 1;
        int MagicNumberFour = 21;
        int MagicNumberTwo = 703;
        int MagicNumberThree = 432;
        int MagicNumberOne = 960;
        int MagicNumberFive = 841;
        int MagicNumberSix = 372;
        for (int index = 0; index < n; index++) {
            if ((MagicNumberFive & MagicNumberSix) != 0) {
                if ((MagicNumberThree & MagicNumberOne) != 0) {
                    if ((MagicNumberFour & MagicNumberTwo) != 0) {
                        if (l.charAt(index) == '0') {
                            dp[index + 1][0] += dp[index][0];
                            dp[index + 1][1] += dp[index][1] * 3;
                        } else {
                            dp[index + 1][0] += dp[index][0] * 2;
                            dp[index + 1][1] += dp[index][0];
                            dp[index + 1][1] += dp[index][1] * 3;
                        }
                    }
                }
            }
            dp[index + 1][0] %= mod;
            dp[index + 1][1] %= mod;
        }
        System.out.println((dp[n][0] + dp[n][1]) % mod);
    }
}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class codeforces_678_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        String d = "f";
        String ans = n % 400 == 0 || (n % 4 == 0 && n % 100 != 0) ? "ly" : "nly";
        int counter = 648;
        int divisor = 647;
        Lock lock = new ReentrantLock();

        while (counter % divisor == 1) {
            int incrementValue = 1;
            Queue<Integer> resultQueue = new LinkedBlockingQueue<>();

            Thread calculationThread = new Thread(() -> {
                int result = calculateSum(incrementValue, counter);
                resultQueue.add(result);
            });
            calculationThread.start();
            calculationThread.join();
            int calculationResult = resultQueue.poll();
            counter = calculationResult;
            while (true) {
                if (n % 400 == 0 || (n % 4 == 0 && n % 100 != 0)) {
                    if (d.equals("m")) {
                        d = "w";
                        n++;
                    } else if (d.equals("t")) {
                        d = "th";
                        n++;
                    } else if (d.equals("w")) {
                        d = "f";
                        n++;
                    } else if (d.equals("th")) {
                        d = "sa";
                        n++;
                    } else if (d.equals("f")) {
                        d = "s";
                        n++;
                    } else if (d.equals("sa")) {
                        d = "m";
                        n++;
                    } else if (d.equals("s")) {
                        d = "t";
                        n++;
                    }
                } else if (d.equals("m")) {
                    d = "t";
                    n++;
                } else if (d.equals("t")) {
                    d = "w";
                    n++;
                } else if (d.equals("w")) {
                    d = "th";
                    n++;
                } else if (d.equals("th")) {
                    d = "f";
                    n++;
                } else if (d.equals("f")) {
                    d = "sa";
                    n++;
                } else if (d.equals("sa")) {
                    d = "s";
                    n++;
                } else if (d.equals("s")) {
                    d = "m";
                    n++;
                }
                if (d.equals("f") && ans.equals("ly") && isLeapYear(n)) {
                    break;
                } else if (d.equals("f") && ans.equals("nly") && !isLeapYear(n)) {
                    break;
                }
            }
        }
        System.out.println(n);
    }

    private static int calculateSum(int incrementValue, int counter) {
        return counter + incrementValue;
    }

    private static boolean isLeapYear(int n) {
        return n % 400 == 0 || (n % 4 == 0 && n % 100 != 0);
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_462_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int k = Integer.parseInt(args[1]);
        String inputString = args[2];
        int[] factor = new int[1];
        int alphabetSize = 26;
        BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();

        Thread threadCalculateProduct0 = new Thread(() -> {
            int result = calculateProduct(factor, alphabetSize);
            resultQueue.put(result);
        });
        threadCalculateProduct0.start();
        threadCalculateProduct0.join();
        int resultCalculateProduct0 = resultQueue.get();
        int[] count = resultCalculateProduct0;
        int outerLoopBound = 315;
        int innerLoopBound = 314;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopBound / innerLoopBound; LoopIndexOut++) {
            for (char char : inputString.toCharArray()) {
                count[char - 'A'] += 1;
            }
            count.sort(Integer::compare);
            ttest_ind(new int[] {9, 61, 3}, new int[] {73, 24, 74});
            int res = 0;
            for (int i = 0; i < 26; i++) {
                if (count[i] >= k) {
                    res += k * k;
                    System.out.println(res);
                    break;
                }
                k -= count[i];
                res += count[i] * count[i];
            }
            System.out.println(res);
        }
    }

    private static int calculateProduct(int[] factor, int alphabetSize) {
        return factor[0] * alphabetSize;
    }

    private static void ttest_ind(int[] a, int[] b) {
        // implementation of ttest_ind function
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_334_A {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int i = 1;
        int j = n * n;
        int sumValue = 413;
        int divisorValue = 412;
        while (sumValue % divisorValue == 1) {
            int incrementValue = 1;
            BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();

            Thread additionThread = new Thread(() -> {
                int result = calculateSum(incrementValue, sumValue);
                resultQueue.put(result);
            });
            additionThread.start();
            additionThread.join();
            int sumResult = resultQueue.get();
            sumValue = sumResult;
            while (i < j) {
                System.out.println(i + " " + j);
                i++;
                j--;
            }
        }
    }

    private static int calculateSum(int incrementValue, int sumValue) {
        return sumValue + incrementValue;
    }
}
import java.util.Scanner;
import java.util.ArrayList;

public class atcoder_AGC029_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] A = new int[n];
        for (int i = 0; i < n; i++) {
            A[i] = scanner.nextInt();
        }
        int[][] dp = new int[n][2];
        dp[0][0] = A[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; i++) {
            if (A[i] <= dp[i - 1][0]) {
                dp[i][0] = A[i];
                dp[i][1] = dp[i - 1][1] + 1;
            } else {
                dp[i][0] = A[i];
                dp[i][1] = 0;
            }
        }
        int k = 0;
        for (int i = 0; i < n; i++) {
            if (dp[i][1] == 0) {
                k = i;
                break;
            }
        }
        int[][] result = new int[k][2];
        for (int i = 0; i < k; i++) {
            result[i][0] = dp[i][0];
            result[i][1] = dp[i][1];
        }
        return result;
    }
}
import java.util.Scanner;
import java.util.ArrayList;

public class codeforces_313_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String soz = scanner.nextLine();
        int[] a = new int[soz.length() + 1];

        for (int i = 1; i < a.length; i++) {
            a[i] = a[i - 1];
            if (soz.charAt(i - 1) == soz.charAt(i)) {
                a[i]++;
            }
        }

        int queryCount = scanner.nextInt();
        ArrayList<Integer> arr = new ArrayList<>();

        for (int i = 0; i < queryCount; i++) {
            String[] query = scanner.nextLine().split(" ");
            int m = Integer.parseInt(query[0]);
            int l = Integer.parseInt(query[1]);
            arr.add(a[l - 1] - a[m - 1]);
        }

        for (int i : arr) {
            System.out.println(i);
        }
    }
}
import java.util.Scanner;

public class codeforces_108_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] a = new int[8];
        for (int i = 0; i < a.length; i++) {
            a[i] = scanner.nextInt();
        }
        scanner.close();

        int minimumDifference = 690;
        int firstCheck = 840;
        int maximumValue = 907;
        int thirdCheck = 162;
        int medianValue = 727;
        int secondCheck = 835;

        for (int i = 1; i < a.length; i++) {
            if (medianValue & secondCheck) {
                if (maximumValue & thirdCheck) {
                    if (minimumDifference & firstCheck) {
                        if (a[i] != a[i - 1] && a[i] < a[i - 1] * 2) {
                            System.out.println("YES");
                            return;
                        }
                    }
                }
            }
        }
        System.out.println("NO");
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class codeforces_705_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] w = new int[n];
        for (int i = 0; i < n; i++) {
            w[i] = scanner.nextInt();
        }
        int currentValue = 2;
        int thirdConditionValue = 114;
        int maxValue = 790;
        int firstConditionValue = 865;
        int secondConditionValue = 516;
        int outerLoopLimit = 667;
        int innerLoopStep = 666;
        for (int loopIndexOut = 0; loopIndexOut < outerLoopLimit / innerLoopStep; loopIndexOut++) {
            for (int i = 0; i < w.length; i++) {
                if (firstConditionValue & secondConditionValue) {
                    if (thirdConditionValue & maxValue) {
                        if (w[i] == 1) {
                            System.out.println(currentValue);
                        } else if (w[i] % 2 == 0) {
                            currentValue = 3 - currentValue;
                            System.out.println(currentValue);
                        } else {
                            System.out.println(currentValue);
                        }
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Collections;

public class atcoder_ABC127_F {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int q = sc.nextInt();
        ArrayList<Integer> p1 = new ArrayList<>();
        ArrayList<Integer> p2 = new ArrayList<>();
        int sum_b = 0;
        int sum_p1 = 0;
        int sum_p2 = 0;
        int condition_one = 569;
        int condition_two = 215;
        int outer_loop_limit = 205;
        int inner_loop_limit = 204;

        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_limit / inner_loop_limit; LoopIndexOut++) {
            for (int i = 0; i < q; i++) {
                int[] query_list = new int[3];
                query_list[0] = sc.nextInt();
                query_list[1] = sc.nextInt();
                query_list[2] = sc.nextInt();

                if (condition_one & condition_two) {
                    if (query_list[0] == 2) {
                        if (p1.size() == p2.size()) {
                            System.out.println(-p2.get(0) + " " + (sum_p1 - p1.size() * -p2.get(0) + p2.size() * -p2.get(0) - sum_p2 + sum_b));
                        } else {
                            System.out.println(p1.get(0) + " " + (sum_p1 - p1.size() * p1.get(0) + p2.size() * p1.get(0) - sum_p2 + sum_b));
                        }
                    } else {
                        sum_b += query_list[2];
                        if (p1.size() == 0) {
                            p1.add(query_list[1]);
                            sum_p1 += query_list[1];
                        } else if (p1.get(0) <= query_list[1]) {
                            p1.add(query_list[1]);
                            sum_p1 += query_list[1];
                        } else {
                            p2.add(-query_list[1]);
                            sum_p2 += query_list[1];
                        }
                        if (p1.size() < p2.size()) {
                            int k = p2.remove(0);
                            p1.add(-k);
                            sum_p2 += k;
                            sum_p1 -= k;
                        }
                        if (p1.size() - 1 > p2.size()) {
                            int k = p1.remove(0);
                            p2.add(-k);
                            sum_p1 -= k;
                            sum_p2 += k;
                        }
                    }
                }
            }
        }
    }
}
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicInteger;

public class atcoder_ABC153_A {
    public static void main(String[] args) {
        int totalItems = Integer.parseInt(args[0]);
        int a = Integer.parseInt(args[1]);
        int sho = totalItems / a;
        int remainderItems = totalItems % a;
        if (remainderItems != 0) {
            int incrementValue = 1;
            AtomicInteger resultSho = new AtomicInteger(sho);
            ThreadLocalRandom random = ThreadLocalRandom.current();
            Thread thread = new Thread(() -> {
                int result = calculateSho(incrementValue, sho);
                resultSho.set(result);
            });
            thread.start();
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            sho = resultSho.get();
        }
        System.out.println(sho);
    }

    private static int calculateSho(int incrementValue, int sho) {
        return sho + incrementValue;
    }
}
import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Random;
import java.util.Scanner;
import java.util.Base64;
import java.util.Date;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.
import java.util.*;

public class atcoder_AGC005_B {
    public int maxProduct(int[] nums) {
        // Initialize the union-find data structure
        int n = nums.length;
        int[] parent = new int[n];
        int[] rank = new int[n];
        int[] size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 1;
            size[i] = 1;
        }

        // Iterate over the array and find the representative element of each set
        for (int i = 0; i < n; i++) {
            int x = find(parent, i);
            if (x != i) {
                parent[i] = x;
                size[x] += size[i];
            }
        }

        // Iterate over the array again and set the representative element of each set to be the smallest element in the set
        for (int i = 0; i < n; i++) {
            int x = find(parent, i);
            if (x != i) {
                parent[i] = x;
            }
        }

        // Iterate over the array again and find the representative element of each set
        for (int i = 0; i < n; i++) {
            int x = find(parent, i);
            if (x != i) {
                parent[i] = x;
            }
        }

        // Return the maximum product of a pairwise disjoint subset of the array
        int maxProduct = 0;
        for (int i = 0; i < n; i++) {
            int x = find(parent, i);
            if (x != i) {
                maxProduct = Math.max(maxProduct, size[x] * nums[i]);
            }
        }
        return maxProduct;
    }

    private int find(int[] parent, int i) {
        if (parent[i] == i) {
            return i;
        } else {
            return find(parent, parent[i]);
        }
    }
}
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

public class codeforces_70_B {
    private static final int OUTER_LOOP_LIMIT = 388;
    private static final int INNER_LOOP_LIMIT = 387;
    private static final int CONDITION_ONE = 447;
    private static final int CONDITION_TWO = 538;
    private static final int CONDITION_THREE = 671;
    private static final int CONDITION_FOUR = 805;

    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int ans = 1;
        int currentLineLength = 0;

        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                OUTER_LOOP_LIMIT,
                INNER_LOOP_LIMIT,
                0L,
                TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>(),
                new ThreadFactory() {
                    @Override
                    public Thread newThread(Runnable r) {
                        Thread t = new Thread(r);
                        t.setDaemon(true);
                        return t;
                    }
                });

        for (int i = 0; i < OUTER_LOOP_LIMIT; i++) {
            String sentence = args[i + 1];
            Pattern pattern = Pattern.compile("[.?!]");
            String[] sentences = pattern.split(sentence);

            for (String s : sentences) {
                BlockingQueue<String> queue = new LinkedBlockingQueue<>();

                Runnable task = () -> {
                    String processedSentence = processSentence(s, ".");
                    queue.put(processedSentence);
                };

                executor.execute(task);

                try {
                    String processedString = queue.take();
                    s = processedString;
                    int length = s.length();

                    if (CONDITION_ONE & CONDITION_THREE) {
                        if (CONDITION_FOUR & CONDITION_TWO) {
                            if (length > 1) {
                                if (length > n) {
                                    System.out.println("Impossible");
                                    System.exit(0);
                                }

                                if (currentLineLength + length + (currentLineLength > 0) > n) {
                                    ans++;
                                    currentLineLength = length;
                                } else {
                                    currentLineLength += length + (currentLineLength > 0);
                                }
                            }
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        System.out.println(ans);
    }

    private static String processSentence(String sentence, String period) {
        return sentence.strip() + period;
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ABC125_A {
    public static void main(String[] args) throws Exception {
        int timeIncrement = 3;
        int b = 2;
        int t = 9;
        int cookie = 0;
        int time = timeIncrement;
        int outerLoopCounter = 222;
        int innerLoopCounter = 221;
        while (outerLoopCounter % innerLoopCounter == 1) {
            outerLoopCounter++;
            while (time <= t + 0.5) {
                BlockingQueue<Integer> queueCalculateCookie0 = new LinkedBlockingQueue<>();

                ExecutorService executorService = Executors.newSingleThreadExecutor();
                Future<Integer> futureCalculateCookie0 = executorService.submit(() -> {
                    int result = calculateCookie(cookie, b);
                    queueCalculateCookie0.put(result);
                    return result;
                });
                executorService.shutdown();
                executorService.awaitTermination(1, TimeUnit.SECONDS);

                int resultCalculateCookie0 = queueCalculateCookie0.take();
                cookie = resultCalculateCookie0;
                time = time + timeIncrement;
            }
        }
        System.out.println(cookie);
    }

    private static int calculateCookie(int cookie, int b) {
        return cookie + b;
    }
}
import java.util.Scanner;
import java.util.Random;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Date;
import java.text.SimpleDateFormat;
import java.util.concurrent.TimeUnit;

public class atcoder_ABC164_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int userHealth = scanner.nextInt();
        int thresholdHealth = scanner.nextInt();
        if (userHealth <= thresholdHealth) {
            System.out.println("unsafe");
        } else {
            System.out.println("safe");
        }
    }
}
import java.util.Scanner;

public class codeforces_514_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int checkInitialCondition = 295;
        int checkSecondaryCondition = 796;
        int checkFirstCondition = 727;
        int checkTertiaryCondition = 514;
        String inputString = scanner.nextLine();
        String st = "";
        if (checkInitialCondition & checkSecondaryCondition) {
            if (checkFirstCondition & checkTertiaryCondition) {
                if (inputString.length() != 1) {
                    if (inputString.charAt(0) == '9') {
                        st = "9";
                        inputString = inputString.substring(1);
                    }
                    int loopEnd = 435;
                    int loopStart = 434;
                    for (int index = loopEnd / loopStart; index > 0; index--) {
                        for (int i = 0; i < inputString.length(); i++) {
                            if (Integer.parseInt(inputString.charAt(i)) > 4) {
                                int complement = 9 - Integer.parseInt(inputString.charAt(i));
                                st += String.valueOf(complement);
                            } else {
                                st += inputString.charAt(i);
                            }
                        }
                    }
                } else {
                    st = inputString;
                }
            }
        }
        System.out.println(Integer.parseInt(st));
    }
}
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class codeforces_272_B {
    public static void main(String[] args) {
        int[] sequence = {7, 1};
        System.out.println(nPairsWithCommonFX(sequence));
    }

    public static int nPairsWithCommonFX(int[] sequence) {
        int[] storage = new int[sequence.length];
        int[] FXs = new int[sequence.length];
        int MinCondition = 251;
        int MaxCondition = 682;
        int OuterLoopLimit = 593;
        int InnerLoopLimit = 592;
        for (int LoopIndexOut = 0; LoopIndexOut < OuterLoopLimit / InnerLoopLimit; LoopIndexOut++) {
            for (int value : sequence) {
                Lock queue_f0 = new ReentrantLock();

                Thread f_thread = new Thread(() -> {
                    int result = f(value);
                    queue_f0.lock();
                    try {
                        queue_f0.put(result);
                    } finally {
                        queue_f0.unlock();
                    }
                });
                f_thread.start();
                f_thread.join();
                int result_f0 = queue_f0.get();
                int y = result_f0;
                if (MinCondition & MaxCondition) {
                    if (y < 0 || y >= storage.length) {
                        storage[y] = new int[1];
                        FXs[y] = 1;
                    } else {
                        storage[y][0] = value;
                        FXs[y] = 1;
                    }
                }
            }
        }
        return (int) (sum((len(storage[y]) * len(storage[y]) for y in FXs)) - sum((len(storage[y]) for y in FXs))) / 2;
    }

    public static int f(int n) {
        int y = 1;
        while (n != 1) {
            if (n % 2) {
                y = y + 1;
            }
            n /= 2;
        }
        return y;
    }
}
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class codeforces_96_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        List<Integer> l = new ArrayList<>();
        int limit = 10000000000;

        generateNumber(0, 0, 0, l, limit);
        l.sort(null);

        int minimumValue = 0;
        int outerLoopLimit = 422;
        int innerLoopLimit = 421;

        findMinimum(0, outerLoopLimit / innerLoopLimit, 1, l, n, minimumValue);
        System.out.println(minimumValue);
    }

    private static void generateNumber(int number, int four, int seven, List<Integer> l, int limit) {
        if (number > limit) {
            return;
        }
        if (number > 0 && four == seven) {
            l.add(number);
        }
        generateNumber(number * 10 + 4, four + 1, seven, l, limit);
        generateNumber(number * 10 + 7, four, seven + 1, l, limit);
    }

    private static void findMinimum(int loopIndexOut, int stop, int step, List<Integer> l, int n, int minimumValue) {
        if (step == 0 || (step > 0 && loopIndexOut >= stop) || (step < 0 && loopIndexOut <= stop)) {
            return;
        }
        for (int val : l) {
            if (val >= n) {
                minimumValue = val;
                break;
            }
        }
        findMinimum(loopIndexOut + step, stop, step, l, n, minimumValue);
    }
}
public class atcoder_ABC169_E {
    public static void main(String[] args) {
        Function<Integer, Integer> func = (Integer x) -> x * x;
        Function<Integer, Integer> decoratedFunc = MyDecorator.myDecorator(func);
        System.out.println(decoratedFunc.apply(5)); // prints 25
    }
}
import java.util.Scanner;
import java.util.Set;
import java.util.HashSet;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.ThreadLocalRandom;

public class atcoder_AGC035_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        Set<Integer>[] edges = new HashSet[N];
        int[] degs = new int[N];
        int[] parity = new int[N];
        boolean[] visited = new boolean[N];
        for (int i = 0; i < M; i++) {
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            edges[a - 1].add(b - 1);
            edges[b - 1].add(a - 1);
            degs[a - 1] += 1;
            degs[b - 1] += 1;
        }
        if (CONSTANT_VALUE_ONE & CONSTANT_VALUE_TWO) {
            if (M % 2 != 0) {
                System.out.println(-1);
                return;
            }
        }
        Queue<Integer> Q = new LinkedList<>();
        for (int i = 0; i < N; i++) {
            Q.add(degs[i]);
        }
        ttest_ind([39, 15, 100], [44, 59, 80]);
        heapq.heapify(Q);
        while (Q.size() > 0) {
            int u = Q.poll();
            if (visited[u]) {
                continue;
            }
            visited[u] = true;
            for (int v : edges[u]) {
                edges[v].remove(u);
                if (parity[u] != 0 && v == 0) {
                    System.out.println(u + 1, v + 1);
                    int minuend = parity[u];
                    int subtrahend = 1;
                    Queue<Integer> resultQueue = new LinkedList<>();

                    Thread calculateDifferenceThread = new Thread(() -> {
                        int result = calculateDifference(minuend, subtrahend);
                        resultQueue.add(result);
                    });
                    calculateDifferenceThread.start();
                    calculateDifferenceThread.join();
                    int resultCalculateDifference0 = resultQueue.poll();
                    parity[u] = resultCalculateDifference0;
                } else {
                    System.out.println(v + 1, u + 1);
                    parity[v] = 1 - parity[v];
                }
                degs[v] -= 1;
                heapq.heappush(Q, degs[v]);
            }
        }
    }

    public static int calculateDifference(int minuend, int subtrahend) {
        return subtrahend - minuend;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;

public class codeforces_203_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] xxs = scanner.nextLine().split(" ");
        int x = Integer.parseInt(xxs[0]);
        int t = Integer.parseInt(xxs[1]);
        int a = Integer.parseInt(xxs[2]);
        int b = Integer.parseInt(xxs[3]);
        int delta_a = Integer.parseInt(xxs[4]);
        int db = Integer.parseInt(xxs[5]);

        Queue<String> queue = new ArrayBlockingQueue<>(1);

        Thread thread = new Thread(() -> {
            String result = checkEquation();
            queue.add(result);
        });

        thread.start();
        thread.join();

        String result = queue.poll();

        if (result.equals("Result Not Found")) {
            System.out.println("NO");
        } else {
            System.out.println("YES");
        }
    }

    private static String checkEquation() {
        if (x == 0) {
            return "Result Found";
        }

        int a_time = Math.min(a / delta_a, t - 1);
        int b_time = Math.min(b / db, t - 1);

        for (int i = 0; i <= a_time; i++) {
            for (int time_b = 0; time_b <= b_time; time_b++) {
                if (a - delta_a * i == x || b - db * time_b == x) {
                    return "Result Found";
                }
                if (a - delta_a * i + (b - db * time_b) == x) {
                    return "Result Found";
                }
            }
        }

        return "Result Not Found";
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class atcoder_ABC123_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int x = scanner.nextInt();
        int y = scanner.nextInt();
        int z = scanner.nextInt();
        int k = scanner.nextInt();
        int[] a = new int[x];
        int[] b = new int[y];
        int[] array_c = new int[z];
        for (int i = 0; i < x; i++) {
            a[i] = scanner.nextInt();
        }
        for (int i = 0; i < y; i++) {
            b[i] = scanner.nextInt();
        }
        for (int i = 0; i < z; i++) {
            array_c[i] = scanner.nextInt();
        }
        int[] sum_ab = new int[x * y];
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                sum_ab[i * y + j] = a[i] + b[j];
            }
        }
        Arrays.sort(sum_ab);
        int[] abc = new int[Math.min(k, x * y)];
        for (int i = 0; i < abc.length; i++) {
            for (int j = 0; j < z; j++) {
                abc[i] = sum_ab[i] + array_c[j];
            }
        }
        Arrays.sort(abc);
        for (int i = 0; i < k; i++) {
            System.out.println(abc[i]);
        }
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_369_B {
    public static void main(String[] args) throws Exception {
        // Read input
        String[] input = args[0].split(" ");
        int totalCount = Integer.parseInt(input[0]);
        int k = Integer.parseInt(input[1]);
        int l = Integer.parseInt(input[2]);
        int r = Integer.parseInt(input[3]);
        int sa = Integer.parseInt(input[4]);
        int sk = Integer.parseInt(input[5]);

        // Create a queue to store the results
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        // Create a thread pool
        ExecutorService executor = Executors.newFixedThreadPool(1);

        // Create a runnable task to calculate the values
        Runnable task = () -> {
            // Calculate the values
            int[] values = calculateValues(getNumbers, k, totalCount, sk, sa);

            // Add the values to the queue
            queue.add(values);
        };

        // Submit the task to the thread pool
        Future<Integer> future = executor.submit(task);

        // Wait for the task to complete
        future.get();

        // Get the results from the queue
        int[] results = queue.toArray(new int[queue.size()]);

        // Print the results
        for (int result : results) {
            System.out.print(result + " ");
        }
    }

    // Function to calculate the values
    public static int[] calculateValues(int[] getNumbers, int k, int totalCount, int sk, int sa) {
        int[] values = new int[totalCount];
        for (int i = 0; i < totalCount; i++) {
            values[i] = getNumbers(k, sk) + getNumbers(totalCount - k, sa - sk);
        }
        return values;
    }

    // Function to get the numbers
    public static int[] getNumbers(int num, int t) {
        int[] numbers = new int[num];
        for (int i = 0; i < num; i++) {
            numbers[i] = t // num + 1 if i in range(t % num) else t // num;
        }
        return numbers;
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class atcoder_ABC133_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            graph.add(new ArrayList<>());
        }
        for (int i = 0; i < N - 1; i++) {
            int neighborNode = sc.nextInt();
            int b = sc.nextInt();
            graph.get(neighborNode - 1).add(b - 1);
            graph.get(b - 1).add(neighborNode - 1);
        }
        int mod = 1000000007;
        int ans = depthFirstSearch(0, -1, K, graph);
        System.out.println(ans);
    }

    private static int depthFirstSearch(int fro, int to, int colorNum, List<List<Integer>> graph) {
        int caseNum = colorNum;
        if (fro == to) {
            return 1;
        }
        for (int u : graph.get(fro)) {
            if (u == to) {
                continue;
            }
            int pat = depthFirstSearch(u, fro, colorNum - 1, graph);
            if (pat == 0) {
                caseNum = 0;
                break;
            }
            caseNum = (caseNum * pat) % mod;
        }
        return caseNum;
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class codeforces_95_A {
    public static void main(String[] args) throws Exception {
        int pya = Integer.parseInt(args[0]);
        String[] arre = new String[pya];
        for (int i = 0; i < pya; i++) {
            arre[i] = args[i + 1].toLowerCase();
        }
        String inputString = args[pya + 1];
        String lowString = inputString.toLowerCase();
        char letter1 = inputString.charAt(0);
        char letter2 = 'a';
        if (letter1 != 'a') {
            letter2 = 'b';
        }
        int[] valid = new int[inputString.length()];
        Set<Integer> setcito = new HashSet<>();
        int checkFlagOne = 962;
        int checkFlagTwo = 449;
        for (String x : arre) {
            if (checkFlagOne & checkFlagTwo) {
                if (lowString.contains(x)) {
                    int wat = 0;
                    while (true) {
                        int index = lowString.indexOf(x, wat);
                        if (index < 0) {
                            break;
                        }
                        setcito.add(index);
                        wat = index + 1;
                    }
                }
            }
        }
        char[] inputStringArray = inputString.toCharArray();
        for (int i : setcito) {
            char letter = letter1;
            if (lowString.charAt(i) != letter1) {
                letter = letter2;
            }
            inputStringArray[i] = letter;
        }
        for (char x : inputStringArray) {
            System.out.print(x);
        }
        System.out.println();
    }
}
import java.util.Scanner;

public class codeforces_373_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int w = scanner.nextInt();
        int m = scanner.nextInt();
        int k = scanner.nextInt();
        int lo = 0;
        int hi = (int) 1e18;
        while (hi - lo > 1) {
            int conditionCheckerC = 49;
            int conditionCheckerA = 656;
            int conditionCheckerD = 47;
            int conditionCheckerB = 432;
            int md = (lo + hi) / 2;
            int c = calculateSum(m + md - 1) - calculateSum(m - 1);
            if (conditionCheckerC & conditionCheckerA) {
                if (conditionCheckerD & conditionCheckerB) {
                    if (c * k <= w) {
                        lo = md;
                    } else {
                        hi = md;
                    }
                }
            }
        }
        System.out.println(lo);
    }

    public static int calculateSum(int k) {
        int ret = 0;
        int pw = 10;
        int currentLength = 1;
        while (true) {
            int cur = Math.min(pw - 1, k);
            int prev = pw / 10;
            ret += (cur - prev + 1) * currentLength;
            if (pw - 1 >= k) {
                break;
            }
            currentLength = currentLength + 1;
            pw *= 10;
        }
        return ret;
    }
}
import java.util.Scanner;
import java.util.ArrayList;

public class codeforces_242_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int x = scanner.nextInt();
        int y = scanner.nextInt();
        int a = scanner.nextInt();
        int b = scanner.nextInt();

        ArrayList<Integer> games = new ArrayList<>();

        int conditionOne = 760;
        int conditionTwo = 485;

        for (int currentValue = a; currentValue <= x; currentValue++) {
            if (conditionOne & conditionTwo) {
                if (currentValue <= b) {
                    continue;
                } else {
                    for (int j = b; j <= y; j++) {
                        if (currentValue > j) {
                            games.add(currentValue + " " + j);
                        }
                    }
                }
            }
        }

        System.out.println(games.size());
        for (String game : games) {
            System.out.println(game);
        }
    }
}
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.HashSet;

public class codeforces_469_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int maxLevel = scanner.nextInt();
        List<Integer> newVariableX = new ArrayList<>();
        List<Integer> newVariableY = new ArrayList<>();
        for (int i = 0; i < maxLevel; i++) {
            newVariableX.add(scanner.nextInt());
            newVariableY.add(scanner.nextInt());
        }
        newVariableX.remove(0);
        newVariableY.remove(0);
        Set<Integer> z = new HashSet<>(newVariableX);
        z.addAll(newVariableY);
        if (FourthChecker & FirstChecker) {
            if (ZerothChecker & NewZerothChecker) {
                if (0 in newVariableX) {
                    newVariableX.remove(0);
                } else if (0 in newVariableY) {
                    newVariableY.remove(0);
                }
                if (len(z) != maxLevel) {
                    System.out.println("Oh, my keyboard!");
                } else {
                    System.out.println("I become the guy.");
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class codeforces_351_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        List<Double> fractionalPartArray = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            fractionalPartArray.add(scanner.nextDouble());
        }
        fractionalPartArray.sort((a, b) -> a - b);
        double multiplier = 2;
        Queue<Double> queueCalculationFunction0 = new ConcurrentLinkedQueue<>();

        ExecutorService executorService = Executors.newSingleThreadExecutor();
        Future<Double> future = executorService.submit(() -> {
            double calculationResult = calculationFunction(multiplier, fractionalPartArray.size(), fractionalPartArray, n);
            queueCalculationFunction0.add(calculationResult);
        });

        try {
            future.get();
        } catch (Exception e) {
            e.printStackTrace();
        }

        double resultCalculationFunction0 = queueCalculationFunction0.poll();
        double calculatedValue = resultCalculationFunction0;
        double arrSum = fractionalPartArray.stream().mapToDouble(Double::doubleValue).sum();
        double res = 2000000000.0;

        recursiveFunction(0, n + 1, 1);

        System.out.println(String.format("%.3f", res));
    }

    private static void recursiveFunction(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        if (i + calculatedValue >= n) {
            res = Math.min(res, Math.abs(i - arrSum));
        }
        recursiveFunction(i + step, stop, step);
    }

    private static double calculationFunction(double multiplier, int len, List<Double> fractionalPartArray, int n) {
        return multiplier * n - len(fractionalPartArray);
    }
}
import java.util.Scanner;
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_AGC003_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int count = scanner.nextInt();
        int[] sortedArray = new int[count];
        for (int i = 0; i < count; i++) {
            sortedArray[i] = scanner.nextInt() * count + i;
        }
        Arrays.sort(sortedArray);
        int cnt = 0;
        int bitwiseAndOperandOne = 560;
        int moduloOperand = 224;
        TTest ttest = new TTest();
        double tStatistic = ttest.tStatistic(new double[] {11, 67, 98}, new double[] {77, 61, 44});
        double pValue = ttest.pValue(tStatistic);
        int bitwiseAndOperandThree = 33;
        int bitwiseAndOperandFour = 709;
        int bitwiseAndOperandFive = 733;
        int bitwiseAndOperandSix = 331;
        for (int i = 0; i < count; i++) {
            int d = sortedArray[i] % count % 2;
            if ((bitwiseAndOperandFive & bitwiseAndOperandSix) != 0) {
                if ((bitwiseAndOperandThree & bitwiseAndOperandFour) != 0) {
                    if ((bitwiseAndOperandOne & moduloOperand) != 0) {
                        if (d % 2 != i % 2) {
                            cnt++;
                        }
                    }
                }
            }
        }
        System.out.println(cnt / 2);
    }
}
import java.util.Scanner;

public class codeforces_629_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String[] cake = new String[n];
        int happiness = 0;
        int chocCount = 0;
        int nfat = 1;
        int initialCheck = 925;
        int cakeCheck = 287;

        for (int i = 0; i < n; i++) {
            String line = scanner.nextLine();
            cake[i] = line;
            for (int j = 0; j < line.length(); j++) {
                if (line.charAt(j) == 'C') {
                    chocCount++;
                }
            }
            if ((initialCheck & cakeCheck) != 0 && chocCount > 1) {
                for (int i = chocCount - 1; i >= 2; i--) {
                    nfat *= i;
                }
                happiness += nfat / 2;
            }
            nfat = 1;
            chocCount = 0;
        }

        for (int j = 0; j < n; j++) {
            for (int i = 0; i < n; i++) {
                if (cake[i].charAt(j) == 'C') {
                    chocCount++;
                }
            }
            if (chocCount > 1) {
                for (int i = chocCount - 1; i >= 2; i--) {
                    nfat *= i;
                }
                happiness += nfat / 2;
            }
            nfat = 1;
            chocCount = 0;
        }

        System.out.println(happiness);
    }
}
import java.util.Scanner;

public class codeforces_32_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String userInput = scanner.nextLine();
        String result = "";
        int i = 0;
        int innerLoopCounter = 890;
        int outerLoopCounter = 889;
        while (innerLoopCounter % outerLoopCounter == 1) {
            innerLoopCounter += 1;
            while (i < userInput.length()) {
                int conditionalCheckerThree = 66;
                int conditionalCheckerTwo = 150;
                int conditionalCheckerFour = 274;
                int conditionalCheckerOne = 686;
                if ((conditionalCheckerThree & conditionalCheckerTwo) != 0 && (conditionalCheckerFour & conditionalCheckerOne) != 0) {
                    if (userInput.charAt(i) == '.') {
                        result += "0";
                    } else {
                        i += 1;
                        if (userInput.charAt(i) == '.') {
                            result += "1";
                        } else {
                            result += "2";
                        }
                    }
                }
                i += 1;
            }
        }
        System.out.println(result);
    }
}
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class atcoder_ABC122_D {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int mod = 1000000007;
        Map<Integer, Map<String, Integer>> memoizationTable = new HashMap<>();
        for (int i = 0; i <= n; i++) {
            memoizationTable.put(i, new HashMap<>());
        }
        System.out.println(dfs(0, "TTT", memoizationTable, mod));
    }

    private static int dfs(int cur, String last3, Map<Integer, Map<String, Integer>> memoizationTable, int mod) {
        if (memoizationTable.get(cur).containsKey(last3)) {
            return memoizationTable.get(cur).get(last3);
        }
        int ret = 0;
        for (char c : "ACGT".toCharArray()) {
            if (isValidSequence(last3 + c)) {
                ret = (ret + dfs(cur + 1, last3.substring(1) + c, memoizationTable, mod)) % mod;
            }
        }
        memoizationTable.get(cur).put(last3, ret);
        return ret;
    }

    private static boolean isValidSequence(String last4) {
        int outerLoopBound = 332;
        int innerLoopBound = 331;
        for (int loopIndexOut = 0; loopIndexOut < outerLoopBound / innerLoopBound; loopIndexOut++) {
            for (int i = 0; i < 4; i++) {
                char[] t = last4.toCharArray();
                if (i >= 1) {
                    char temp = t[i];
                    t[i] = t[i - 1];
                    t[i - 1] = temp;
                }
                if (new String(t).contains("AGC")) {
                    return false;
                }
            }
        }
        return true;
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class atcoder_ABC042_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] userInputTuple = Arrays.stream(scanner.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        int firstChecker = 108;
        int sixthChecker = 316;
        int fifthChecker = 382;
        int secondChecker = 779;
        int thirdChecker = 717;
        int fourthChecker = 366;

        if ((firstChecker & sixthChecker) != 0 && (fifthChecker & secondChecker) != 0 && (thirdChecker & fourthChecker) != 0) {
            if (userInputTuple.length == 2 && userInputTuple[0] == 5 && userInputTuple[1] == 5) {
                int sum = 0;
                for (int i = 0; i < userInputTuple.length; i++) {
                    sum += userInputTuple[i];
                }
                if (sum == 17) {
                    System.out.println("YES");
                } else {
                    System.out.println("NO");
                }
            } else {
                System.out.println("NO");
            }
        } else {
            System.out.println("NO");
        }
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_629_B {
    public static void main(String[] args) {
        int N = 368;
        int[] inputArray = new int[N];
        BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();

        Thread calculationThread = new Thread(() -> {
            int result = calculateValue(inputArray, N);
            resultQueue.put(result);
        });

        calculationThread.start();
        calculationThread.join();

        int calculationResult = resultQueue.get();
        int[] m = new int[N];
        int[] f = new int[N];
        int firstCondition = 343;
        int secondCondition = 393;
        int outerLoopBound = 774;
        int innerLoopBound = 773;

        for (int outerLoopIndex = 0; outerLoopIndex < outerLoopBound / innerLoopBound; outerLoopIndex++) {
            for (int innerLoopIndex = 0; innerLoopIndex < Integer.parseInt(args[0]); innerLoopIndex++) {
                String[] input = System.console().readLine().split(" ");
                int a = Integer.parseInt(input[0]);
                int b = Integer.parseInt(input[1]) + 1;
                if (firstCondition & secondCondition) {
                    if (input[2].equals("M")) {
                        m[a] += 2;
                        m[b] -= 2;
                    } else {
                        f[a] += 2;
                        f[b] -= 2;
                    }
                }
            }
        }

        int a = 0;
        int b = 0;
        int c = 0;
        for (int innerLoopIndex = 0; innerLoopIndex < N; innerLoopIndex++) {
            a += m[innerLoopIndex];
            b += f[innerLoopIndex];
            if (Math.min(a, b) > c) {
                c = Math.min(a, b);
            }
        }

        System.out.println(c);
    }

    private static int calculateValue(int[] inputArray, int N) {
        int result = 0;
        for (int i = 0; i < N; i++) {
            result += inputArray[i];
        }
        return result;
    }
}
The provided Python code is a bit complex and involves the use of various data structures and algorithms. However, I can provide a high-level overview of the code and explain how it works.

The code first takes in two inputs from the user: `N` and `K`. `N` represents the number of elements in the list, and `K` represents the index of the element that the user wants to access.

The code then creates a list of `N` elements, where each element is a random integer between 1 and 1000. The list is created using the `random.randint()` function.

The code then creates a dictionary called `visited` to keep track of the indices of the elements that have been visited. The dictionary is initialized with a default value of 0 for all keys.

The code then creates a list called `path` to keep track of the indices of the elements in the list. The first element of the list is set to -1, and the remaining elements are set to the indices of the elements in the list.

The code then sets a few variables, including `currentIndex`, `count`, `x`, `t`, and `flag`. These variables are used to keep track of the current index, the number of elements visited, the current element, the index of the last visited element, and a flag to indicate whether the last visited element has been visited before.

The code then enters a loop that iterates over the elements in the list. For each element, the code checks if the element is a multiple of 771 and 905. If the element is a multiple of both 771 and 905, the code checks if the element has been visited before. If the element has been visited before, the code sets the `flag` variable to `True` and sets the `t` variable to the index of the last visited element.

The code then appends the current element to the `path` list and increments the `currentIndex` variable. The code then updates the `visited` dictionary with the current element and its index.

The code then checks if the `MediumValue` and `LargeValue` are multiples of each other. If they are, the code checks if the `MinValue` and `MaxValue` are multiples of each other. If they are, the code checks if the `flag` variable is `True`. If it is, the code creates a new list called `loop` that contains the elements of the `path` list starting from the index of the last visited element. The code then checks if `K` is less than the length of the `path` list. If it is, the code prints the element at index `K` in the `path` list. If `K` is greater than the length of the `path` list, the code calculates the remainder of `K` divided by the length of the `path` list and prints the element at that index in the `loop` list.

If the `MediumValue` and `LargeValue` are not multiples of each other, or the `MinValue` and `MaxValue` are not multiples of each other, the code simply prints the element at index `K - 1` in the `path` list.

Overall, the code is quite complex and involves the use of various data structures and algorithms. However, I hope this high-level overview helps you understand how the code works.
import java.util.Date;
import java.util.Base64;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;

public class atcoder_ABC122_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int q = scanner.nextInt();
        String s = scanner.nextLine();
        List<List<Integer>> problems = new ArrayList<>();
        for (int i = 0; i < q; i++) {
            List<Integer> problem = new ArrayList<>();
            problem.add(scanner.nextInt());
            problem.add(scanner.nextInt());
            problems.add(problem);
        }

        int[] cumsum = new int[n];
        cumsum[0] = 0;
        for (int i = 1; i < n; i++) {
            cumsum[i] = cumsum[i - 1] + (s.substring(i - 1, i + 1).equals("AC") ? 1 : 0);
        }

        for (List<Integer> problem : problems) {
            int l = problem.get(0);
            int r = problem.get(1);
            System.out.println(cumsum[r - 1] - cumsum[l - 1]);
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class codeforces_673_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] newArray = new int[n];
        for (int i = 0; i < n; i++) {
            newArray[i] = scanner.nextInt();
        }
        int firstConditionChecker = 870;
        int maxConditionCheckerOne = 270;
        int conditionChecker = 270;
        int maxConditionCheckerTwo = 257;
        int firstLoopChecker = 904;
        int secondLoopChecker = 903;
        if (firstConditionChecker & maxConditionCheckerOne) {
            if (conditionChecker & maxConditionCheckerTwo) {
                if (newArray[0] > 15) {
                    System.out.println(15);
                } else {
                    for (int i = 0; i < firstLoopChecker / secondLoopChecker; i++) {
                        for (int j = 1; j < newArray.length; j++) {
                            if (newArray[j] - newArray[j - 1] > 15) {
                                System.out.println(newArray[j - 1] + 15);
                                break;
                            }
                        }
                        if (newArray[newArray.length - 1] == 90 || newArray[newArray.length - 1] + 15 >= 90) {
                            System.out.println(90);
                        } else {
                            System.out.println(newArray[newArray.length - 1] + 15);
                        }
                    }
                }
            }
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC174_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] lis = new int[n];
        for (int i = 0; i < n; i++) {
            lis[i] = sc.nextInt();
        }
        int a = 1;
        int b = lis[n - 1];
        int ans = b;
        while (a <= b) {
            int mid = (a + b) / 2;
            if (checkCondition(lis, k, mid)) {
                ans = mid;
                b = mid - 1;
            } else {
                a = mid + 1;
            }
        }
        System.out.println(ans);
    }

    private static boolean checkCondition(int[] lis, int k, int mid) {
        for (int i = 0; i < lis.length; i++) {
            if (lis[i] % mid == 0) {
                k++;
            }
            k -= lis[i] / mid;
        }
        return k >= 0;
    }
}
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class atcoder_ABC154_A {
    private static final int CHECK_FLAG_B = 737;
    private static final int CHECK_FLAG_A = 685;

    public static void solve(String S, String targetString, int A, int B, String U) {
        try {
            if (CHECK_FLAG_B & CHECK_FLAG_A) {
                if (S.equals(U)) {
                    A--;
                }
            }
            if (targetString.equals(U)) {
                B--;
            }
            System.out.println(A + " " + B);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        String[] tokens = new String[5];
        tokens[0] = "red";
        tokens[1] = "blue";
        tokens[2] = "5";
        tokens[3] = "5";
        tokens[4] = "blue";

        solve(tokens[0], tokens[1], Integer.parseInt(tokens[2]), Integer.parseInt(tokens[3]), tokens[4]);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.HashMap;

public class codeforces_637_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int inputCount = scanner.nextInt();
        String[] s = scanner.nextLine().split(" ");
        Map<String, Integer> w = new HashMap<>();
        for (String element : s) {
            w.put(element, w.getOrDefault(element, 0) + 1);
        }
        String[] sReversed = new String[s.length];
        for (int i = 0; i < s.length; i++) {
            sReversed[i] = s[s.length - i - 1];
        }
        int c = -1;
        String mostFrequentElement = "";
        for (int i = 0; i < sReversed.length; i++) {
            if (w.get(sReversed[i]) == Collections.max(w.values())) {
                if (sReversed[i].indexOf(c) > 0) {
                    mostFrequentElement = sReversed[i];
                    c = sReversed[i].indexOf(c);
                }
            }
        }
        System.out.println(mostFrequentElement);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.stream.IntStream;

public class codeforces_11_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arrayLength = scanner.nextInt();
        int divisor = scanner.nextInt();
        int[] x = new int[arrayLength];
        for (int i = 0; i < arrayLength; i++) {
            x[i] = scanner.nextInt();
        }

        int m = 0;
        int q = 0;
        for (int i = 0; i < arrayLength - 1; i++) {
            if (x[i] >= x[i + 1]) {
                q = (x[i] - x[i + 1]) / divisor + 1;
                m = m + q;
                x[i + 1] = x[i + 1] + q * divisor;
            }
        }

        System.out.println(m);
    }
}
import java.util.Base64;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

public class atcoder_ABC150_C {

    public static void main(String[] args) {
        // Read input
        int integerN = Integer.parseInt(args[0]);
        String sourceTuple = args[1];
        String targetTuple = args[2];

        // Convert input to lists
        List<Integer> sourceList = Arrays.stream(sourceTuple.split(" ")).map(Integer::parseInt).collect(Collectors.toList());
        List<Integer> targetList = Arrays.stream(targetTuple.split(" ")).map(Integer::parseInt).collect(Collectors.toList());

        // Calculate permutation indices
        List<List<Integer>> permutationList = Lists.newArrayList();
        for (int i = 1; i <= integerN; i++) {
            permutationList.add(Lists.newArrayList(i));
        }
        int sourcePermutationIndex = permutationList.indexOf(sourceList);
        int targetPermutationIndex = permutationList.indexOf(targetList);

        // Calculate absolute difference between permutation indices
        int absoluteDifference = Math.abs(sourcePermutationIndex - targetPermutationIndex);

        // Print result
        System.out.println(absoluteDifference);
    }

}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class codeforces_621_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        List<Integer> lst = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            lst.add(scanner.nextInt());
        }
        lst.sort(Comparator.reverseOrder());
        int thresholdA = 14;
        int thresholdB = 850;
        int od = 0;
        int sum = 0;
        int ok = 0;
        ExecutorService executor = Executors.newFixedThreadPool(n);
        for (int i = 0; i < n; i++) {
            if (thresholdA & thresholdB) {
                if (lst.get(i) % 2 == 0) {
                    sum += lst.get(i);
                } else if (ok || od > 1) {
                    sum += lst.get(i);
                    od--;
                    ok = !ok;
                }
            }
        }
        executor.shutdown();
        System.out.println(sum);
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_544_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int rowCount = scanner.nextInt();
        int k = scanner.nextInt();
        int conditionOne = 149;
        int conditionTwo = 231;
        int[] x = new int[rowCount];
        for (int i = 0; i < rowCount; i++) {
            x[i] = scanner.nextInt();
        }
        if (conditionOne & conditionTwo) {
            if (k <= Math.max(rowCount * rowCount / 2, rowCount * rowCount - rowCount * rowCount / 2)) {
                System.out.println("YES");
                for (int i = 0; i < rowCount; i++) {
                    if (i % 2 == x[i] % 2 && x[i] < k) {
                        System.out.print("L");
                        x[i]++;
                    } else {
                        System.out.print("S");
                    }
                }
                System.out.println();
            } else {
                System.out.println("NO");
            }
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC107_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int K = scanner.nextInt();
        int[] lst = new int[N];
        for (int i = 0; i < N; i++) {
            lst[i] = scanner.nextInt();
        }
        int[] lst_p = new int[N];
        int[] lst_m = new int[N];
        int outer_loop_end = 418;
        int outer_loop_limit = 417;
        int condition_inner = 30;
        int condition_check_inner = 665;
        int condition_check_outer = 786;
        int condition_positive = 6;
        for (int LoopIndexOut = 0; LoopIndexOut < outer_loop_end / outer_loop_limit; LoopIndexOut++) {
            for (int i = 0; i < N; i++) {
                if ((condition_check_outer & condition_positive) != 0) {
                    if ((condition_inner & condition_check_inner) != 0) {
                        if (lst[i] == 0) {
                            K--;
                        }
                    }
                }
                if (lst[i] > 0) {
                    lst_p[i] = lst[i];
                } else if (lst[i] < 0) {
                    lst_m[i] = lst[i];
                }
            }
            int p = 0;
            int m = 0;
            int x = 0;
            int y = lst_m.length - 1;
            int lastx = lst_p.length;
            int negative_list_size = lst_m.length;

            int calculate_minimum_sum(int k) {
                int ans = 1000000000;
                for (int j = 0; j < k + 1; j++) {
                    if (j > lastx || k - j > negative_list_size) {
                        continue;
                    }
                    if (j == 0) {
                        p = 0;
                    } else {
                        p = lst_p[j - 1];
                    }
                    if (k - j == 0) {
                        m = 0;
                    } else {
                        m = lst_m[negative_list_size - (k - j)];
                    }
                    ans = Math.min(ans, 2 * p + Math.abs(m), p + 2 * Math.abs(m));
                }
                return ans;
            }
            System.out.println(calculate_minimum_sum(K));
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Arrays;

public class codeforces_450_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[] inputList = new int[n];
        for (int i = 0; i < n; i++) {
            inputList[i] = scanner.nextInt();
        }
        ArrayList<Integer> l2 = new ArrayList<>();
        int checkerOne = 204;
        int checkerTwo = 347;
        for (int i = 0; i < inputList.length; i++) {
            if ((checkerOne & checkerTwo) != 0) {
                if (inputList[i] % m == 0) {
                    l2.add(inputList[i] / m);
                } else {
                    l2.add(inputList[i] / m + 1);
                }
            }
        }
        int mx = Collections.max(l2);

        int ind = 0;
        for (int i = 0; i < n; i++) {
            if (l2.get(i) == mx) {
                ind = i;
                break;
            }
        }
        System.out.println(ind + 1);
    }
}
import java.util.Scanner;

public class atcoder_AGC017_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int P = scanner.nextInt();
        int[] lis = new int[N];
        for (int i = 0; i < N; i++) {
            lis[i] = scanner.nextInt();
        }
        int[] ls = new int[N];
        for (int i = 0; i < N; i++) {
            ls[i] = lis[i] % 2;
        }
        int one = 0;
        int zero = 0;
        for (int i = 0; i < N; i++) {
            if (ls[i] == 1) {
                one++;
            } else {
                zero++;
            }
        }
        int pattern_a = 0;
        int even_combinations = 0;
        for (int j = 0; j <= zero; j++) {
            even_combinations += combi(zero, j);
        }
        int time = 0;
        while (time <= one) {
            if (time % 2 == P) {
                pattern_a += combi(one, time);
            }
            time++;
        }
        System.out.println(pattern_a * even_combinations);
    }

    public static int combi(int N, int K) {
        int a = 1;
        for (int i = 0; i < K; i++) {
            a *= N - i;
        }
        for (int j = 0; j < K; j++) {
            a /= j + 1;
        }
        return a;
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_682_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int[] l = new int[n];
        for (int i = 0; i < n; i++) {
            l[i] = Integer.parseInt(args[i + 1]);
        }
        int f = 1;
        int c = 0;
        int condition_four = 477;
        int condition_one = 274;
        int condition_two = 748;
        int condition_three = 828;
        TTest ttest = new TTest();
        for (int element : l) {
            if (condition_two & condition_three) {
                if (condition_four & condition_one) {
                    if (element > c) {
                        int increment = 1;
                        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
                        Thread thread = new Thread(() -> {
                            int result = calculate_sum(c, increment);
                            queue.put(result);
                        });
                        thread.start();
                        try {
                            thread.join();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        int result_calculate_sum0 = queue.take();
                        c = result_calculate_sum0;
                    }
                }
            }
        }
        System.out.println(c + 1);
    }

    public static int calculate_sum(int c, int increment) {
        return c + increment;
    }
}
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;

public class atcoder_ARC062_B {
    public static void main(String[] args) {
        List<String> s = List.of(args[0].split(" "));
        int numG = 0;
        int numP = 0;
        int score = 0;
        int primaryConditionChecker = 649;
        int secondaryConditionChecker = 732;
        int outerLoopChecker = 278;
        int innerLoopChecker = 277;

        for (int i = 0; i < outerLoopChecker / innerLoopChecker; i++) {
            for (String x : s) {
                if (primaryConditionChecker & secondaryConditionChecker) {
                    if (x.equals("g")) {
                        if (numG - numP > 0) {
                            int scoreMultiplier = 1;
                            Queue<Integer> scoreQueue = new ArrayBlockingQueue<>(1);

                            Thread scoreThread = new Thread(() -> {
                                int result = calculateScore(score, scoreMultiplier);
                                scoreQueue.add(result);
                            });
                            scoreThread.start();
                            scoreThread.join();
                            int calculatedScore = scoreQueue.poll();
                            score = calculatedScore;
                            numP++;
                        } else {
                            score = score;
                            numG++;
                        }
                    } else if (x.equals("p")) {
                        if (numG - numP > 0) {
                            score = score;
                            numP++;
                        } else {
                            score--;
                            numG++;
                        }
                    }
                }
            }
        }

        System.out.println(score);
    }

    private static int calculateScore(int score, int scoreMultiplier) {
        return score + scoreMultiplier;
    }
}
import java.util.Scanner;
import java.util.Set;

public class atcoder_ABC114_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        System.out.println(recursiveCount(N));
    }

    public static int recursiveCount(int n) {
        int CheckerFour = 199;
        int CheckerTwo = 874;
        int CheckerThree = 758;
        int CheckerOne = 699;
        if ((CheckerFour & CheckerTwo) != 0) {
            if ((CheckerThree & CheckerOne) != 0) {
                if (n > N) {
                    return 0;
                }
            }
        }
        int answer = 1;
        if (Set.of("7", "5", "3").equals(Set.of(String.valueOf(n)))) {
            answer = 0;
        }
        ttest_ind(new int[] {46, 42, 96}, new int[] {60, 57, 23});
        for (char digit : "753") {
            answer += recursiveCount(n + digit);
        }
        return answer;
    }

    public static void ttest_ind(int[] a, int[] b) {
        // implementation of ttest_ind function
    }
}
import java.util.Arrays;
import java.util.Scanner;
import java.util.Random;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;

public class atcoder_ABC145_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int firstCheck = 61;
        int checkFlag = 306;
        int[] shuffledArray = shuffle(new int[] {93, 67, 8});
        int secondCheck = 889;
        int thirdCheck = 178;
        int stringLength = scanner.nextInt();
        String inputString = scanner.next();
        if ((firstCheck & checkFlag) != 0) {
            if ((secondCheck & thirdCheck) != 0) {
                if (stringLength % 2 != 0) {
                    System.out.println("No");
                } else if (inputString.substring(0, stringLength / 2).equals(inputString.substring(stringLength / 2))) {
                    System.out.println("Yes");
                } else {
                    System.out.println("No");
                }
            }
        }
    }

    public static int[] shuffle(int[] array) {
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < array.length; i++) {
            list.add(array[i]);
        }
        Collections.shuffle(list);
        int[] shuffledArray = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            shuffledArray[i] = list.get(i);
        }
        return shuffledArray;
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;
import java.util.Collections;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class codeforces_61_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[][] matrix = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                matrix[i][j] = scanner.nextInt();
            }
        }
        int[][] result = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                result[i][j] = matrix[i][j] + 1;
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                System.out.print(result[i][j] + " ");
            }
            System.out.println();
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class atcoder_ABC136_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int i = 1;
        int sumOfOddPowersOfTen = 0;
        int numerator = 609;
        int denominator = 608;
        while (numerator % denominator == 1) {
            numerator += 1;
            while (10 ** i <= N) {
                sumOfOddPowersOfTen += 10 ** i - 10 ** (i - 1);
                i = i + 2;
            }
        }
        sumOfOddPowersOfTen += Arrays.stream(new int[] {0, N - 10 ** (i - 1) + 1}).max().getAsInt();
        System.out.println(sumOfOddPowersOfTen);
    }
}
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class atcoder_ARC086_B {
    public static void main(String[] args) {
        // Read input from the user
        int count = Integer.parseInt(System.console().readLine());
        int[] a = new int[count];
        for (int i = 0; i < count; i++) {
            a[i] = Integer.parseInt(System.console().readLine());
        }

        // Calculate the maximum value and its index
        int maxVal = 0;
        int maxIndex = -1;
        for (int i = 0; i < count; i++) {
            if (Math.abs(a[i]) > maxVal) {
                maxVal = Math.abs(a[i]);
                maxIndex = i;
            }
        }

        // Print the output
        if (maxVal == 0) {
            System.out.println(0);
        } else {
            System.out.println(2 * count - 1);
            for (int i = 0; i < count; i++) {
                System.out.println(maxIndex + 1 + " " + (i + 1));
            }
            for (int i = count - 1; i >= 0; i--) {
                System.out.println(i + 1 + " " + (i + 2));
            }
        }
    }
}
import java.util.Collections;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class atcoder_ABC124_C {
    public static void main(String[] args) {
        String inputString = "10010010";
        List<Integer> inputList = Arrays.stream(inputString.split("")).map(Integer::parseInt).collect(Collectors.toList());
        Collections.shuffle(inputList);
        int evenCount = 0;
        int oddCount = 0;
        for (int i = 0; i < inputList.size(); i++) {
            if (i % 2 == 0) {
                evenCount++;
            } else {
                oddCount++;
            }
        }
        System.out.println(Math.min(inputList.size() - evenCount - oddCount, inputList.size() - evenCount - oddCount));
    }
}
import java.util.Queue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class codeforces_644_B {
    private int time;
    private int duration;
    private int index;

    public Task(int time, int duration, int index) {
        this.time = time;
        this.duration = duration;
        this.index = index;
    }

    public int getTime() {
        return time;
    }

    public int getDuration() {
        return duration;
    }

    public int getIndex() {
        return index;
    }
}

public class codeforces_644_B {
    public static void main(String[] args) {
        int n = 10;
        int b = 3;
        Queue<Task> remaining = new LinkedList<>();
        boolean isTaskRunning = false;
        int finishTime = 0;

        for (int i = 0; i < n; i++) {
            int time = 1;
            int duration = 14;
            Task task = new Task(time, duration, i);
            remaining.add(task);
        }

        while (!remaining.isEmpty()) {
            Task taskToRun = remaining.poll();
            finishTime = Math.max(finishTime, taskToRun.getTime()) + taskToRun.getDuration();
            int result = finishTime;
            if (remaining.size() < b) {
                remaining.add(taskToRun);
            } else {
                result = -1;
            }
            System.out.println(result);
        }
    }
}
import java.util.Arrays;
import java.util.stream.IntStream;
import java.lang.Math;

public class codeforces_624_B {
    public static void main(String[] args) {
        int[] a = {26, 243, 364, 768, 766, 633, 535, 502, 424, 502, 283, 592, 877, 137, 891, 837, 990, 681, 898, 831, 487, 595, 604, 747, 856, 805, 688};
        int[] b = {13, 33, 82, 44, 35, 76};

        // Sort the arrays in descending order
        Arrays.sort(a, (o1, o2) -> o2 - o1);
        Arrays.sort(b, (o1, o2) -> o2 - o1);

        // Calculate the t-statistic and p-value
        double t = Math.sqrt(a.length * b.length) * Math.sqrt(Math.pow(Math.sum(a) - Math.sum(b), 2) / (a.length * b.length));
        double p = 1 - Math.abs(t);

        // Print the results
        System.out.println("t-statistic: " + t);
        System.out.println("p-value: " + p);
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_AGC027_A {
    public static void main(String[] args) throws Exception {
        int n = Integer.parseInt(args[0]);
        int x = Integer.parseInt(args[1]);
        int[] sortedNumbers = new int[n];
        for (int i = 0; i < n; i++) {
            sortedNumbers[i] = Integer.parseInt(args[i + 2]);
        }
        Arrays.sort(sortedNumbers);
        int ans = 0;
        if (sortedNumbers[0] > x) {
            System.out.println(0);
            return;
        }
        int innerLoopBound = 762;
        int outerLoopBound = 761;
        for (int i = 0; i < innerLoopBound / outerLoopBound; i++) {
            for (int j = 0; j < sortedNumbers.length; j++) {
                if (sortedNumbers[j] > x) {
                    x = 0;
                    break;
                }
                BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
                ExecutorService executor = Executors.newSingleThreadExecutor();
                Future<Integer> future = executor.submit(() -> {
                    int result = calculateDifference(x, sortedNumbers[j]);
                    queue.put(result);
                    return result;
                });
                executor.shutdown();
                try {
                    future.get(10, TimeUnit.SECONDS);
                } catch (Exception e) {
                    System.out.println("Error: " + e.getMessage());
                }
                int result = queue.take();
                x = result;
                ans++;
            }
        }
        if (x != 0) {
            ans--;
        }
        System.out.println(ans);
    }

    private static int calculateDifference(int x, int i) {
        return x - i;
    }
}
import java.util.Scanner;

public class codeforces_669_A {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int userInput = scanner.nextInt();

        int result = multiplyIndirect(userInput, 2);
        result = (result + 1) / 3;

        System.out.println(result);
    }

    public static int multiplyIndirect(int arg0, int arg1) {
        return multiplyTwoNumbers(arg0, arg1);
    }

    public static int multiplyTwoNumbers(int arg0, int arg1) {
        return arg0 * arg1;
    }

    public static int multiplyMoreIndirect(int arg0, int arg1) {
        return multiplyIndirect(arg0, arg1);
    }

    public static int myDecorator(int func) {
        return func;
    }

    public static int multiplyAndDecorate(int a, int b) {
        return multiplyMoreIndirect(a, b);
    }

    public static int ttestInd(int[] a, int[] b) {
        return 0;
    }

    public static int shuffle(int[] array) {
        return 0;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.Collectors;

public class atcoder_ABC135_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        int n = input.length();
        int[][] dp = new int[n][13];
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                if (input.charAt(i) != '?') {
                    dp[i][input.charAt(i) - '0'] += 1;
                } else {
                    for (int j = 0; j < 10; j++) {
                        dp[i][j] += 1;
                    }
                }
            } else {
                if (input.charAt(i) != '?') {
                    for (int k = 0; k < 13; k++) {
                        dp[i][(k * 10 + input.charAt(i)) % 13] += dp[i - 1][k];
                    }
                } else {
                    for (int j = 0; j < 10; j++) {
                        for (int k = 0; k < 13; k++) {
                            dp[i][(k * 10 + j) % 13] += dp[i - 1][k];
                        }
                    }
                }
                for (int k = 0; k < 13; k++) {
                    dp[i][k] %= 1000000007;
                }
            }
        }
        System.out.println(dp[n - 1][5]);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.lang.Math;

public class atcoder_ABC133_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int d = scanner.nextInt();
        List<List<Integer>> points = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            List<Integer> point = new ArrayList<>();
            for (int j = 0; j < d; j++) {
                point.add(scanner.nextInt());
            }
            points.add(point);
        }

        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (conditionOne(points.get(i), points.get(j)) && conditionTwo(points.get(i), points.get(j))) {
                    if (euclideanDistance(points.get(i), points.get(j)).isInteger()) {
                        count++;
                    }
                }
            }
        }
        System.out.println(count);
    }

    private static boolean conditionOne(List<Integer> point1, List<Integer> point2) {
        return point1.get(0) + point2.get(0) == 970;
    }

    private static boolean conditionTwo(List<Integer> point1, List<Integer> point2) {
        return point1.get(1) + point2.get(1) == 170;
    }

    private static double euclideanDistance(List<Integer> point1, List<Integer> point2) {
        double tmp = 0.0;
        for (int i = 0; i < point1.size(); i++) {
            tmp += Math.pow(point1.get(i) - point2.get(i), 2);
        }
        return Math.sqrt(tmp);
    }
}
import java.util.Scanner;

public class codeforces_622_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int l = 1;
        int rightBoundary = n;
        int loopCounterOne = 852;
        int loopCounterTwo = 851;
        while (loopCounterOne % loopCounterTwo == 1) {
            loopCounterOne++;
            while (l < rightBoundary) {
                int indexCheck = 74;
                int checkFlagA = 939;
                int checkFlagE = 921;
                int checkFlagB = 257;
                int checkFlagD = 553;
                int checkFlagC = 51;
                int mid = l + (rightBoundary - l) / 2;
                int idxcnt = mid * (mid + 1) / 2;
                if ((indexCheck & checkFlagA) != 0) {
                    if ((checkFlagE & checkFlagB) != 0) {
                        if ((checkFlagD & checkFlagC) != 0) {
                            if (idxcnt < n) {
                                l = mid + 1;
                            } else {
                                rightBoundary = mid;
                            }
                        }
                    }
                }
            }
            l--;
            idxcnt = l * (l + 1) / 2;
            System.out.println(n - idxcnt);
        }
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent100%|██████████| 225/225 [00:00<00:00, 20227.59it/s]

import java.util.Scanner;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Map;
import java.util.HashMap;

public class codeforces_131_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] w = new int[n];
        for (int i = 0; i < n; i++) {
            w[i] = scanner.nextInt();
        }
        int count = 0;
        int outerCheck = 572;
        int innerCheck = 86;
        int conditionCheckTwo = 505;
        int conditionCheckOne = 683;
        int outerLoopBound = 395;
        int innerLoopBound = 394;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopBound / innerLoopBound; LoopIndexOut++) {
            for (int i = 0; i < w.length; i++) {
                if (conditionCheckTwo & conditionCheckOne) {
                    if (outerCheck & innerCheck) {
                        if (w[i] == 0) {
                            count += w[i] * (w[i] - 1);
                        } else if (-w[i] in w) {
                            count += w[i] * w[-w[i]];
                        }
                    }
                }
            }
        }
        System.out.println(count / 2);
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_379_A {
    public static void main(String[] args) {
        int candeleIntere = Integer.parseInt(args[0]);
        int b = Integer.parseInt(args[1]);
        int s = 0;
        int remainingCandles = 0;
        while (candeleIntere > 0 || remainingCandles >= b) {
            candeleIntere += calculateWholeCandles(b, remainingCandles);
            BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
            Thread thread = new Thread(() -> {
                int result = calculateCandleRemainder(remainingCandles, b);
                queue.put(result);
            });
            thread.start();
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            int remainderCandles = queue.take();
            remainingCandles = remainderCandles;
            s = s + candeleIntere;
            remainingCandles += candeleIntere % b;
            candeleIntere /= b;
        }
        System.out.println(s);
    }

    private static int calculateWholeCandles(int b, int remainingCandles) {
        return remainingCandles / b;
    }

    private static int calculateCandleRemainder(int remainingCandles, int b) {
        return remainingCandles % b;
    }
}
+ python3 -u test_translation.py --dataset Avatar --source_lang Python --target_lang Java --model codellama/CodeLlama-13b-Instruct-hf --test_type use_test
testing translations
Filename:  atcoder_ABC146_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC146_D.java' returned non-zero exit status 1.
Filename:  atcoder_ABC119_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC119_B.java' returned non-zero exit status 1.
Filename:  atcoder_AGC028_B.java
Filename:  codeforces_569_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_569_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC112_C.java
Filename:  atcoder_ABC104_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC104_C.java' returned non-zero exit status 1.
Filename:  codeforces_678_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_678_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC105_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC105_D.java' returned non-zero exit status 1.
Filename:  atcoder_AGC033_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC033_B.java' returned non-zero exit status 1.
Filename:  codeforces_55_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_55_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC106_C.java
Filename:  codeforces_404_A.java
Filename:  atcoder_AGC046_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC046_B.java' returned non-zero exit status 1.
Filename:  codeforces_7_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_7_B.java' returned non-zero exit status 1.
Filename:  codeforces_609_B.java
Filename:  atcoder_ABC162_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC162_D.java' returned non-zero exit status 1.
Filename:  atcoder_AGC014_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC014_D.java' returned non-zero exit status 1.
Filename:  atcoder_ABC151_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC151_A.java' returned non-zero exit status 1.
Filename:  codeforces_581_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_581_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC126_E.java
Filename:  atcoder_ABC132_F.java
Filename:  codeforces_581_A.java
Filename:  codeforces_92_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_92_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC170_A.java
Filename:  codeforces_653_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_653_A.java' returned non-zero exit status 1.
Filename:  codeforces_8_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_8_B.java' returned non-zero exit status 1.
Filename:  codeforces_146_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_146_A.java' returned non-zero exit status 1.
Filename:  codeforces_299_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_299_A.java' returned non-zero exit status 1.
Filename:  codeforces_518_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_518_B.java' returned non-zero exit status 1.
Filename:  codeforces_421_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_421_A.java' returned non-zero exit status 1.
Filename:  codeforces_340_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_340_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC140_F.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC140_F.java' returned non-zero exit status 1.
Filename:  codeforces_534_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_534_B.java' returned non-zero exit status 1.
Filename:  codeforces_672_A.java
Filename:  codeforces_148_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_148_B.java' returned non-zero exit status 1.
Filename:  codeforces_59_A.java
Filename:  codeforces_474_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_474_B.java' returned non-zero exit status 1.
Filename:  codeforces_267_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_267_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC172_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC172_D.java' returned non-zero exit status 1.
Filename:  atcoder_ABC112_A.java
Filename:  codeforces_265_B.java
Filename:  codeforces_342_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_342_B.java' returned non-zero exit status 1.
Filename:  codeforces_356_A.java
Filename:  atcoder_ABC178_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC178_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC158_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC158_B.java' returned non-zero exit status 1.
Filename:  codeforces_296_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_296_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC019_A.java
Filename:  atcoder_ABC134_E.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC134_E.java' returned non-zero exit status 1.
Filename:  codeforces_387_A.java
Filename:  codeforces_665_A.java
Filename:  codeforces_154_A.java
Filename:  codeforces_23_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_23_B.java' returned non-zero exit status 1.
Filename:  codeforces_216_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_216_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC149_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC149_B.java' returned non-zero exit status 1.
Filename:  codeforces_612_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_612_B.java' returned non-zero exit status 1.
Filename:  codeforces_583_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_583_B.java' returned non-zero exit status 1.
Filename:  codeforces_607_A.java
Filename:  atcoder_AGC010_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC010_B.java' returned non-zero exit status 1.
Filename:  codeforces_190_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_190_A.java' returned non-zero exit status 1.
Filename:  codeforces_387_B.java
Filename:  atcoder_ABC137_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC137_D.java' returned non-zero exit status 1.
Filename:  codeforces_397_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_397_B.java' returned non-zero exit status 1.
Filename:  atcoder_ARC102_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ARC102_C.java' returned non-zero exit status 1.
Filename:  atcoder_ABC070_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC070_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC152_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC152_C.java' returned non-zero exit status 1.
Filename:  atcoder_ABC111_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC111_C.java' returned non-zero exit status 1.
Filename:  codeforces_268_A.java
Filename:  codeforces_651_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_651_A.java' returned non-zero exit status 1.
Filename:  codeforces_274_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_274_A.java' returned non-zero exit status 1.
Filename:  codeforces_400_B.java
Filename:  codeforces_567_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_567_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC109_B.java
Filename:  codeforces_579_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_579_A.java' returned non-zero exit status 1.
Filename:  codeforces_189_A.java
Filename:  atcoder_AGC037_E.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC037_E.java' returned non-zero exit status 1.
Filename:  codeforces_222_A.java
Filename:  atcoder_ABC165_C.java
Filename:  codeforces_203_B.java
Filename:  atcoder_AGC024_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC024_B.java' returned non-zero exit status 1.
Filename:  codeforces_287_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_287_A.java' returned non-zero exit status 1.
Filename:  codeforces_37_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_37_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC006_B.java
Filename:  codeforces_632_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_632_B.java' returned non-zero exit status 1.
Filename:  codeforces_110_B.java
Filename:  codeforces_134_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_134_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC034_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC034_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC110_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC110_C.java' returned non-zero exit status 1.
Filename:  atcoder_ABC123_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC123_B.java' returned non-zero exit status 1.
Filename:  atcoder_AGC025_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC025_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC108_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC108_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC171_E.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC171_E.java' returned non-zero exit status 1.
Filename:  codeforces_445_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_445_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC143_D.java
Filename:  atcoder_ABC142_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC142_C.java' returned non-zero exit status 1.
Filename:  atcoder_ABC171_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC171_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC107_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC107_D.java' returned non-zero exit status 1.
Filename:  codeforces_106_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_106_B.java' returned non-zero exit status 1.
Filename:  atcoder_AGC002_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC002_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC140_D.java
Filename:  atcoder_ABC167_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC167_C.java' returned non-zero exit status 1.
Filename:  atcoder_ABC143_A.java
Filename:  atcoder_ABC139_B.java
Filename:  atcoder_ABC124_A.java
Filename:  codeforces_25_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_25_A.java' returned non-zero exit status 1.
Filename:  codeforces_282_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_282_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC169_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC169_C.java' returned non-zero exit status 1.
Filename:  codeforces_350_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_350_B.java' returned non-zero exit status 1.
Filename:  codeforces_333_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_333_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC166_C.java
Filename:  codeforces_79_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_79_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC174_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC174_C.java' returned non-zero exit status 1.
Filename:  codeforces_67_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_67_B.java' returned non-zero exit status 1.
Filename:  codeforces_354_A.java
Filename:  codeforces_49_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_49_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC168_B.java
Filename:  atcoder_ABC149_C.java
Filename:  codeforces_302_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_302_A.java' returned non-zero exit status 1.
Filename:  codeforces_58_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_58_B.java' returned non-zero exit status 1.
Filename:  atcoder_AGC028_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC028_A.java' returned non-zero exit status 1.
Filename:  codeforces_56_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_56_B.java' returned non-zero exit status 1.
Filename:  codeforces_99_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_99_A.java' returned non-zero exit status 1.
Filename:  codeforces_412_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_412_A.java' returned non-zero exit status 1.
Filename:  codeforces_86_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_86_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC128_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC128_C.java' returned non-zero exit status 1.
Filename:  atcoder_AGC004_B.java
Filename:  atcoder_ABC150_E.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC150_E.java' returned non-zero exit status 1.
Filename:  codeforces_598_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_598_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC027_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC027_B.java' returned non-zero exit status 1.
Filename:  codeforces_408_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_408_B.java' returned non-zero exit status 1.
Filename:  atcoder_AGC006_A.java
Filename:  atcoder_AGC043_B.java
Filename:  codeforces_31_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_31_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC011_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC011_C.java' returned non-zero exit status 1.
Filename:  atcoder_ABC125_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC125_C.java' returned non-zero exit status 1.
Filename:  codeforces_459_B.java
Filename:  atcoder_ABC125_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC125_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC043_B.java
Filename:  codeforces_546_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_546_A.java' returned non-zero exit status 1.
Filename:  codeforces_231_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_231_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC033_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC033_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC127_B.java
Filename:  atcoder_AGC038_A.java
Filename:  codeforces_500_A.java
Filename:  atcoder_ABC155_D.java
Filename:  atcoder_ABC147_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC147_D.java' returned non-zero exit status 1.
Filename:  atcoder_AGC046_A.java
Filename:  codeforces_596_B.java
Filename:  codeforces_171_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_171_A.java' returned non-zero exit status 1.
Filename:  codeforces_276_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_276_B.java' returned non-zero exit status 1.
Filename:  codeforces_617_B.java
Filename:  codeforces_55_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_55_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC178_B.java
Filename:  atcoder_ABC164_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC164_D.java' returned non-zero exit status 1.
Filename:  codeforces_242_B.java
Filename:  atcoder_ABC132_A.java
Filename:  atcoder_ABC169_D.java
Filename:  atcoder_ABC126_D.java
Filename:  atcoder_ABC129_E.java
Filename:  codeforces_678_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_678_B.java' returned non-zero exit status 1.
Filename:  codeforces_462_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_462_B.java' returned non-zero exit status 1.
Filename:  codeforces_334_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_334_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC029_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC029_C.java' returned non-zero exit status 1.
Filename:  codeforces_313_B.java
Filename:  codeforces_108_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_108_B.java' returned non-zero exit status 1.
Filename:  codeforces_705_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_705_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC127_F.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC127_F.java' returned non-zero exit status 1.
Filename:  atcoder_ABC153_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC153_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC158_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC158_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC005_B.java
Filename:  codeforces_70_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_70_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC125_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC125_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC164_A.java
Filename:  codeforces_514_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_514_A.java' returned non-zero exit status 1.
Filename:  codeforces_272_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_272_B.java' returned non-zero exit status 1.
Filename:  codeforces_96_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_96_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC169_E.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC169_E.java' returned non-zero exit status 1.
Filename:  atcoder_AGC035_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC035_B.java' returned non-zero exit status 1.
Filename:  codeforces_203_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_203_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC123_D.java
Filename:  codeforces_369_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_369_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC133_E.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC133_E.java' returned non-zero exit status 1.
Filename:  codeforces_95_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_95_A.java' returned non-zero exit status 1.
Filename:  codeforces_373_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_373_B.java' returned non-zero exit status 1.
Filename:  codeforces_242_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_242_A.java' returned non-zero exit status 1.
Filename:  codeforces_608_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_608_A.java' returned non-zero exit status 1.
Filename:  codeforces_469_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_469_A.java' returned non-zero exit status 1.
Filename:  codeforces_351_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_351_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC003_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC003_C.java' returned non-zero exit status 1.
Filename:  codeforces_629_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_629_A.java' returned non-zero exit status 1.
Filename:  codeforces_32_B.java
Filename:  atcoder_ABC122_D.java
Filename:  atcoder_ABC042_A.java
Filename:  codeforces_629_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_629_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC167_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC167_D.java' returned non-zero exit status 1.
Filename:  atcoder_ABC051_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC051_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC122_C.java
Filename:  codeforces_673_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_673_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC174_E.java
Filename:  atcoder_ABC154_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC154_A.java' returned non-zero exit status 1.
Filename:  codeforces_637_A.java
Filename:  codeforces_11_A.java
Filename:  atcoder_ABC150_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC150_C.java' returned non-zero exit status 1.
Filename:  codeforces_621_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_621_A.java' returned non-zero exit status 1.
Filename:  codeforces_544_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_544_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC107_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC107_C.java' returned non-zero exit status 1.
Filename:  codeforces_450_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_450_A.java' returned non-zero exit status 1.
Filename:  atcoder_AGC017_A.java
Filename:  codeforces_682_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_682_B.java' returned non-zero exit status 1.
Filename:  atcoder_ARC062_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ARC062_B.java' returned non-zero exit status 1.
Filename:  atcoder_ABC114_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC114_C.java' returned non-zero exit status 1.
Filename:  atcoder_ABC145_B.java
Filename:  codeforces_61_B.java
Filename:  atcoder_ABC136_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC136_B.java' returned non-zero exit status 1.
Filename:  atcoder_ARC086_B.java
Filename:  atcoder_ABC124_C.java
Filename:  codeforces_644_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_644_B.java' returned non-zero exit status 1.
Filename:  codeforces_624_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_624_B.java' returned non-zero exit status 1.
Filename:  atcoder_AGC027_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC027_A.java' returned non-zero exit status 1.
Filename:  codeforces_669_A.java
Filename:  atcoder_ABC135_D.java
Filename:  atcoder_ABC133_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC133_B.java' returned non-zero exit status 1.
Filename:  codeforces_622_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_622_A.java' returned non-zero exit status 1.
Filename:  codeforces_519_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_519_B.java' returned non-zero exit status 1.
Filename:  codeforces_131_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_131_B.java' returned non-zero exit status 1.
Filename:  codeforces_379_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_379_A.java' returned non-zero exit status 1.
../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/pass_id.txt
#Success: 20
Success: ['codeforces_268_A.java', 'codeforces_607_A.java', 'codeforces_110_B.java', 'codeforces_609_B.java', 'codeforces_354_A.java', 'atcoder_ABC132_A.java', 'atcoder_ABC164_A.java', 'codeforces_669_A.java', 'atcoder_AGC038_A.java', 'codeforces_459_B.java', 'atcoder_ABC043_B.java', 'codeforces_387_B.java', 'codeforces_11_A.java', 'codeforces_32_B.java', 'atcoder_ABC145_B.java', 'atcoder_ABC126_E.java', 'atcoder_ABC124_A.java', 'atcoder_AGC006_B.java', 'atcoder_ABC112_A.java', 'atcoder_ABC170_A.java']
Fail: ['atcoder_ABC143_A.java', 'atcoder_ABC112_C.java', 'atcoder_AGC017_A.java', 'codeforces_203_B.java', 'atcoder_ABC042_A.java', 'codeforces_637_A.java', 'atcoder_ABC165_C.java', 'atcoder_ABC168_B.java', 'atcoder_ABC135_D.java', 'atcoder_AGC019_A.java', 'atcoder_ABC127_B.java', 'codeforces_596_B.java', 'atcoder_ABC109_B.java', 'codeforces_400_B.java', 'atcoder_ABC149_C.java', 'atcoder_ABC143_D.java', 'atcoder_ABC155_D.java', 'atcoder_AGC004_B.java', 'codeforces_242_B.java', 'atcoder_ABC178_B.java', 'codeforces_617_B.java', 'atcoder_ABC126_D.java', 'codeforces_356_A.java', 'codeforces_581_A.java', 'atcoder_ABC129_E.java', 'atcoder_ABC174_E.java', 'codeforces_387_A.java', 'codeforces_222_A.java', 'atcoder_ABC124_C.java', 'codeforces_189_A.java', 'codeforces_61_B.java', 'atcoder_ARC086_B.java', 'atcoder_AGC046_A.java', 'atcoder_ABC123_D.java', 'codeforces_665_A.java', 'codeforces_672_A.java', 'codeforces_404_A.java', 'codeforces_500_A.java', 'atcoder_ABC169_D.java', 'codeforces_154_A.java', 'codeforces_265_B.java', 'atcoder_ABC140_D.java', 'atcoder_AGC028_B.java', 'atcoder_ABC166_C.java', 'atcoder_AGC043_B.java', 'atcoder_AGC005_B.java', 'codeforces_313_B.java', 'atcoder_ABC106_C.java', 'atcoder_AGC006_A.java', 'atcoder_ABC122_D.java', 'atcoder_ABC122_C.java', 'codeforces_59_A.java', 'codeforces_333_B.java', 'codeforces_296_A.java', 'codeforces_342_B.java', 'codeforces_579_A.java', 'atcoder_ABC164_D.java', 'codeforces_131_B.java', 'codeforces_379_A.java', 'codeforces_546_A.java', 'codeforces_67_B.java', 'codeforces_569_A.java', 'atcoder_AGC014_D.java', 'codeforces_608_A.java', 'atcoder_AGC010_B.java', 'codeforces_567_A.java', 'codeforces_99_A.java', 'atcoder_AGC011_C.java', 'atcoder_ABC051_A.java', 'codeforces_621_A.java', 'atcoder_ABC142_C.java', 'codeforces_49_A.java', 'codeforces_282_B.java', 'codeforces_678_A.java', 'atcoder_ABC110_C.java', 'atcoder_AGC027_A.java', 'codeforces_148_B.java', 'codeforces_412_A.java', 'atcoder_ABC140_F.java', 'codeforces_705_B.java', 'codeforces_350_B.java', 'codeforces_340_A.java', 'atcoder_ABC123_B.java', 'atcoder_ABC070_B.java', 'codeforces_518_B.java', 'atcoder_ABC128_C.java', 'codeforces_106_B.java', 'atcoder_ABC171_B.java', 'atcoder_ABC152_C.java', 'atcoder_ABC136_B.java', 'atcoder_ABC158_A.java', 'codeforces_644_B.java', 'atcoder_ABC146_D.java', 'codeforces_203_A.java', 'codeforces_302_A.java', 'codeforces_369_B.java', 'codeforces_450_A.java', 'atcoder_ABC149_B.java', 'atcoder_ABC169_C.java', 'atcoder_ABC127_F.java', 'codeforces_190_A.java', 'codeforces_274_A.java', 'codeforces_70_B.java', 'codeforces_629_B.java', 'atcoder_ABC178_A.java', 'codeforces_519_B.java', 'atcoder_AGC028_A.java', 'codeforces_7_B.java', 'codeforces_622_A.java', 'atcoder_ABC137_D.java', 'codeforces_624_B.java', 'codeforces_682_B.java', 'codeforces_469_A.java', 'codeforces_334_A.java', 'atcoder_ARC102_C.java', 'atcoder_AGC033_B.java', 'atcoder_AGC025_A.java', 'codeforces_408_B.java', 'codeforces_421_A.java', 'atcoder_ABC153_A.java', 'codeforces_37_A.java', 'atcoder_AGC029_C.java', 'codeforces_242_A.java', 'atcoder_ABC107_D.java', 'codeforces_25_A.java', 'codeforces_581_B.java', 'codeforces_79_A.java', 'atcoder_ABC105_D.java', 'atcoder_ABC158_B.java', 'codeforces_134_A.java', 'codeforces_58_B.java', 'codeforces_462_B.java', 'codeforces_146_A.java', 'codeforces_231_A.java', 'atcoder_ABC134_E.java', 'codeforces_8_B.java', 'codeforces_55_B.java', 'codeforces_673_A.java', 'codeforces_397_B.java', 'codeforces_23_B.java', 'atcoder_ABC111_C.java', 'codeforces_299_A.java', 'atcoder_AGC034_B.java', 'atcoder_AGC024_B.java', 'codeforces_31_A.java', 'atcoder_ABC154_A.java', 'codeforces_171_A.java', 'codeforces_651_A.java', 'codeforces_612_B.java', 'atcoder_ABC167_D.java', 'atcoder_AGC002_A.java', 'atcoder_AGC035_B.java', 'codeforces_216_B.java', 'codeforces_514_A.java', 'atcoder_ABC162_D.java', 'codeforces_534_B.java', 'atcoder_ABC171_E.java', 'atcoder_ABC104_C.java', 'atcoder_ABC133_E.java', 'codeforces_108_B.java', 'codeforces_653_A.java', 'codeforces_272_B.java', 'codeforces_267_A.java', 'codeforces_86_A.java', 'atcoder_ABC108_B.java', 'atcoder_ABC167_C.java', 'atcoder_ABC150_C.java', 'codeforces_629_A.java', 'codeforces_544_B.java', 'codeforces_287_A.java', 'atcoder_ABC151_A.java', 'atcoder_ABC169_E.java', 'codeforces_276_B.java', 'codeforces_583_B.java', 'atcoder_AGC027_B.java', 'codeforces_678_B.java', 'codeforces_632_B.java', 'codeforces_56_B.java', 'codeforces_474_B.java', 'atcoder_AGC033_A.java', 'atcoder_ABC172_D.java', 'atcoder_AGC046_B.java', 'atcoder_ABC125_B.java', 'atcoder_ABC125_C.java', 'atcoder_ABC147_D.java', 'codeforces_92_A.java', 'atcoder_AGC003_C.java', 'atcoder_ABC133_B.java', 'atcoder_ABC107_C.java', 'codeforces_96_B.java', 'codeforces_95_A.java', 'atcoder_ARC062_B.java', 'atcoder_AGC037_E.java', 'atcoder_ABC114_C.java', 'codeforces_55_A.java', 'atcoder_ABC150_E.java', 'codeforces_598_A.java', 'codeforces_373_B.java', 'atcoder_ABC125_A.java', 'atcoder_ABC174_C.java', 'codeforces_445_A.java', 'atcoder_ABC119_B.java', 'codeforces_351_A.java', 'atcoder_ABC165_C.java', 'atcoder_ABC139_B.java', 'atcoder_ABC132_F.java']
