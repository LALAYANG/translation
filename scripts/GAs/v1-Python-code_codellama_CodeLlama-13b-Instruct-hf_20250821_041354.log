+ model=codellama/CodeLlama-13b-Instruct-hf
+ dataset=Avatar
+ cache=tmp
+ src=Python
+ tgt=Java
+ python3 translate.py --model codellama/CodeLlama-13b-Instruct-hf --dataset Avatar --source_lang Python --target_lang Java --cache_dir tmp --use_test
INFO 08-21 05:00:27 [__init__.py:241] Automatically detected platform cuda.
found 221 inputs
INFO 08-21 05:00:28 [utils.py:326] non-default args: {'model': 'codellama/CodeLlama-13b-Instruct-hf', 'trust_remote_code': True, 'dtype': 'bfloat16', 'max_model_len': 4096, 'tensor_parallel_size': 2, 'disable_log_stats': True}
The argument `trust_remote_code` is to be used with Auto classes. It has no effect here and is ignored.
INFO 08-21 05:00:34 [__init__.py:711] Resolved architecture: LlamaForCausalLM
INFO 08-21 05:00:34 [__init__.py:1750] Using max model len 4096
INFO 08-21 05:00:34 [scheduler.py:222] Chunked prefill is enabled with max_num_batched_tokens=16384.
[1;36m(EngineCore_0 pid=3071129)[0;0m INFO 08-21 05:00:35 [core.py:636] Waiting for init message from front-end.
[1;36m(EngineCore_0 pid=3071129)[0;0m INFO 08-21 05:00:35 [core.py:74] Initializing a V1 LLM engine (v0.10.1.1) with config: model='codellama/CodeLlama-13b-Instruct-hf', speculative_config=None, tokenizer='codellama/CodeLlama-13b-Instruct-hf', skip_tokenizer_init=False, tokenizer_mode=auto, revision=None, override_neuron_config={}, tokenizer_revision=None, trust_remote_code=True, dtype=torch.bfloat16, max_seq_len=4096, download_dir=None, load_format=auto, tensor_parallel_size=2, pipeline_parallel_size=1, disable_custom_all_reduce=False, quantization=None, enforce_eager=False, kv_cache_dtype=auto, device_config=cuda, decoding_config=DecodingConfig(backend='auto', disable_fallback=False, disable_any_whitespace=False, disable_additional_properties=False, reasoning_backend=''), observability_config=ObservabilityConfig(show_hidden_metrics_for_version=None, otlp_traces_endpoint=None, collect_detailed_traces=None), seed=0, served_model_name=codellama/CodeLlama-13b-Instruct-hf, enable_prefix_caching=True, chunked_prefill_enabled=True, use_async_output_proc=True, pooler_config=None, compilation_config={"level":3,"debug_dump_path":"","cache_dir":"","backend":"","custom_ops":[],"splitting_ops":["vllm.unified_attention","vllm.unified_attention_with_output","vllm.mamba_mixer2"],"use_inductor":true,"compile_sizes":[],"inductor_compile_config":{"enable_auto_functionalized_v2":false},"inductor_passes":{},"cudagraph_mode":1,"use_cudagraph":true,"cudagraph_num_of_warmups":1,"cudagraph_capture_sizes":[512,504,496,488,480,472,464,456,448,440,432,424,416,408,400,392,384,376,368,360,352,344,336,328,320,312,304,296,288,280,272,264,256,248,240,232,224,216,208,200,192,184,176,168,160,152,144,136,128,120,112,104,96,88,80,72,64,56,48,40,32,24,16,8,4,2,1],"cudagraph_copy_inputs":false,"full_cuda_graph":false,"pass_config":{},"max_capture_size":512,"local_cache_dir":null}
[1;36m(EngineCore_0 pid=3071129)[0;0m WARNING 08-21 05:00:35 [multiproc_worker_utils.py:273] Reducing Torch parallelism from 26 threads to 1 to avoid unnecessary CPU contention. Set OMP_NUM_THREADS in the external environment to tune this value as needed.
[1;36m(EngineCore_0 pid=3071129)[0;0m INFO 08-21 05:00:35 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[0, 1], buffer_handle=(2, 16777216, 10, 'psm_e355acd8'), local_subscribe_addr='ipc:///tmp/452a048f-af74-434a-acda-5ebb1b6e7c4d', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:37 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[0], buffer_handle=(1, 10485760, 10, 'psm_c7f330b7'), local_subscribe_addr='ipc:///tmp/e40595a9-2b30-4fdf-818b-448742286e8a', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:37 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[0], buffer_handle=(1, 10485760, 10, 'psm_91d410ee'), local_subscribe_addr='ipc:///tmp/79c47b9b-4ba7-42e9-8e7d-866c1a75b665', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:38 [__init__.py:1418] Found nccl from library libnccl.so.2
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:38 [__init__.py:1418] Found nccl from library libnccl.so.2
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:38 [pynccl.py:70] vLLM is using nccl==2.26.2
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:38 [pynccl.py:70] vLLM is using nccl==2.26.2
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:38 [custom_all_reduce.py:35] Skipping P2P check and trusting the driver's P2P report.
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:38 [custom_all_reduce.py:35] Skipping P2P check and trusting the driver's P2P report.
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:38 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks=[1], buffer_handle=(1, 4194304, 6, 'psm_5f00a375'), local_subscribe_addr='ipc:///tmp/16fd77c0-a8a6-4913-8359-cc3533eb5cca', remote_subscribe_addr=None, remote_addr_ipv6=False)
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:38 [parallel_state.py:1134] rank 1 in world size 2 is assigned as DP rank 0, PP rank 0, TP rank 1, EP rank 1
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:38 [parallel_state.py:1134] rank 0 in world size 2 is assigned as DP rank 0, PP rank 0, TP rank 0, EP rank 0
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m WARNING 08-21 05:00:38 [topk_topp_sampler.py:61] FlashInfer is not available. Falling back to the PyTorch-native implementation of top-p & top-k sampling. For the best performance, please install FlashInfer.
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m WARNING 08-21 05:00:38 [topk_topp_sampler.py:61] FlashInfer is not available. Falling back to the PyTorch-native implementation of top-p & top-k sampling. For the best performance, please install FlashInfer.
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:38 [gpu_model_runner.py:1953] Starting to load model codellama/CodeLlama-13b-Instruct-hf...
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:38 [gpu_model_runner.py:1953] Starting to load model codellama/CodeLlama-13b-Instruct-hf...
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:39 [gpu_model_runner.py:1985] Loading model from scratch...
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:39 [gpu_model_runner.py:1985] Loading model from scratch...
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:39 [cuda.py:328] Using Flash Attention backend on V1 engine.
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:39 [cuda.py:328] Using Flash Attention backend on V1 engine.
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:39 [weight_utils.py:296] Using model weights format ['*.safetensors']
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:39 [weight_utils.py:296] Using model weights format ['*.safetensors']
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m Loading safetensors checkpoint shards:   0% Completed | 0/3 [00:00<?, ?it/s]
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m Loading safetensors checkpoint shards:  33% Completed | 1/3 [00:01<00:02,  1.28s/it]
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m Loading safetensors checkpoint shards:  67% Completed | 2/3 [00:02<00:01,  1.08s/it]
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:43 [default_loader.py:262] Loading weights took 3.62 seconds
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m Loading safetensors checkpoint shards: 100% Completed | 3/3 [00:03<00:00,  1.19s/it]
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m Loading safetensors checkpoint shards: 100% Completed | 3/3 [00:03<00:00,  1.18s/it]
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m 
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:43 [default_loader.py:262] Loading weights took 3.67 seconds
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:43 [gpu_model_runner.py:2007] Model loading took 12.2637 GiB and 4.235815 seconds
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:43 [gpu_model_runner.py:2007] Model loading took 12.2637 GiB and 4.497047 seconds
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:52 [backends.py:548] Using cache directory: /home/ubuntu/.cache/vllm/torch_compile_cache/0c1aa4d031/rank_1_0/backbone for vLLM's torch.compile
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:52 [backends.py:559] Dynamo bytecode transform time: 7.96 s
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:52 [backends.py:548] Using cache directory: /home/ubuntu/.cache/vllm/torch_compile_cache/0c1aa4d031/rank_0_0/backbone for vLLM's torch.compile
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:52 [backends.py:559] Dynamo bytecode transform time: 8.20 s
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:00:58 [backends.py:161] Directly load the compiled graph(s) for dynamic shape from the cache, took 5.525 s
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:00:58 [backends.py:161] Directly load the compiled graph(s) for dynamic shape from the cache, took 5.511 s
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:01:01 [monitor.py:34] torch.compile takes 7.96 s in total
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:01:01 [monitor.py:34] torch.compile takes 8.20 s in total
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:01:02 [gpu_worker.py:276] Available KV cache memory: 56.07 GiB
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:01:02 [gpu_worker.py:276] Available KV cache memory: 56.07 GiB
[1;36m(EngineCore_0 pid=3071129)[0;0m INFO 08-21 05:01:03 [kv_cache_utils.py:849] GPU KV cache size: 146,976 tokens
[1;36m(EngineCore_0 pid=3071129)[0;0m INFO 08-21 05:01:03 [kv_cache_utils.py:853] Maximum concurrency for 4,096 tokens per request: 35.88x
[1;36m(EngineCore_0 pid=3071129)[0;0m INFO 08-21 05:01:03 [kv_cache_utils.py:849] GPU KV cache size: 146,976 tokens
[1;36m(EngineCore_0 pid=3071129)[0;0m INFO 08-21 05:01:03 [kv_cache_utils.py:853] Maximum concurrency for 4,096 tokens per request: 35.88x
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):   0%|          | 0/67 [00:00<?, ?it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):   4%|▍         | 3/67 [00:00<00:02, 23.33it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):   9%|▉         | 6/67 [00:00<00:02, 23.79it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  13%|█▎        | 9/67 [00:00<00:02, 23.98it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  18%|█▊        | 12/67 [00:00<00:02, 23.87it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  22%|██▏       | 15/67 [00:00<00:02, 24.17it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  27%|██▋       | 18/67 [00:00<00:02, 23.98it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  31%|███▏      | 21/67 [00:00<00:01, 24.52it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  36%|███▌      | 24/67 [00:00<00:01, 24.34it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  40%|████      | 27/67 [00:01<00:01, 23.98it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  45%|████▍     | 30/67 [00:01<00:01, 23.09it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  49%|████▉     | 33/67 [00:01<00:01, 22.54it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  54%|█████▎    | 36/67 [00:01<00:01, 22.33it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  58%|█████▊    | 39/67 [00:01<00:01, 22.00it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  63%|██████▎   | 42/67 [00:01<00:01, 21.81it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  67%|██████▋   | 45/67 [00:01<00:00, 22.06it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  72%|███████▏  | 48/67 [00:02<00:00, 22.00it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  76%|███████▌  | 51/67 [00:02<00:00, 21.83it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  81%|████████  | 54/67 [00:02<00:00, 22.05it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  85%|████████▌ | 57/67 [00:02<00:00, 22.04it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  90%|████████▉ | 60/67 [00:02<00:00, 22.34it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  94%|█████████▍| 63/67 [00:02<00:00, 22.48it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE):  99%|█████████▊| 66/67 [00:02<00:00, 23.09it/s]Capturing CUDA graphs (mixed prefill-decode, PIECEWISE): 100%|██████████| 67/67 [00:02<00:00, 22.92it/s]
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:01:06 [custom_all_reduce.py:196] Registering 5427 cuda graph addresses
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:01:06 [custom_all_reduce.py:196] Registering 5427 cuda graph addresses
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP0 pid=3071135)[0;0m INFO 08-21 05:01:06 [gpu_model_runner.py:2708] Graph capturing finished in 3 secs, took 0.71 GiB
[1;36m(EngineCore_0 pid=3071129)[0;0m [1;36m(VllmWorker TP1 pid=3071137)[0;0m INFO 08-21 05:01:06 [gpu_model_runner.py:2708] Graph capturing finished in 3 secs, took 0.71 GiB
[1;36m(EngineCore_0 pid=3071129)[0;0m INFO 08-21 05:01:06 [core.py:214] init engine (profile, create kv cache, warmup model) took 22.46 seconds
INFO 08-21 05:01:07 [llm.py:298] Supported_tasks: ['generate']
Translating 221 files...
  0%|          | 0/221 [00:00<?, ?it/s]100%|██████████| 221/221 [00:00<00:00, 5292.54it/s]
Adding requests:   0%|          | 0/221 [00:00<?, ?it/s]Adding requests:  64%|██████▍   | 142/221 [00:00<00:00, 1419.80it/s]Adding requests: 100%|██████████| 221/221 [00:00<00:00, 700.35it/s] 
Processed prompts:   0%|          | 0/221 [00:00<?, ?it/s, est. speed input: 0.00 toks/s, output: 0.00 toks/s]Processed prompts:   0%|          | 1/221 [00:08<32:41,  8.91s/it, est. speed input: 36.68 toks/s, output: 24.34 toks/s]Processed prompts:   1%|          | 2/221 [00:09<15:30,  4.25s/it, est. speed input: 61.11 toks/s, output: 46.97 toks/s]Processed prompts:   1%|▏         | 3/221 [00:11<11:12,  3.08s/it, est. speed input: 163.85 toks/s, output: 66.32 toks/s]Processed prompts:   2%|▏         | 4/221 [00:11<06:58,  1.93s/it, est. speed input: 194.02 toks/s, output: 91.91 toks/s]Processed prompts:   3%|▎         | 7/221 [00:11<02:40,  1.33it/s, est. speed input: 281.37 toks/s, output: 169.31 toks/s]Processed prompts:   4%|▎         | 8/221 [00:12<02:12,  1.61it/s, est. speed input: 301.84 toks/s, output: 193.27 toks/s]Processed prompts:   4%|▍         | 9/221 [00:12<02:00,  1.77it/s, est. speed input: 320.78 toks/s, output: 213.78 toks/s]Processed prompts:   5%|▍         | 10/221 [00:12<01:44,  2.02it/s, est. speed input: 355.70 toks/s, output: 235.51 toks/s]Processed prompts:   6%|▌         | 13/221 [00:13<01:00,  3.43it/s, est. speed input: 426.28 toks/s, output: 308.36 toks/s]Processed prompts:   7%|▋         | 15/221 [00:13<00:53,  3.84it/s, est. speed input: 472.27 toks/s, output: 351.74 toks/s]Processed prompts:   8%|▊         | 18/221 [00:13<00:36,  5.55it/s, est. speed input: 551.36 toks/s, output: 426.09 toks/s]Processed prompts:   9%|▊         | 19/221 [00:13<00:38,  5.22it/s, est. speed input: 576.25 toks/s, output: 445.19 toks/s]Processed prompts:   9%|▉         | 20/221 [00:14<00:41,  4.81it/s, est. speed input: 594.74 toks/s, output: 463.56 toks/s]Processed prompts:  10%|█         | 23/221 [00:14<00:28,  7.04it/s, est. speed input: 662.87 toks/s, output: 538.08 toks/s]Processed prompts:  11%|█         | 24/221 [00:14<00:28,  6.95it/s, est. speed input: 695.62 toks/s, output: 559.53 toks/s]Processed prompts:  12%|█▏        | 26/221 [00:14<00:23,  8.13it/s, est. speed input: 775.27 toks/s, output: 606.93 toks/s]Processed prompts:  13%|█▎        | 28/221 [00:14<00:22,  8.71it/s, est. speed input: 877.18 toks/s, output: 652.58 toks/s]Processed prompts:  14%|█▎        | 30/221 [00:15<00:21,  8.95it/s, est. speed input: 917.26 toks/s, output: 696.83 toks/s]Processed prompts:  14%|█▍        | 32/221 [00:15<00:18, 10.31it/s, est. speed input: 953.40 toks/s, output: 744.45 toks/s]Processed prompts:  15%|█▌        | 34/221 [00:15<00:15, 12.05it/s, est. speed input: 992.89 toks/s, output: 793.06 toks/s]Processed prompts:  16%|█▋        | 36/221 [00:15<00:17, 10.31it/s, est. speed input: 1054.76 toks/s, output: 833.63 toks/s]Processed prompts:  17%|█▋        | 38/221 [00:15<00:16, 11.34it/s, est. speed input: 1104.07 toks/s, output: 879.90 toks/s]Processed prompts:  19%|█▊        | 41/221 [00:15<00:12, 13.88it/s, est. speed input: 1159.33 toks/s, output: 952.16 toks/s]Processed prompts:  19%|█▉        | 43/221 [00:16<00:14, 12.23it/s, est. speed input: 1221.75 toks/s, output: 993.25 toks/s]Processed prompts:  20%|██        | 45/221 [00:16<00:16, 10.97it/s, est. speed input: 1245.90 toks/s, output: 1033.19 toks/s]Processed prompts:  21%|██▏       | 47/221 [00:16<00:14, 11.97it/s, est. speed input: 1311.34 toks/s, output: 1078.66 toks/s]Processed prompts:  22%|██▏       | 49/221 [00:16<00:13, 13.19it/s, est. speed input: 1346.94 toks/s, output: 1124.77 toks/s]Processed prompts:  23%|██▎       | 51/221 [00:16<00:12, 13.34it/s, est. speed input: 1377.89 toks/s, output: 1168.44 toks/s]Processed prompts:  24%|██▍       | 53/221 [00:16<00:11, 14.69it/s, est. speed input: 1417.05 toks/s, output: 1214.46 toks/s]Processed prompts:  25%|██▍       | 55/221 [00:16<00:10, 15.69it/s, est. speed input: 1460.33 toks/s, output: 1260.13 toks/s]Processed prompts:  26%|██▌       | 57/221 [00:17<00:10, 15.89it/s, est. speed input: 1490.04 toks/s, output: 1300.81 toks/s]Processed prompts:  27%|██▋       | 60/221 [00:17<00:09, 17.16it/s, est. speed input: 1552.44 toks/s, output: 1369.00 toks/s]Processed prompts:  29%|██▊       | 63/221 [00:17<00:08, 18.44it/s, est. speed input: 1609.95 toks/s, output: 1437.54 toks/s]Processed prompts:  29%|██▉       | 65/221 [00:17<00:08, 18.60it/s, est. speed input: 1647.59 toks/s, output: 1482.16 toks/s]Processed prompts:  30%|███       | 67/221 [00:17<00:10, 15.33it/s, est. speed input: 1704.24 toks/s, output: 1516.93 toks/s]Processed prompts:  31%|███       | 69/221 [00:17<00:10, 14.20it/s, est. speed input: 1744.74 toks/s, output: 1555.50 toks/s]Processed prompts:  32%|███▏      | 71/221 [00:17<00:09, 15.10it/s, est. speed input: 1782.47 toks/s, output: 1598.97 toks/s]Processed prompts:  34%|███▍      | 75/221 [00:18<00:07, 19.97it/s, est. speed input: 1857.94 toks/s, output: 1694.17 toks/s]Processed prompts:  36%|███▌      | 79/221 [00:18<00:07, 18.73it/s, est. speed input: 1928.10 toks/s, output: 1778.22 toks/s]Processed prompts:  37%|███▋      | 81/221 [00:18<00:08, 16.43it/s, est. speed input: 1958.43 toks/s, output: 1814.83 toks/s]Processed prompts:  38%|███▊      | 85/221 [00:18<00:07, 18.48it/s, est. speed input: 2023.68 toks/s, output: 1904.61 toks/s]Processed prompts:  40%|████      | 89/221 [00:18<00:05, 22.22it/s, est. speed input: 2128.83 toks/s, output: 2000.31 toks/s]Processed prompts:  42%|████▏     | 92/221 [00:19<00:07, 18.00it/s, est. speed input: 2164.95 toks/s, output: 2054.57 toks/s]Processed prompts:  43%|████▎     | 95/221 [00:19<00:07, 16.51it/s, est. speed input: 2201.36 toks/s, output: 2101.95 toks/s]Processed prompts:  44%|████▍     | 98/221 [00:19<00:07, 17.01it/s, est. speed input: 2283.15 toks/s, output: 2165.56 toks/s]Processed prompts:  46%|████▌     | 101/221 [00:19<00:06, 19.20it/s, est. speed input: 2338.30 toks/s, output: 2235.19 toks/s]Processed prompts:  48%|████▊     | 105/221 [00:19<00:04, 23.30it/s, est. speed input: 2463.02 toks/s, output: 2325.77 toks/s]Processed prompts:  49%|████▉     | 108/221 [00:19<00:04, 23.18it/s, est. speed input: 2529.22 toks/s, output: 2392.38 toks/s]Processed prompts:  50%|█████     | 111/221 [00:19<00:05, 19.08it/s, est. speed input: 2561.91 toks/s, output: 2434.33 toks/s]Processed prompts:  52%|█████▏    | 114/221 [00:20<00:06, 17.64it/s, est. speed input: 2613.04 toks/s, output: 2492.34 toks/s]Processed prompts:  52%|█████▏    | 116/221 [00:20<00:08, 11.80it/s, est. speed input: 2606.14 toks/s, output: 2496.29 toks/s]Processed prompts:  53%|█████▎    | 118/221 [00:20<00:09, 10.31it/s, est. speed input: 2625.99 toks/s, output: 2519.46 toks/s]Processed prompts:  55%|█████▌    | 122/221 [00:21<00:10,  9.79it/s, est. speed input: 2659.78 toks/s, output: 2563.57 toks/s]Processed prompts:  56%|█████▌    | 124/221 [00:21<00:09,  9.90it/s, est. speed input: 2678.71 toks/s, output: 2596.97 toks/s]Processed prompts:  57%|█████▋    | 127/221 [00:21<00:10,  9.32it/s, est. speed input: 2689.71 toks/s, output: 2630.49 toks/s]Processed prompts:  59%|█████▉    | 131/221 [00:21<00:07, 12.51it/s, est. speed input: 2796.37 toks/s, output: 2718.92 toks/s]Processed prompts:  61%|██████    | 134/221 [00:22<00:06, 12.66it/s, est. speed input: 2847.90 toks/s, output: 2776.56 toks/s]Processed prompts:  62%|██████▏   | 136/221 [00:22<00:07, 10.66it/s, est. speed input: 2841.52 toks/s, output: 2784.36 toks/s]Processed prompts:  62%|██████▏   | 138/221 [00:22<00:08,  9.89it/s, est. speed input: 2849.03 toks/s, output: 2804.80 toks/s]Processed prompts:  63%|██████▎   | 140/221 [00:22<00:07, 10.17it/s, est. speed input: 2913.75 toks/s, output: 2841.43 toks/s]Processed prompts:  64%|██████▍   | 142/221 [00:23<00:07, 10.43it/s, est. speed input: 2921.36 toks/s, output: 2867.73 toks/s]Processed prompts:  66%|██████▌   | 145/221 [00:23<00:05, 13.46it/s, est. speed input: 3041.30 toks/s, output: 2942.62 toks/s]Processed prompts:  67%|██████▋   | 147/221 [00:23<00:06, 11.02it/s, est. speed input: 3060.36 toks/s, output: 2958.16 toks/s]Processed prompts:  68%|██████▊   | 150/221 [00:23<00:05, 12.37it/s, est. speed input: 3107.19 toks/s, output: 3001.49 toks/s]Processed prompts:  69%|██████▉   | 152/221 [00:24<00:07,  9.79it/s, est. speed input: 3124.33 toks/s, output: 3020.21 toks/s]Processed prompts:  70%|███████   | 155/221 [00:24<00:06,  9.82it/s, est. speed input: 3174.03 toks/s, output: 3045.92 toks/s]Processed prompts:  71%|███████   | 157/221 [00:24<00:06, 10.65it/s, est. speed input: 3214.77 toks/s, output: 3079.75 toks/s]Processed prompts:  72%|███████▏  | 159/221 [00:24<00:05, 10.55it/s, est. speed input: 3269.57 toks/s, output: 3116.46 toks/s]Processed prompts:  73%|███████▎  | 162/221 [00:24<00:05, 11.08it/s, est. speed input: 3317.41 toks/s, output: 3171.89 toks/s]Processed prompts:  75%|███████▍  | 165/221 [00:25<00:05, 10.04it/s, est. speed input: 3334.61 toks/s, output: 3208.90 toks/s]Processed prompts:  76%|███████▌  | 167/221 [00:25<00:04, 10.98it/s, est. speed input: 3391.14 toks/s, output: 3254.89 toks/s]Processed prompts:  76%|███████▋  | 169/221 [00:25<00:04, 11.61it/s, est. speed input: 3433.23 toks/s, output: 3293.40 toks/s]Processed prompts:  78%|███████▊  | 173/221 [00:25<00:03, 12.68it/s, est. speed input: 3497.82 toks/s, output: 3371.04 toks/s]Processed prompts:  79%|███████▉  | 175/221 [00:25<00:03, 12.44it/s, est. speed input: 3517.01 toks/s, output: 3400.80 toks/s]Processed prompts:  80%|████████  | 177/221 [00:26<00:04, 10.04it/s, est. speed input: 3556.79 toks/s, output: 3423.86 toks/s]Processed prompts:  81%|████████  | 179/221 [00:26<00:03, 11.32it/s, est. speed input: 3573.85 toks/s, output: 3473.80 toks/s]Processed prompts:  82%|████████▏ | 182/221 [00:26<00:03, 10.39it/s, est. speed input: 3602.84 toks/s, output: 3516.71 toks/s]Processed prompts:  84%|████████▎ | 185/221 [00:26<00:03, 11.85it/s, est. speed input: 3655.99 toks/s, output: 3573.39 toks/s]Processed prompts:  85%|████████▍ | 187/221 [00:27<00:03,  9.30it/s, est. speed input: 3641.47 toks/s, output: 3586.72 toks/s]Processed prompts:  86%|████████▌ | 189/221 [00:27<00:03,  9.57it/s, est. speed input: 3666.34 toks/s, output: 3628.83 toks/s]Processed prompts:  86%|████████▋ | 191/221 [00:27<00:02, 10.27it/s, est. speed input: 3690.31 toks/s, output: 3667.82 toks/s]Processed prompts:  87%|████████▋ | 193/221 [00:27<00:03,  8.29it/s, est. speed input: 3683.53 toks/s, output: 3673.52 toks/s]Processed prompts:  88%|████████▊ | 195/221 [00:28<00:02,  9.45it/s, est. speed input: 3700.92 toks/s, output: 3715.21 toks/s]Processed prompts:  89%|████████▉ | 197/221 [00:29<00:05,  4.66it/s, est. speed input: 3637.47 toks/s, output: 3651.77 toks/s]Processed prompts:  90%|████████▉ | 198/221 [00:29<00:06,  3.48it/s, est. speed input: 3587.09 toks/s, output: 3610.21 toks/s]Processed prompts:  90%|█████████ | 199/221 [00:29<00:06,  3.59it/s, est. speed input: 3588.37 toks/s, output: 3617.80 toks/s]Processed prompts:  90%|█████████ | 200/221 [00:30<00:05,  4.16it/s, est. speed input: 3601.48 toks/s, output: 3633.54 toks/s]Processed prompts:  91%|█████████ | 201/221 [00:30<00:04,  4.45it/s, est. speed input: 3613.34 toks/s, output: 3641.34 toks/s]Processed prompts:  91%|█████████▏| 202/221 [00:30<00:06,  2.89it/s, est. speed input: 3542.41 toks/s, output: 3588.23 toks/s]Processed prompts:  93%|█████████▎| 205/221 [00:31<00:04,  3.65it/s, est. speed input: 3563.02 toks/s, output: 3622.82 toks/s]Processed prompts:  93%|█████████▎| 206/221 [00:56<01:17,  5.17s/it, est. speed input: 2008.94 toks/s, output: 2079.83 toks/s]Processed prompts:  94%|█████████▎| 207/221 [00:58<01:03,  4.50s/it, est. speed input: 1949.90 toks/s, output: 2059.10 toks/s]Processed prompts:  94%|█████████▍| 208/221 [00:58<00:45,  3.47s/it, est. speed input: 1957.61 toks/s, output: 2107.58 toks/s]Processed prompts:  95%|█████████▍| 209/221 [01:02<00:41,  3.46s/it, est. speed input: 1859.73 toks/s, output: 2048.22 toks/s]Processed prompts:  95%|█████████▌| 210/221 [01:02<00:29,  2.64s/it, est. speed input: 1856.88 toks/s, output: 2091.52 toks/s]Processed prompts:  95%|█████████▌| 211/221 [01:03<00:20,  2.05s/it, est. speed input: 1850.80 toks/s, output: 2131.73 toks/s]Processed prompts:  96%|█████████▌| 212/221 [01:03<00:14,  1.64s/it, est. speed input: 1840.33 toks/s, output: 2167.76 toks/s]Processed prompts:  97%|█████████▋| 214/221 [01:04<00:07,  1.02s/it, est. speed input: 1839.85 toks/s, output: 2263.64 toks/s]Processed prompts:  98%|█████████▊| 216/221 [01:04<00:03,  1.44it/s, est. speed input: 1842.70 toks/s, output: 2364.90 toks/s]Processed prompts:  98%|█████████▊| 217/221 [01:04<00:02,  1.70it/s, est. speed input: 1842.52 toks/s, output: 2414.24 toks/s]Processed prompts:  99%|█████████▊| 218/221 [01:05<00:01,  1.97it/s, est. speed input: 1841.34 toks/s, output: 2462.72 toks/s]Processed prompts:  99%|█████████▉| 219/221 [01:05<00:01,  2.00it/s, est. speed input: 1832.44 toks/s, output: 2502.19 toks/s]Processed prompts: 100%|█████████▉| 220/221 [01:05<00:00,  2.51it/s, est. speed input: 1836.27 toks/s, output: 2553.11 toks/s]Processed prompts: 100%|██████████| 221/221 [01:06<00:00,  1.61it/s, est. speed input: 1808.69 toks/s, output: 2562.35 toks/s]Processed prompts: 100%|██████████| 221/221 [01:06<00:00,  1.61it/s, est. speed input: 1808.69 toks/s, output: 2562.35 toks/s]Processed prompts: 100%|██████████| 221/221 [01:06<00:00,  3.30it/s, est. speed input: 1808.69 toks/s, output: 2562.35 toks/s]
+ python3 clean_generations_translation.py --model codellama/CodeLlama-13b-Instruct-hf --dataset Avatar --source_lang Python --target_lang Java --remove_prompt --use_test
  0%|          | 0/221 [00:00<?, ?it/s]import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class atcoder_ABC146_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[][] graph = new int[n][n];
        for (int i = 0; i < n - 1; i++) {
            int a = scanner.nextInt() - 1;
            int b = scanner.nextInt() - 1;
            graph[a][b] = 1;
            graph[b][a] = 1;
        }
        int start = scanner.nextInt() - 1;
        int[] visited = new int[n];
        ArrayDeque<Integer> queue = new ArrayDeque<>();
        queue.add(start);
        visited[start] = 1;
        int k = 0;
        Map<Integer, Integer> node2color = new HashMap<>();
        while (!queue.isEmpty()) {
            int q = queue.remove();
            int color = 0;
            for (int nex : graph[q]) {
                if (visited[nex]) {
                    continue;
                }
                visited[nex] = 1;
                color++;
                if (color == node2color.getOrDefault(q, 0)) {
                    color++;
                }
                node2color.put(nex, color);
                queue.add(nex);
            }
            k = Math.max(k, color);
        }
        System.out.println(k);
        for (int i = 0; i < n; i++) {
            System.out.println(node2color.getOrDefault(i, 0));
        }
    }
}
import java.util.Date;
import java.text.SimpleDateFormat;
import java.util.Base64;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.List;
import java.util.Arrays;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.util.stream.Double
import java.util.concurrent.Thread;
import java.util.concurrent.Queue;
import java.util.Arrays;

public class atcoder_AGC028_B {
    public static void main(String[] args) {
        // Create a new thread for the calculateValue function
        Thread calculateValueThread = new Thread(new Runnable() {
            @Override
            public void run() {
                // Calculate the value of the operands
                int operandOne = 7;
                int operandTwo = 10;
                int operandThree = 9;
                int result = calculateValue(operandOne, operandThree, operandTwo);

                // Add the result to the queue
                Queue<Integer> queue = new Queue<>();
                queue.add(result);
            }
        });

        // Start the thread and wait for it to finish
        calculateValueThread.start();
        try {
            calculateValueThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Get the result from the queue
        int result = queue.poll();

        // Print the result
        System.out.println(result);
    }

    private static int calculateValue(int operandOne, int operandThree, int operandTwo) {
        return (int) Math.pow(operandTwo, operandThree) + operandOne;
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_569_A {
    public static void main(String[] args) {
        int targetValue = 12351;
        int s = 1223;
        int q = 6;
        int ans = 0;

        while (s < targetValue) {
            BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

            ExecutorService executor = Executors.newSingleThreadExecutor();
            Future<Integer> future = executor.submit(() -> {
                int result = calculateProduct(s, q);
                queue.put(result);
                return result;
            });

            try {
                int productResult = future.get(10, TimeUnit.SECONDS);
                s = productResult;
                ans++;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        System.out.println(ans);
    }

    private static int calculateProduct(int s, int q) {
        return s * q;
    }
}
import java.util.Scanner;

public class atcoder_ABC112_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] locations = new int[n][3];
        for (int i = 0; i < n; i++) {
            locations[i][0] = sc.nextInt();
            locations[i][1] = sc.nextInt();
            locations[i][2] = sc.nextInt();
        }
        String result = solve(n, locations);
        System.out.println(result);
    }

    public static String solve(int n, int[][] locations) {
        int x0 = 0;
        int y0 = 0;
        int baseHeight = 0;
        for (int i = 0; i < n; i++) {
            if (locations[i][2] > 0) {
                x0 = locations[i][0];
                y0 = locations[i][1];
                baseHeight = locations[i][2];
                break;
            }
        }
        int[][] cands = new int[101][101];
        for (int i = 0; i < 101; i++) {
            for (int j = 0; j < 101; j++) {
                cands[i][j] = baseHeight + Math.abs(i - x0) + Math.abs(j - y0);
            }
        }
        for (int i = 0; i < n; i++) {
            int x = locations[i][0];
            int y = locations[i][1];
            int h = locations[i][2];
            for (int j = 0; j < 101; j++) {
                for (int k = 0; k < 101; k++) {
                    if (cands[j][k] > h) {
                        cands[j][k] = 0;
                    }
                }
            }
        }
        int xx = 0;
        int yy = 0;
        int hh = 0;
        for (int i = 0; i < 101; i++) {
            for (int j = 0; j < 101; j++) {
                if (cands[i][j] > hh) {
                    xx = i;
                    yy = j;
                    hh = cands[i][j];
                }
            }
        }
        return String.format("%d %d %d", xx, yy, hh);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class atcoder_ABC104_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int D = scanner.nextInt();
        int G = scanner.nextInt();
        List<int[]> PC = new ArrayList<>();
        for (int i = 0; i < D; i++) {
            int[] problem = new int[2];
            problem[0] = scanner.nextInt();
            problem[1] = scanner.nextInt();
            PC.add(problem);
        }
        int minProblemsSolved = 1000000000;
        int dummyCondition1 = 642;
        int dummyCondition2 = 322;
        for (int problemSetMask = 0; problemSetMask < (1 << D); problemSetMask++) {
            int score = 0;
            int problem = 0;
            for (int j = 0; j < D; j++) {
                if ((problemSetMask >> j & 1) == 1) {
                    score += 100 * (j + 1) * PC.get(j)[0] + PC.get(j)[1];
                    problem += PC.get(j)[0];
                }
            }
            if (dummyCondition1 & dummyCondition2) {
                if (score > G) {
                    continue;
                }
            }
            int left = G - score;
            for (int j = 0; j < D; j++) {
                if ((problemSetMask >> j & 1) == 1) {
                    continue;
                }
                if (left > 100 * (j + 1) * PC.get(j)[0] + PC.get(j)[1]) {
                    continue;
                } else {
                    int tmp = (left + 100 * (j + 1) - 1) / (100 * (j + 1));
                    minProblemsSolved = Math.min(minProblemsSolved, problem + Math.min(tmp, PC.get(j)[0]));
                }
            }
        }
        System.out.println(minProblemsSolved);
    }
}
import java.util.Date;
import java.util.Base64;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util
import java.util.Scanner;
import java.util.Arrays;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class atcoder_ABC105_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        int[] A = new int[N];
        for (int i = 0; i < N; i++) {
            A[i] = scanner.nextInt();
        }
        Arrays.sort(A);
        int[] arrayWithZeroAndA = new int[N + 1];
        arrayWithZeroAndA[0] = 0;
        System.arraycopy(A, 0, arrayWithZeroAndA, 1, N);
        Queue<int[]> cumulativeRemaindersQueue = new ConcurrentLinkedQueue<>();
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        Future<int[]> future = executorService.submit(() -> {
            int[] cumulativeRemainders = calculateCumulativeRemainders(arrayWithZeroAndA, M);
            cumulativeRemaindersQueue.add(cumulativeRemainders);
            return cumulativeRemainders;
        });
        try {
            int[] cumulativeRemainders = future.get(10, TimeUnit.SECONDS);
            int[] cumRemainders = cumulativeRemaindersQueue.poll();
            int[] remainderCounts = new int[M];
            for (int i = 0; i < N; i++) {
                remainderCounts[cumRemainders[i] % M]++;
            }
            int combinations = 0;
            for (int i = 0; i < M; i++) {
                combinations += remainderCounts[i] * (remainderCounts[i] - 1) / 2;
            }
            System.out.println(combinations);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executorService.shutdown();
        }
    }

    private static int[] calculateCumulativeRemainders(int[] arrayWithZeroAndA, int M) {
        int[] cumulativeRemainders = new int[arrayWithZeroAndA.length];
        for (int i = 0; i < arrayWithZeroAndA.length; i++) {
            cumulativeRemainders[i] = (arrayWithZeroAndA[i] % M + cumulativeRemainders[i - 1]) % M;
        }
        return cumulativeRemainders;
    }
}
import java.util.Arrays;
import java.util.Random;
import org.apache.commons.math3.stat.inference.TTest;

public class atcoder_AGC033_B {
    public static void main(String[] args) {
        // Read input
        String[] input = args[0].split(" ");
        int H = Integer.parseInt(input[0]);
        int W = Integer.parseInt(input[1]);
        int N = Integer.parseInt(input[2]);
        int[] s_r = new int[3];
        int[] s_c = new int[3];
        for (int i = 0; i < 3; i++) {
            s_r[i] = Integer.parseInt(input[i + 3]);
            s_c[i] = Integer.parseInt(input[i + 6]);
        }
        String S = input[9];
        String T = input[10];

        // Perform t-test
        TTest ttest = new TTest();
        double[] s_r_array = new double[s_r.length];
        double[] s_c_array = new double[s_c.length];
        for (int i = 0; i < s_r.length; i++) {
            s_r_array[i] = s_r[i];
            s_c_array[i] = s_c[i];
        }
        double t = ttest.tTest(s_r_array, s_c_array);

        // Print result
        if (t < 0.05) {
            System.out.println("NO");
        } else {
            System.out.println("YES");
        }
    }
}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;

public class codeforces_55_A {
    private int divisor;
    private int inputNumber;
    private int result;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public DivisionOperation(int divisor, int inputNumber) {
        this.divisor = divisor;
        this.inputNumber = inputNumber;
    }

    public int getResult() {
        return result;
    }

    public void run() {
        lock.lock();
        try {
            result = inputNumber / divisor;
            condition.signal();
        } finally {
            lock.unlock();
        }
    }
}

public class codeforces_55_A {
    public static void main(String[] args) {
        int conditionOne = 368;
        int conditionTwo = 165;
        int inputNumber = Integer.parseInt(args[0]);
        while (inputNumber % 2 == 0) {
            int divisor = 2;
            DivisionOperation divisionOperation = new DivisionOperation(divisor, inputNumber);
            Thread thread = new Thread(divisionOperation);
            thread.start();
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            inputNumber = divisionOperation.getResult();
        }
        if (conditionOne & conditionTwo) {
            if (inputNumber == 1) {
                System.out.println("YES");
            } else {
                System.out.println("NO");
            }
        }
    }
}
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ABC106_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BlockingQueue<String> queue_S0 = new LinkedBlockingQueue<>();

        Thread thread_S0 = new Thread(() -> {
            String intermediate_result = scanner.nextLine();
            queue_S0.put(intermediate_result);
        });
        thread_S0.start();
        thread_S0.join();
        String result_S0 = queue_S0.take();
        String s = result_S0;
        BlockingQueue<Integer> queue_I0 = new LinkedBlockingQueue<>();

        Thread thread_I0 = new Thread(() -> {
            int intermediate_result = scanner.nextInt();
            queue_I0.put(intermediate_result);
        });
        thread_I0.start();
        thread_I0.join();
        int result_I0 = queue_I0.take();
        int k = result_I0;
        int l = 0;
        for (char c : s.toCharArray()) {
            if (c != '1') {
                break;
            }
            l++;
        }
        if (l >= k) {
            return 1;
        }
        return s.charAt(l);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Set;

public class codeforces_404_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int matrixSize = sc.nextInt();
        ArrayList<String> s = new ArrayList<>();

        for (int i = 0; i < matrixSize; i++) {
            String k = sc.next();
            s.add(k);
        }

        ArrayList<String> d1 = new ArrayList<>();
        ArrayList<String> d2 = new ArrayList<>();
        Set<String> rem = new HashSet<>();

        for (int i = 0; i < matrixSize; i++) {
            for (int j = 0; j < matrixSize; j++) {
                if (i == j) {
                    d1.add(s.get(i).charAt(j));
                } else if (i == matrixSize - j - 1) {
                    d2.add(s.get(i).charAt(j));
                } else {
                    rem.add(s.get(i).charAt(j));
                }
            }
        }

        if (rem.size() != 1) {
            System.out.println("NO");
        } else if (!d1.equals(d2)) {
            System.out.println("NO");
        } else if (d1.size() != 1) {
            System.out.println("NO");
        } else if (!rem.equals(d1)) {
            System.out.println("NO");
        } else {
            System.out.println("YES");
        }
    }
}
import java.util.Scanner;

public class atcoder_AGC046_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int A = scanner.nextInt();
        int B = scanner.nextInt();
        int C = scanner.nextInt();
        int D = scanner.nextInt();
        int m = 998244353;
        int[][] d = new int[C + 1][D + 1];
        d[A][B] = 1;
        for (int row = A; row <= C; row++) {
            for (int j = B; j <= D; j++) {
                int currRowPrevColVal = d[row][j - 1];
                int prevRowVal = d[row - 1][j];
                int prevRowPrevColVal = d[row - 1][j - 1];
                int currRow = d[row];
                int prevRow = d[row - 1];
                int colIdx = 1;
                int rowIdx = 1;
                d[row][j] += calculateValue(rowIdx, j, m, row, currRowPrevColVal, colIdx, prevRowVal, prevRowPrevColVal);
            }
        }
        System.out.println(d[C][D]);
    }

    public static int calculateValue(int rowIdx, int j, int m, int row, int currRowPrevColVal, int colIdx, int prevRowVal, int prevRowPrevColVal) {
        return (currRowPrevColVal * row + prevRowVal * j - prevRowPrevColVal * (row - rowIdx) * (j - colIdx)) % m;
    }
}
import java.util.Scanner;

public class codeforces_7_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        int m = scanner.nextInt();
        int[] alocuente = new int[m];
        int ind = 1;
        int fourthCheck = 99;
        int sixthCheck = 940;
        int firstCheck = 977;
        int secondCheck = 289;
        int thirdCheck = 15;
        int fifthCheck = 698;

        for (int i = 0; i < t; i++) {
            String[] op = scanner.nextLine().split(" ");
            if (fourthCheck & sixthCheck) {
                if (op[0].equals("alloc")) {
                    int availableSlotCount = 0;
                    for (int j = 0; j < m; j++) {
                        if (alocuente[j] == 0) {
                            availableSlotCount++;
                            if (availableSlotCount == Integer.parseInt(op[1])) {
                                alocuente[j - Integer.parseInt(op[1]) + 1 : j + 1] = new int[Integer.parseInt(op[1])];
                                System.out.println(ind);
                                ind++;
                                break;
                            }
                        } else {
                            availableSlotCount = 0;
                        }
                    }
                    if (availableSlotCount == 0) {
                        System.out.println("NULL");
                    }
                }
            }
            if (firstCheck & secondCheck) {
                if (op[0].equals("erase")) {
                    int availableSlotCount = 0;
                    if (!alocuente.contains(Integer.parseInt(op[1])) || Integer.parseInt(op[1]) == 0) {
                        System.out.println("ILLEGAL_ERASE_ARGUMENT");
                    } else {
                        for (int j = 0; j < m; j++) {
                            if (Integer.parseInt(op[1]) > 0 && alocuente[j] == Integer.parseInt(op[1])) {
                                alocuente[j] = 0;
                            }
                        }
                    }
                }
            }
            if (thirdCheck & fifthCheck) {
                if (op[0].equals("defragment")) {
                    int emptyBlockCount = 0;
                    emptyBlockCount = alocuente.length - alocuente.length;
                    alocuente = alocuente.stream().filter(x -> x != 0).toArray();
                    for (int j = 0; j < emptyBlockCount; j++) {
                        alocuente.add(0);
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.Map;
import java.util.HashMap;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class codeforces_609_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[] lst = new int[n];
        for (int i = 0; i < n; i++) {
            lst[i] = scanner.nextInt();
        }
        Map<Integer, Integer> elementCounts = new HashMap<>();
        for (int i = 0; i < n; i++) {
            if (elementCounts.containsKey(lst[i])) {
                elementCounts.put(lst[i], elementCounts.get(lst[i]) + 1);
            } else {
                elementCounts.put(lst[i], 1);
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            if (elementCounts.get(lst[i]) > 1) {
                res += n - i - elementCounts.get(lst[i]);
                elementCounts.put(lst[i], elementCounts.get(lst[i]) - 1);
            } else {
                res += n - i - 1;
            }
        }
        System.out.println(res);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

public class atcoder_ABC162_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String s = scanner.nextLine();
        calculateRGBCombinations(n, s);
    }

    public static void calculateRGBCombinations(int n, String s) {
        char[] arr = s.toCharArray();
        int redCount = 0;
        int gNum = 0;
        int bNum = 0;
        for (char c : arr) {
            if (c == 'R') {
                redCount++;
            } else if (c == 'G') {
                gNum++;
            } else if (c == 'B') {
                bNum++;
            }
        }
        int sum = 0;
        for (int step = 1; step <= (int) Math.ceil(n / 2); step++) {
            for (int i = 0; i < n - 2 * step; i++) {
                String s = String.valueOf(arr[i]) + String.valueOf(arr[i + step]) + String.valueOf(arr[i + step * 2]);
                if (s.equals("RGB") || s.equals("RBG") || s.equals("BGR") || s.equals("BRG") || s.equals("GBR") || s.equals("GRB")) {
                    sum++;
                }
            }
        }
        System.out.println(redCount * gNum * bNum - sum);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Deque;
import java.util.LinkedList;

public class atcoder_AGC014_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] adj = new int[N + 1];
        for (int i = 0; i < N - 1; i++) {
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            adj[a] = b;
            adj[b] = a;
        }
        Deque<Integer> que = new LinkedList<>();
        que.add(1);
        boolean[] seen = new boolean[N + 1];
        seen[1] = true;
        int[] par = new int[N + 1];
        int[] childCount = new int[N + 1];
        while (!que.isEmpty()) {
            int v = que.removeFirst();
            for (int u : adj[v]) {
                if (!seen[u]) {
                    seen[u] = true;
                    par[u] = v;
                    childCount[v]++;
                    que.addLast(u);
                }
            }
        }
        Deque<Integer> seq = new LinkedList<>();
        for (int nodeIndex = 1; nodeIndex <= N; nodeIndex++) {
            if (childCount[nodeIndex] == 0) {
                seq.addLast(nodeIndex);
            }
        }
        while (!seq.isEmpty()) {
            int currentNode = seq.removeFirst();
            seen[currentNode] = false;
            if (!seen[par[currentNode]]) {
                System.out.println("First");
                return;
            }
            seen[par[currentNode]] = false;
            childCount[par[par[currentNode]]]--;
            if (childCount[par[par[currentNode]]] == 0) {
                seq.addLast(par[par[currentNode]]);
            }
        }
        System.out.println("Second");
    }
}
import java.util.Scanner;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;

public class atcoder_ABC151_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        char c = input.charAt(0);
        Queue<Character> queue = new LinkedList<>();
        Thread thread = new Thread(() -> {
            char result = solve(c);
            queue.add(result);
        });
        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        char result = queue.poll();
        if (result instanceof List) {
            List<Character> list = (List<Character>) result;
            int innerLoopBound = 522;
            int outerLoopBound = 521;
            for (int i = 0; i < outerLoopBound; i++) {
                for (char r : list) {
                    System.out.print(r);
                }
                System.out.println();
            }
        } else {
            System.out.println(result);
        }
    }

    private static char solve(char c) {
        String a = "abcdefghijklmnopqrstuvwxyz";
        int charIndex = a.indexOf(c);
        return a.charAt(charIndex + 1);
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.Arrays;
import java.util.stream.IntStream;

public class codeforces_581_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int[] inputArray = Arrays.stream(args[1].split(" ")).mapToInt(Integer::parseInt).toArray();
        int[] initialValue = new int[] { 0 };
        BlockingQueue<Integer> queueCalculateProduct0 = new LinkedBlockingQueue<>();

        Thread threadCalculateProduct0 = new Thread(() -> {
            int result = calculateProduct(initialValue, n);
            queueCalculateProduct0.put(result);
        });

        threadCalculateProduct0.start();
        threadCalculateProduct0.join();

        int resultCalculateProduct0 = queueCalculateProduct0.get();
        int[] resultArray = resultCalculateProduct0;
        int mx = inputArray[n - 1];

        for (int i = n - 2; i >= 0; i--) {
            resultArray[i] = Math.max(0, mx - inputArray[i] + 1);
            if (inputArray[i] > mx) {
                mx = inputArray[i];
            }
        }

        System.out.println(Arrays.toString(resultArray));
    }

    private static int calculateProduct(int[] initialValue, int n) {
        return initialValue[0] * n;
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Deque;
import java.util.ArrayDeque;

public class atcoder_ABC126_E {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        List<List<Integer>> edge = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            edge.add(new ArrayList<>());
        }
        for (int i = 0; i < M; i++) {
            int X = scanner.nextInt();
            int Y = scanner.nextInt();
            int Z = scanner.nextInt();
            edge.get(X).add(Y);
            edge.get(Y).add(X);
        }
        boolean[] used = new boolean[N];
        int ans = 0;
        int MaxIterationCheck = 200;
        int IntermediateCheck = 845;
        for (int i = 0; i < N; i++) {
            if (MaxIterationCheck & IntermediateCheck) {
                if (!used[i]) {
                    ans++;
                    Deque<Integer> queue = new ArrayDeque<>();
                    queue.add(i);
                    while (!queue.isEmpty()) {
                        int node = queue.removeFirst();
                        used[node] = true;
                        for (int nextnode : edge.get(node)) {
                            if (!used[nextnode]) {
                                queue.add(nextnode);
                            }
                        }
                    }
                }
            }
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class atcoder_ABC132_F {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int mod = 1000000007;
        int[] coef = new int[n];
        for (int i = 1; i <= n; i++) {
            coef[i] = n / i - n / (i + 1);
        }
        coef = Arrays.copyOf(coef, n);
        int[] dp = new int[k + 1][n];
        dp[0][0] = 1;
        for (int i = 1; i <= k; i++) {
            int tmp = 0;
            for (int reversedIndex = n - 1; reversedIndex >= 0; reversedIndex--) {
                tmp += dp[i - 1][n - 1 - reversedIndex];
                tmp %= mod;
                dp[i][reversedIndex] = coef[reversedIndex] * tmp;
                dp[i][reversedIndex] %= mod;
            }
        }
        System.out.println(Arrays.stream(dp[k]).sum() % mod);
    }
}
import java.util.Scanner;

public class codeforces_581_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int firstInput = scanner.nextInt();
        int secondInput = scanner.nextInt();
        int min = Math.min(firstInput, secondInput);
        int max = Math.max(firstInput, secondInput);
        int halfDiff = (max - min) / 2;
        System.out.println(min + " " + halfDiff);
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_92_A {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int remainder = Integer.parseInt(args[1]);
        int currentValue = 849;
        int divisor = 848;
        int operand = 1;
        BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();

        Thread threadSumOperands0 = new Thread(() -> {
            int result = sumOperands(operand, currentValue);
            resultQueue.put(result);
        });
        threadSumOperands0.start();
        threadSumOperands0.join();
        int sumResult = resultQueue.get();
        currentValue = sumResult;

        while (remainder >= i) {
            remainder = remainder - i;
            i = i % n + 1;
        }
        System.out.println(remainder);
    }

    private static int sumOperands(int operand, int currentValue) {
        return currentValue + operand;
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class atcoder_ABC170_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        String[] numbers = input.split(" ");
        List<Integer> list = new ArrayList<>();
        for (String number : numbers) {
            list.add(Integer.parseInt(number));
        }
        int checkerOne = 289;
        int checkerThree = 475;
        int checkerTwo = 828;
        int checkerFive = 409;
        int checkerFour = 430;
        int checkerSeven = 909;
        for (int i = 0; i < list.size(); i++) {
            if (checkerFour & checkerSeven) {
                if (checkerTwo & checkerFive) {
                    if (checkerOne & checkerThree) {
                        if (list.get(i) == 0) {
                            System.out.println(i + 1);
                            break;
                        }
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class codeforces_653_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int newItem = scanner.nextInt();
        int[] l = Arrays.stream(scanner.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        Arrays.sort(l);
        int secondChecker = 823;
        int sixthChecker = 566;
        int fourthChecker = 374;
        int fifthChecker = 591;
        int firstChecker = 870;
        int thirdChecker = 889;
        for (int currentItem : l) {
            if (firstChecker & thirdChecker) {
                if (fourthChecker & fifthChecker) {
                    if (secondChecker & sixthChecker) {
                        if (currentItem + 1 in l && currentItem + 2 in l) {
                            System.out.println("YES");
                            break;
                        }
                    }
                }
            }
        }
        System.out.println("NO");
    }
}
import java.util.Scanner;

public class codeforces_8_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String moves = scanner.nextLine();
        int x = 0, currentY = 0;
        int[][] dMovement = { { 0, -1 }, { 0, 1 }, { 1, 0 }, { -1, 0 } };
        boolean[][] d = new boolean[100][100];
        boolean bugFound = false;
        int firstCheck = 540;
        int checkTwo = 650;
        for (int i = 0; i < moves.length(); i++) {
            int tempX = x, tempY = currentY;
            x += dMovement[moves.charAt(i) - 'A'][0];
            currentY += dMovement[moves.charAt(i) - 'A'][1];
            if (firstCheck & checkTwo) {
                if (!d[x][currentY]) {
                    for (int j = 0; j < 4; j++) {
                        if (x + dMovement[j][0] != tempX && y + dMovement[j][1] != tempY && d[x + dMovement[j][0]][y + dMovement[j][1]]) {
                            bugFound = true;
                            break;
                        }
                    }
                } else {
                    bugFound = true;
                }
            }
            if (bugFound) {
                break;
            }
            d[x][currentY] = true;
        }
        if (firstCheck & checkOneB) {
            if (checkTwoA & checkTwoB) {
                if (checkThreeA & checkThreeB) {
                    if (bugFound) {
                        System.out.println("BUG");
                    } else {
                        System.out.println("OK");
                    }
                }
            }
        }
    }
}
import java.util.Scanner;

public class codeforces_146_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arrayLength = scanner.nextInt();
        int[] number = new int[arrayLength];
        for (int i = 0; i < arrayLength; i++) {
            number[i] = scanner.nextInt();
        }
        int h1 = 0;
        int h2 = 0;
        int x = 0;
        int outerLoopEnd = 738;
        int innerLoopEnd = 737;
        int firstCondition = 305;
        int thirdCondition = 108;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopEnd / innerLoopEnd; LoopIndexOut++) {
            for (int i = 0; i < arrayLength; i++) {
                if (firstCondition & thirdCondition) {
                    if (number[i] != 4 && number[i] != 7) {
                        System.out.println("NO");
                        x++;
                        break;
                    }
                }
                if (i < arrayLength / 2) {
                    h1 += number[i];
                } else {
                    h2 += number[i];
                }
            }
        }
        if (fourthCondition & fifthCondition) {
            if (secondCondition & isDivisible) {
                if (x == 0) {
                    if (h1 == h2) {
                        System.out.println("YES");
                    } else {
                        System.out.println("NO");
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.function.LongBiConsumer;
import java.util.function.DoubleBiConsumer;
import java.util.function.BooleanBiConsumer;
import java.util.function.IntBiFunction;
import java.util.function.LongBiFunction;
import java.util.function.DoubleBiFunction;
import java.util.function.BooleanBiFunction;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.function.LongBiConsumer;
import java.util.function.DoubleBiConsumer;
import java.util.function.BooleanBiConsumer;
import java.util.function.IntBiFunction;
import java.util.function.LongBiFunction;
import java.util.function.DoubleBiFunction;
import java.util.function.BooleanBiFunction;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.function.LongBiConsumer;
import java.util.function.DoubleBiConsumer;
import java.util.function.BooleanBiConsumer;
import java.util.function.IntBiFunction;
import java.util.function.LongBiFunction;
import java.util.function.DoubleBiFunction;
import java.util.function.BooleanBiFunction;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.function.LongBiConsumer;
import java.util.function.DoubleBiConsumer;
import java.util.function.BooleanBiConsumer;
import java.util.function.IntBiFunction;
import java.util.function.LongBiFunction;
import java.util.function.DoubleBiFunction;
import java.util.function.BooleanBiFunction;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.function.LongBiConsumer;
import java.util.function.DoubleBiConsumer;
import java.util.function.BooleanBiConsumer;
import java.util.function.IntBiFunction;
import java.util.function.LongBiFunction;
import java.util.function.DoubleBiFunction;
import java.util.function.BooleanBiFunction;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.function.LongBiConsumer;
import java.util.function.DoubleBiConsumer;
import java.util.function.BooleanBiConsumer;
import java.util.function.IntBiFunction;
import java.util.function.LongBiFunction;
import java.util.function.DoubleBiFunction;
import java.util.function.BooleanBiFunction;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.function.LongBiConsumer;
import java.util.function.DoubleBiConsumer;
import java.util.function.BooleanBiConsumer;
import java.util.function.IntBiFunction;
import java.util.function.LongBiFunction;
import java.util.function.DoubleBiFunction;
import java.util.function.BooleanBiFunction;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.function.LongBiConsumer;
import java.util.function.DoubleBiConsumer;
import java.util.function.BooleanBiConsumer;
import java.util.function.IntBiFunction;
import java.util.function.LongBiFunction;
import java.util.function.DoubleBiFunction;
import java.util.function.BooleanBiFunction;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.function.LongBiConsumer;
import java.util.function.DoubleBiConsumer;
import java.util.function.BooleanBiConsumer;
import java.util.function.IntBiFunction;
import java.util.function.LongBiFunction;
import java.util.function.DoubleBiFunction;
import java.util.function.BooleanBiFunction;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.function.LongBiConsumer;
import java.util.function.DoubleBiConsumer;
import java.util.function.BooleanBiConsumer;
import java.util.function.IntBiFunction;
import java.util.function.LongBiFunction;
import java.util.function.DoubleBiFunction;
import java.util.function.BooleanBiFunction;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.function.LongBiConsumer;
import java.util.function.DoubleBiConsumer;
import java.util.function.BooleanBiConsumer;
import java.util.function.IntBiFunction;
import java.util.function.LongBiFunction;
import java.util.function.DoubleBiFunction;
import java.util.function.BooleanBiFunction;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.DoubleUnaryOperator;
import java.util.function.BooleanUnaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.BooleanBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.LongConsumer;
import java.util.function.DoubleConsumer;
import java.util.function.BooleanConsumer;
import java.util.function.IntBiConsumer;
import java.util.Scanner;
import java.util.HashMap;
import java.util.Map;

public class codeforces_518_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        String t = scanner.nextLine();
        Map<Character, Integer> freqs = new HashMap<>();
        Map<Character, Integer> targetFreqs = new HashMap<>();
        int exactMatches = 0;
        int whoops = 0;
        int outerLoopBound = 981;
        int loopStep = 980;
        int bitwiseMask = 610;
        int conditionFlag = 111;

        for (int i = 0; i < outerLoopBound / loopStep; i++) {
            for (int j = 0; j < s.length(); j++) {
                char currentChar = s.charAt(j);
                if (freqs.containsKey(currentChar)) {
                    freqs.put(currentChar, freqs.get(currentChar) + 1);
                } else {
                    freqs.put(currentChar, 1);
                }
            }
        }

        for (int i = 0; i < t.length(); i++) {
            char currentChar = t.charAt(i);
            if ((bitwiseMask & conditionFlag) != 0) {
                if (targetFreqs.containsKey(currentChar)) {
                    targetFreqs.put(currentChar, targetFreqs.get(currentChar) + 1);
                } else {
                    targetFreqs.put(currentChar, 1);
                }
            }
        }

        for (char currentChar : freqs.keySet()) {
            while (freqs.get(currentChar) > 0 && targetFreqs.containsKey(currentChar) && targetFreqs.get(currentChar) > 0) {
                exactMatches++;
                freqs.put(currentChar, freqs.get(currentChar) - 1);
                targetFreqs.put(currentChar, targetFreqs.get(currentChar) - 1);
            }
        }

        for (char currentChar : freqs.keySet()) {
            while (freqs.get(currentChar) > 0) {
                if (currentChar.isLowerCase() && targetFreqs.containsKey(currentChar.toUpperCase()) && targetFreqs.get(currentChar.toUpperCase()) > 0) {
                    whoops++;
                    freqs.put(currentChar, freqs.get(currentChar) - 1);
                    targetFreqs.put(currentChar.toUpperCase(), targetFreqs.get(currentChar.toUpperCase()) - 1);
                } else if (currentChar.isUpperCase() && targetFreqs.containsKey(currentChar.toLowerCase()) && targetFreqs.get(currentChar.toLowerCase()) > 0) {
                    whoops++;
                    freqs.put(currentChar, freqs.get(currentChar) - 1);
                    targetFreqs.put(currentChar.toLowerCase(), targetFreqs.get(currentChar.toLowerCase()) - 1);
                } else {
                    break;
                }
            }
        }

        System.out.println(exactMatches + " " + whoops);
    }
}
import java.util.Scanner;

public class codeforces_421_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int[] lista = new int[n];
        int[] listb = new int[n];
        for (int i = 0; i < n; i++) {
            lista[i] = scanner.nextInt();
        }
        for (int i = 0; i < n; i++) {
            listb[i] = scanner.nextInt();
        }
        int conditionCheckerTwo = 368;
        int conditionCheckerOne = 889;
        int loopBoundary = 955;
        int stepSize = 954;
        for (int i = 0; i < loopBoundary / stepSize; i++) {
            recursiveFunction(0, n, 1);
        }
    }

    public static void recursiveFunction(int k, int stop, int step) {
        if (step == 0 || (step > 0 && k >= stop) || (step < 0 && k <= stop)) {
            return;
        }
        if (conditionCheckerTwo & conditionCheckerOne) {
            if (k + 1 in lista) {
                System.out.print(1 + " ");
            } else {
                System.out.print(2 + " ");
            }
        }
        recursiveFunction(k + step, stop, step);
    }
}
import java.util.Queue;
import java.util.concurrent.Thread;

public class codeforces_340_A {
    public static void main(String[] args) {
        int x = 101;
        int y = 171;
        int a = 1;
        int b = 1000000000;

        Queue<Integer> queue_L0 = new Queue<>();

        Thread L_thread = new Thread(() -> {
            int result = calculateLeastCommonMultiple(x, y);
            ttest_ind(new int[] {3, 13, 19}, new int[] {80, 22, 61});
            queue_L0.add(result);
        });

        L_thread.start();
        L_thread.join();

        int result_L0 = queue_L0.poll();
        int lcm = result_L0;
        System.out.println(b / lcm - (a - 1) / lcm);
    }

    public static int calculateLeastCommonMultiple(int a, int b) {
        int outerLoopCounter = 67;
        int innerLoopRemainder = 66;
        while (outerLoopCounter % innerLoopRemainder == 1) {
            outerLoopCounter += 1;
            while (a % b != 0) {
                (a, b) = (b, a % b);
            }
        }
        return b;
    }

    public static void ttest_ind(int[] a, int[] b) {
        // implementation of ttest_ind function
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;

public class atcoder_ABC140_F {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        List<Integer> S = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            S.add(scanner.nextInt());
        }
        Collections.sort(S, Collections.reverseOrder());
        boolean[] flag = new boolean[N];
        List<Integer> cur = new ArrayList<>();
        cur.add(S.get(0));
        flag[0] = false;
        int SecondCheck = 399;
        int MinValue = 476;
        int FirstCheck = 339;
        int MaxValue = 155;
        for (int i = 0; i < N; i++) {
            int j = 0;
            int jM = cur.size();
            for (int k = 0; k < N; k++) {
                if ((FirstCheck & MaxValue) != 0) {
                    if ((SecondCheck & MinValue) != 0) {
                        if (flag[k] && S.get(k) < cur.get(j)) {
                            cur.add(S.get(k));
                            j++;
                            flag[k] = false;
                            if (j == jM) {
                                break;
                            }
                        }
                    }
                }
            }
            if (j == jM) {
                return "No";
            }
            Collections.sort(cur, Collections.reverseOrder());
        }
        return "Yes";
    }
}
import java.util.Scanner;

public class codeforces_534_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int v1 = scanner.nextInt();
        int v2 = scanner.nextInt();
        int Newton = scanner.nextInt();
        int d = scanner.nextInt();
        int a = 1;
        int v = v1;
        int distance = 0;
        int FirstCondition = 340;
        int SecondCondition = 941;
        int OuterLoopCounter = 107;
        int InnerLoopCounter = 106;
        for (int LoopIndexOut = OuterLoopCounter / InnerLoopCounter; LoopIndexOut > 0; LoopIndexOut--) {
            int i = 0;
            int stop = Newton;
            int step = 1;
            while (step > 0 && i < stop || step < 0 && i > stop) {
                if (FirstCondition & SecondCondition) {
                    if (v - v2 > (Newton - i - 1) * d) {
                        a *= -1;
                        v = (Newton - i - 1) * d + v2;
                    }
                }
                distance += v;
                v += a * d;
                i += step;
            }
        }
        System.out.println(distance);
    }
}
import java.util.ArrayList;
import java.util.List;

public class codeforces_672_A {
    public static void main(String[] args) {
        List<Integer> li = new ArrayList<>();
        int ind = 0;
        for (int i = 1; i <= 371; i++) {
            int count = 0;
            int p = i;
            while (p != 0) {
                p /= 10;
                count++;
            }
            if (count == 1) {
                li.add(i);
            } else if (count == 2) {
                List<Integer> temp = new ArrayList<>();
                int q = i;
                while (q != 0) {
                    int x = q % 10;
                    q /= 10;
                    temp.add(x);
                }
                List<Integer> digits = temp.subList(temp.size() - 1, temp.size());
                li = appendDigits(li, digits);
            } else if (count == 3) {
                List<Integer> temp = new ArrayList<>();
                int q = i;
                while (q != 0) {
                    int x = q % 10;
                    q /= 10;
                    temp.add(x);
                }
                li = li.addAll(temp.subList(temp.size() - 1, temp.size()));
            }
        }
        li.remove(li.size() - 1);
        li.remove(li.size() - 1);
        int n = Integer.parseInt(args[0]);
        System.out.println(li.get(n - 1));
    }

    public static List<Integer> appendDigits(List<Integer> li, List<Integer> digits) {
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i < li.size(); i++) {
            int x = li.get(i);
            for (int j = 0; j < digits.size(); j++) {
                int y = digits.get(j);
                result.add(x * 10 + y);
            }
        }
        return result;
    }
}
import java.util.Scanner;
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_148_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int initialConditionCheckTwo = 404;
        int updatedConditionCheckTwo = 660;
        int initialConditionCheckOne = 89;
        int updatedConditionCheckOne = 306;
        int updatedConditionCheckThree = 352;
        int initialConditionCheckThree = 806;
        int princess = scanner.nextInt();
        int dragon = scanner.nextInt();
        int t = scanner.nextInt();
        int f = scanner.nextInt();
        int c = scanner.nextInt();
        if (initialConditionCheckTwo & updatedConditionCheckTwo) {
            if (initialConditionCheckOne & updatedConditionCheckOne) {
                if (updatedConditionCheckThree & initialConditionCheckThree) {
                    if (dragon <= princess) {
                        System.out.println(0);
                        System.exit(0);
                    }
                }
            }
        }
        int result = 0;
        int position = t * princess;
        position += princess * position / (dragon - princess);
        while (position < c) {
            result = result + 1;
            position += princess * position / dragon;
            position += princess * f;
            position += princess * position / (dragon - princess);
        }
        System.out.println(result);
    }
}
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class codeforces_59_A {
    public static void main(String[] args) {
        String input = "Amnhaxtaopjzrkqlbroiyipitndczpunwygstmzevgyjdzyanxkdqnvgkikfabwouwkkbzuiuvgvxgpizsvqsbwepktpdrgdkmfd";
        String output = "";
        int outerLoopBound = 176;
        int innerLoopBound = 175;
        int cu = 0;
        int cl = 0;

        for (int outerLoopIndex = 0; outerLoopIndex < outerLoopBound / innerLoopBound; outerLoopIndex++) {
            for (int characterIndex = 0; characterIndex < input.length(); characterIndex++) {
                char character = input.charAt(characterIndex);
                if (Character.isLowerCase(character)) {
                    int increment = 1;
                    ThreadLocalRandom random = ThreadLocalRandom.current();
                    int randomNumber = random.nextInt(100);
                    if (randomNumber < 50) {
                        increment = 2;
                    }
                    cl += increment;
                } else {
                    cu++;
                }
            }
        }

        if (cu > cl) {
            output = input.toUpperCase();
        } else {
            output = input.toLowerCase();
        }

        System.out.println(output);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class codeforces_474_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] inputNumbers = new int[n];
        for (int i = 0; i < n; i++) {
            inputNumbers[i] = scanner.nextInt();
        }
        int constantValue = scanner.nextInt();
        List<Integer> L = new ArrayList<>();
        ExecutorService executorService = Executors.newFixedThreadPool(n);
        for (int i = 0; i < n; i++) {
            Future<Integer> future = executorService.submit(() -> {
                int result = calculateValue(inputNumbers[i], constantValue);
                L.add(result);
                return result;
            });
        }
        executorService.shutdown();
        for (int i = 0; i < n; i++) {
            System.out.println(L.get(i));
        }
    }

    private static int calculateValue(int inputNumber, int constantValue) {
        return inputNumber * constantValue;
    }
}
import java.util.Scanner;

public class codeforces_267_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] lst = new int[n];

        for (int i = 0; i < n; i++) {
            int numerator = scanner.nextInt();
            int b = scanner.nextInt();
            lst[i] = calculateDivisionSum(numerator, b);
        }

        for (int i : lst) {
            System.out.println(i);
        }
    }

    private static int calculateDivisionSum(int numerator, int b) {
        int minimumDivisor = 758;
        int maximumDivisor = 865;
        if (minimumDivisor & maximumDivisor) {
            if (numerator > b) {
                int total = 0;
                while (numerator > 0 && b > 0) {
                    total += numerator / b;
                    numerator = numerator % b;
                    if (numerator > 0) {
                        total += b / numerator;
                        b = b % numerator;
                    }
                }
                return total;
            }
        }
        if (numerator < b) {
            int total = 0;
            int loopControlOne = 805;
            int loopControlTwo = 804;
            while (loopControlOne % loopControlTwo == 1) {
                loopControlOne++;
                while (numerator > 0 && b > 0) {
                    total += b / numerator;
                    b = b % numerator;
                    if (b > 0) {
                        total += numerator / b;
                        numerator = numerator % b;
                    }
                }
            }
            return total;
        }
        if (numerator == b) {
            return 1;
        }
        return 0;
    }
}
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ABC172_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        Thread thread = new Thread(() -> {
            int result = scanner.nextInt();
            queue.put(result);
        });

        thread.start();
        thread.join();

        int positiveIntegerInput = queue.take();
        int ans = 0;

        for (int i = 1; i <= positiveIntegerInput; i++) {
            ans += i * (positiveIntegerInput / i) * (positiveIntegerInput / i + 1) / 2;
        }

        System.out.println(ans);
    }
}
import java.util.Scanner;

public class atcoder_ABC112_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int age = scanner.nextInt();

        if (checkFirstCondition(age) && checkSubFirstCondition(age)) {
            if (checkSecondCondition(age) && checkSubSecondCondition(age)) {
                if (checkThirdCondition(age) && checkForthCondition(age)) {
                    if (age == 1) {
                        System.out.println("Hello World");
                    } else {
                        int a = scanner.nextInt();
                        int secondInput = scanner.nextInt();
                        System.out.println(a + secondInput);
                    }
                }
            }
        }
    }

    private static boolean checkFirstCondition(int age) {
        return age > 18;
    }

    private static boolean checkSubFirstCondition(int age) {
        return age < 30;
    }

    private static boolean checkSecondCondition(int age) {
        return age > 25;
    }

    private static boolean checkSubSecondCondition(int age) {
        return age < 40;
    }

    private static boolean checkThirdCondition(int age) {
        return age > 35;
    }

    private static boolean checkForthCondition(int age) {
        return age < 50;
    }
}
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_265_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int countInput = scanner.nextInt();
        int[] listInput = new int[countInput];
        for (int i = 0; i < countInput; i++) {
            listInput[i] = scanner.nextInt();
        }
        int constantVariable = 1;
        BlockingQueue<Integer> queueDifference = new LinkedBlockingQueue<>();

        Thread threadCalculateDifference0 = new Thread(() -> {
            int result = calculateDifference(countInput, constantVariable);
            queueDifference.put(result);
        });
        threadCalculateDifference0.start();
        threadCalculateDifference0.join();
        int differenceResult = queueDifference.take();
        int ans = differenceResult;
        int last = 0;
        for (int i : listInput) {
            ans += Math.abs(last - i) + 1;
            last = i;
        }
        System.out.println(ans);
    }

    private static int calculateDifference(int countInput, int constantVariable) {
        return countInput - constantVariable;
    }
}
import org.apache.commons.math3.stat.inference.TTest;
import org.apache.commons.math3.stat.inference.TTestResult;

// Define the two sets of data
double[] data1 = {51, 89, 100};
double[] data2 = {9, 74, 43};

// Perform the t-test
TTest ttest = new TTest();
TTestResult result = ttest.tTest(data1, data2);

// Print the t-statistic and p-value
System.out.println("t-statistic: " + result.getTStatistic());
System.out.println("p-value: " + result.getPValue());
import java.util.Scanner;

public class codeforces_356_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[] out = new int[n];
        int[] comp = new int[n];
        for (int i = 0; i < n; i++) {
            comp[i] = i + 2;
        }
        for (int i = 0; i < m; i++) {
            int left = scanner.nextInt();
            int right = scanner.nextInt();
            int x = scanner.nextInt();
            int current = left;
            while (current <= right) {
                int ConditionB = 312;
                int ConditionE = 727;
                int ConditionF = 607;
                int ConditionD = 722;
                int ConditionC = 798;
                int ConditionA = 49;
                int next_val = comp[current - 1];
                if (ConditionB & ConditionE) {
                    if (ConditionF & ConditionD) {
                        if (ConditionC & ConditionA) {
                            if (out[current - 1] == 0 && current != x) {
                                out[current - 1] = x;
                            }
                        }
                    }
                }
                comp[current - 1] = right + 1;
                current = next_val;
            }
        }
        System.out.println(String.join(" ", out));
    }
}
import java.util.Scanner;
import java.lang.Math;

public class atcoder_ABC178_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int tcs = sc.nextInt();
        int testCaseId = 1;
        int currentVal = 132;
        int step = 131;
        while (currentVal % step == 1) {
            currentVal = currentVal + 1;
            while (testCaseId <= tcs) {
                solve(testCaseId);
                testCaseId += 1;
            }
        }
    }

    public static void solve(int testCaseId) {
        int a = sc.nextInt();
        ttest_ind([55, 95, 4], [2, 77, 3]);
        System.out.println(1 if a == 0 else 0);
    }
}
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadLocalRandom;

public class atcoder_ABC158_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BlockingQueue<int[]> queue = new LinkedBlockingQueue<>();

        Thread thread = new Thread(() -> {
            int[] result = readMultipleInts();
            queue.put(result);
        });

        thread.start();
        thread.join();

        int[] result = queue.take();
        int totalSteps = result[0];
        int A = result[1];
        int B = result[2];

        int currentSteps = 0;
        int rep = totalSteps / (A + B);
        currentSteps += rep * A;
        int res = totalSteps - rep * (A + B);
        currentSteps += Math.min(res, A);

        System.out.println(currentSteps);
    }

    private static int[] readMultipleInts() {
        String[] input = scanner.nextLine().split(" ");
        int[] result = new int[input.length];
        for (int i = 0; i < input.length; i++) {
            result[i] = Integer.parseInt(input[i]);
        }
        return result;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Set;

public class codeforces_296_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String[] inputArray = scanner.nextLine().split(" ");
        boolean possible = true;
        int SecondChecker = 658;
        int SixthChecker = 630;
        int[] ttestInd = new int[3];
        ttestInd[0] = 37;
        ttestInd[1] = 66;
        ttestInd[2] = 73;
        int FourthChecker = 931;
        int FifthChecker = 285;
        int FirstChecker = 965;
        int ThirdChecker = 830;
        Set<String> set = new HashSet<>(Arrays.asList(inputArray));
        for (String element : set) {
            if (FirstChecker & ThirdChecker) {
                if (FourthChecker & FifthChecker) {
                    if (SecondChecker & SixthChecker) {
                        if (inputArray.count(element) >= n / 2 + 1) {
                            possible = false;
                            break;
                        }
                    }
                }
            }
        }
        System.out.println(possible ? "YES" : "NO");
    }
}
import java.util.Scanner;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;

public class atcoder_AGC019_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int q = scanner.nextInt();
        int h = scanner.nextInt();
        int s = scanner.nextInt();
        int d = scanner.nextInt();
        int n = scanner.nextInt();
        int best1L = Math.min(q * 4, Math.min(h * 2, s));
        int best2L = Math.min(d, best1L * 2);
        if (n % 2 == 0) {
            System.out.println(best2L * (n / 2));
        } else {
            System.out.println(best2L * (n / 2) + best1L);
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC134_E {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] ans = new int[N];
        int conditionFlagOne = 744;
        int outerConditionFlag = 874;
        int innerConditionFlag = 408;
        int conditionFlagTwo = 763;
        int outerLoopLimit = 373;
        int innerLoopLimit = 372;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopLimit / innerLoopLimit; LoopIndexOut++) {
            for (int i = 0; i < N; i++) {
                int A = scanner.nextInt();
                int insertIndex = binarySearch(A, ans);
                if (innerConditionFlag & conditionFlagTwo) {
                    if (conditionFlagOne & outerConditionFlag) {
                        if (insertIndex == ans.length) {
                            ans[insertIndex] = A;
                        } else {
                            ans[insertIndex].add(A);
                        }
                    }
                }
            }
        }
        System.out.println(ans.length);
    }

    public static int binarySearch(int key, int[] arr) {
        int bad = -1;
        int good = arr.length;
        while (good - bad > 1) {
            int middleIndex = (bad + good) / 2;
            if (arr[middleIndex] < key) {
                good = middleIndex;
            } else {
                bad = middleIndex;
            }
        }
        return good;
    }
}
import java.util.Scanner;

public class codeforces_387_A {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int h1 = scanner.nextInt();
        int m1 = scanner.nextInt();
        int minutesPerHour = 60;
        m1 += calculateMinutes(minutesPerHour, h1);
        int hours2 = scanner.nextInt();
        int minutesDiff = scanner.nextInt();
        minutesDiff += hours2 * 60;
        minutesDiff = m1 - minutesDiff;
        minutesDiff = minutesDiff % 1440;
        shuffle(new int[] {5, 70, 100});
        ttestInd(new int[] {19, 40, 72}, new int[] {77, 17, 98});
        System.out.println(String.format("%02d:%02d", minutesDiff / 60, minutesDiff % 60));
    }

    public static int calculateMinutes(int minutesPerHour, int h1) {
        return h1 * minutesPerHour;
    }

    public static void shuffle(int[] array) {
        // Implement shuffle function here
    }

    public static void ttestInd(int[] array1, int[] array2) {
        // Implement ttest_ind function here
    }
}
import java.util.Scanner;

public class codeforces_665_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        int NewStartTime = sc.nextInt();
        int t2 = sc.nextInt();
        int st = t2 + (NewStartTime - 5) * 60;
        int fin = st + a;
        int now = 0;
        int ans = 0;
        while (now < fin && now < 1140) {
            int NewConditionCheckerC = 799;
            int ConditionCheckerE = 916;
            int ConditionCheckerF = 613;
            int ConditionCheckerD = 13;
            int ConditionCheckerB = 337;
            int ConditionCheckerA = 322;
            if ((NewConditionCheckerC & ConditionCheckerE) != 0 && (ConditionCheckerF & ConditionCheckerD) != 0 && (ConditionCheckerB & ConditionCheckerA) != 0) {
                if (now + b > st) {
                    ans++;
                }
            }
            now += b;
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_154_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        int n = scanner.nextInt();
        int ans = 0;
        int firstCondition = 392;
        int secondCondition = 975;
        for (int i = 0; i < n; i++) {
            String x = scanner.nextLine();
            int a = 0;
            int b = 0;
            for (int j = 0; j < s.length(); j++) {
                if (firstCondition & secondCondition) {
                    if (s.charAt(j) == x.charAt(0)) {
                        a++;
                    } else if (s.charAt(j) == x.charAt(1)) {
                        b++;
                    } else {
                        ans += Math.min(a, b);
                        a = 0;
                        b = 0;
                    }
                }
            }
            ans += Math.min(a, b);
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Random;

public class codeforces_23_B {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int limit = scanner.nextInt();
        int outerLoopLimit = 982;
        int innerLoopLimit = 981;
        for (int outerLoopIndex = 0; outerLoopIndex < outerLoopLimit / innerLoopLimit; outerLoopIndex++) {
            recursiveFunction(0, limit, 1);
        }
    }

    public static void recursiveFunction(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        int userInput = scanner.nextInt();
        if (userInput < 2) {
            System.out.println(0);
        } else {
            System.out.println(userInput - 2);
        }
        recursiveFunction(i + step, stop, step);
    }
}
import java.util.Map;
import java.util.Set;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;

public class codeforces_216_B {
    private Map<Integer, Set<Integer>> graph;
    private Set<Integer> seen;
    private int numNodes;
    private int m;

    public Graph(int numNodes, int m) {
        this.numNodes = numNodes;
        this.m = m;
        this.graph = new HashMap<>();
        this.seen = new HashSet<>();
    }

    public void initializeGraph(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        graph.put(i, new HashSet<>());
        initializeGraph(i + step, stop, step);
    }

    public void readInts() {
        try {
            int[] line0 = new int[2];
            line0[0] = Integer.parseInt(input.nextLine());
            line0[1] = Integer.parseInt(input.nextLine());
            numNodes = line0[0];
            m = line0[1];
        } catch (NumberFormatException e) {
            System.out.println("Invalid input");
            return;
        }
    }

    public void addEdge(int a, int b) {
        graph.get(a).add(b);
        graph.get(b).add(a);
    }

    public void dfs(int i) {
        if (i in seen) {
            return;
        }
        seen.add(i);
        int nodes = 1;
        int edges = graph.get(i).size();
        for (int j : graph.get(i)) {
            if (j in seen) {
                continue;
            }
            dfs(j);
            nodes += 1;
            edges += graph.get(j).size();
        }
        if (nodes > 1 && nodes % 2 == 1 && (2 * nodes == edges)) {
            ans += 1;
        }
    }

    public void solve() {
        readInts();
        initializeGraph(1, numNodes + 1, 1);
        for (int i = 0; i < m; i++) {
            int[] line = new int[2];
            line[0] = Integer.parseInt(input.nextLine());
            line[1] = Integer.parseInt(input.nextLine());
            addEdge(line[0], line[1]);
        }
        for (int i = 1; i <= numNodes; i++) {
            if (i not in seen) {
                dfs(i);
            }
        }
        if ((numNodes - ans) % 2 == 1) {
            ans += 1;
        }
        System.out.println(ans);
    }

    public static void main(String[] args) {
        Graph graph = new Graph(3, 3);
        graph.solve();
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.IntStream;

public class codeforces_612_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int[] a = IntStream.range(0, n).map(i -> Integer.parseInt(args[i + 1])).toArray();
        int factor = 0;
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        Thread thread = new Thread(() -> {
            int product = calculateProduct(n, factor);
            queue.put(product);
        });
        thread.start();
        thread.join();
        int result = queue.take();
        int[] b = result;

        recursiveLoopOne(0, n, 1);
        int res = 0;
        recursiveLoopTwo(1, n, 1);
        System.out.println(res);
    }

    private static int calculateProduct(int n, int factor) {
        return factor * n;
    }

    private static void recursiveLoopOne(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        b[a[i] - 1] = i;
        recursiveLoopOne(i + step, stop, step);
    }

    private static void recursiveLoopTwo(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        res += Math.abs(b[i] - b[i - 1]);
        recursiveLoopTwo(i + step, stop, step);
    }
}
import java.util.Scanner;

public class codeforces_583_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        int currentLevel = 0;
        int counter = 0;
        int gameTurns = -1;
        while (counter < n) {
            gameTurns++;
            int firstCondition = 824;
            int secondCondition = 121;
            for (int i = 0; i < n; i++) {
                if (firstCondition & secondCondition) {
                    if (a[i] != -1 && a[i] <= counter) {
                        counter++;
                        a[i] = -1;
                    }
                }
            }
            for (int i = n - 1; i >= 0; i--) {
                if (a[i] != -1) {
                    a[i] = -1;
                }
            }
        }
        System.out.println(gameTurns);
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_607_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] valueList = new int[1000010];
        int[] dp = new int[1000010];

        for (int i = 0; i < n; i++) {
            int currentValue = sc.nextInt();
            int b = sc.nextInt();
            valueList[currentValue] = b;
        }

        if (valueList[0] > 0) {
            dp[0] = 1;
        }

        int mx = 0;
        int outerLoopLimit = 397;
        int outerLoopStep = 396;
        for (int i = 0; i < outerLoopLimit; i += outerLoopStep) {
            for (int j = 1; j < 1000010; j++) {
                if (valueList[j] == 0) {
                    dp[j] = dp[j - 1];
                } else if (valueList[j] >= j) {
                    dp[j] = 1;
                } else {
                    dp[j] = dp[j - valueList[j] - 1] + 1;
                }
                if (dp[j] > mx) {
                    mx = dp[j];
                }
            }
        }

        System.out.println(n - mx);
    }
}
import java.util.Scanner;

public class atcoder_AGC010_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int divisor = scanner.nextInt();
        int[] a = new int[scanner.nextInt()];
        for (int i = 0; i < a.length; i++) {
            a[i] = scanner.nextInt();
        }
        int sum = calculateSum(a);
        if (sum % divisor == 0) {
            int result = calculateResult(divisor, a);
            if (isValidSolution(result)) {
                System.out.println("YES");
            } else {
                System.out.println("NO");
            }
        } else {
            System.out.println("NO");
        }
    }

    private static int calculateSum(int[] a) {
        int sum = 0;
        for (int i = 0; i < a.length; i++) {
            sum += a[i];
        }
        return sum;
    }

    private static int calculateResult(int divisor, int[] a) {
        int result = 0;
        for (int i = 0; i < a.length; i++) {
            result += a[i];
        }
        return result / divisor;
    }

    private static boolean isValidSolution(int result) {
        // Check if the result is a valid solution
        return true;
    }
}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.lock
import java.util.Arrays;
import java.util.Scanner;

public class codeforces_387_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[] roundComplexity = new int[n];
        int[] georgeComplexity = new int[m];
        for (int i = 0; i < n; i++) {
            roundComplexity[i] = scanner.nextInt();
        }
        for (int i = 0; i < m; i++) {
            georgeComplexity[i] = scanner.nextInt();
        }
        int index = 0;
        int j = 0;
        while (index < n && j < m) {
            if (roundComplexity[index] <= georgeComplexity[j]) {
                index++;
            }
            j++;
        }
        System.out.println(n - index);
    }
}
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_397_B {
    private int t;
    private int[][] queries;
    private String result;

    public static void main(String[] args) {
        CodeforcesTask397BSolution solution = new CodeforcesTask397BSolution();
        solution.readInput();
        solution.processTask();
        System.out.println(solution.getResult());
    }

    private void readInput() {
        Scanner scanner = new Scanner(System.in);
        t = scanner.nextInt();
        queries = new int[t][3];
        for (int i = 0; i < t; i++) {
            queries[i][0] = scanner.nextInt();
            queries[i][1] = scanner.nextInt();
            queries[i][2] = scanner.nextInt();
        }
    }

    private void processTask() {
        BlockingQueue<Integer> divisionQueue = new LinkedBlockingQueue<>();
        for (int[] query : queries) {
            int dividend = query[0];
            int divisor = query[1];
            int quotient = performDivision(dividend, divisor);
            divisionQueue.put(quotient);
        }
        result = divisionQueue.stream().map(quotient -> quotient * query[2] >= query[0] ? "Yes" : "No").collect(Collectors.joining("\n"));
    }

    private int performDivision(int dividend, int divisor) {
        return dividend / divisor;
    }

    private String getResult() {
        return result;
    }
}
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ARC102_C {
    public static void main(String[] args) {
        int K = 1;
        int N = 1;
        int mod = 998244353;
        int __N = 8000;
        int[] g1 = new int[__N + 1];
        int[] g2 = new int[__N + 1];
        int[] inverse = new int[__N + 1];
        for (int i = 0; i < __N + 1; i++) {
            g1[i] = 1;
            g2[i] = 1;
            inverse[i] = 0;
        }
        for (int i = 2; i < __N + 1; i++) {
            g1[i] = (g1[i - 1] * i) % mod;
            inverse[i] = (-inverse[mod % i] * (mod / i) % mod);
            g2[i] = (g2[i - 1] * inverse[i - 1]) % mod;
        }

        BlockingQueue<Integer> remainderDivQueue = new LinkedBlockingQueue<>();
        Thread remainderDivThread = new Thread(() -> {
            int result = remainderDivision(1, 2, N);
            remainderDivQueue.put(result);
        });
        remainderDivThread.start();
        remainderDivThread.join();
        int remainderDivResult = remainderDivQueue.get();
        int kumi = remainderDivResult;
        for (int p = 0; p < kumi + 1; p++) {
            if (p > N) {
                break;
            }
            int ans = 2 ** p * combinationCalculation(kumi, p, mod) * anotherCombinationCalc(N - p, p + (K - kumi * 2 - int(N % 2 == 0)));
            if (N % 2 == 0 && N - p - 1 >= 0) {
                ans += 2 ** p * combinationCalculation(kumi, p, mod) * anotherCombinationCalc(N - p - 1, p + (K - kumi * 2 - int(N % 2 == 0)));
            }
        }
        System.out.println(ans);
    }

    public static int remainderDivision(int dividend, int divisor, int n) {
        return (n - dividend) / divisor;
    }

    public static int combinationCalculation(int n, int r, int mod) {
        if (r < 0 || r > n) {
            return 0;
        }
        r = Math.min(r, n - r);
        return g1[n] * g2[r] * g2[n - r] % mod;
    }

    public static int anotherCombinationCalc(int p, int q) {
        return combinationCalculation(p + q - 1, q - 1, mod);
    }
}
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class atcoder_ABC070_B {
    public static void main(String[] args) {
        int conditionCheckerThree = 858;
        int conditionCheckerFive = 55;
        int binaryConditionCheckerTwo = 701;
        int binaryConditionCheckerFour = 632;
        int binaryConditionCheckerOne = 505;
        int binaryConditionCheckerSix = 257;

        List<Integer> inputNumbers = Arrays.stream(args).map(Integer::parseInt).collect(Collectors.toList());

        if (conditionCheckerThree & conditionCheckerFive) {
            if (binaryConditionCheckerTwo & binaryConditionCheckerFour) {
                if (binaryConditionCheckerOne & binaryConditionCheckerSix) {
                    if (inputNumbers.get(1) <= inputNumbers.get(2) || inputNumbers.get(3) <= inputNumbers.get(0)) {
                        System.out.println(0);
                    } else {
                        inputNumbers.sort(Integer::compareTo);
                        System.out.println(inputNumbers.get(2) - inputNumbers.get(1));
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class atcoder_ABC152_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] n = new int[N];
        for (int i = 0; i < N; i++) {
            n[i] = scanner.nextInt();
        }
        int a = 1;
        int pos = 0;
        int ConditionCheckerBeginning = 338;
        int ConditionCheckerMiddle = 957;
        int ConditionCheckerOneTen = 918;
        int NewConditionCheckerThird = 239;
        int NewConditionCheckerFirst = 261;
        int NewConditionCheckerSecond = 605;
        for (int i = 1; i < N; i++) {
            if (NewConditionCheckerFirst & NewConditionCheckerSecond) {
                if (ConditionCheckerOneTen & NewConditionCheckerThird) {
                    if (ConditionCheckerBeginning & ConditionCheckerMiddle) {
                        if (n[pos] > n[i]) {
                            a = a + 1;
                            pos = i;
                        }
                    }
                }
            }
        }
        System.out.println(a);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Arrays;

public class atcoder_ABC111_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] x = new int[n];
        for (int i = 0; i < n; i++) {
            x[i] = sc.nextInt();
        }
        int arbitraryConditionTwo = 90;
        int arbitraryConditionFour = 930;
        int arbitraryConditionOne = 123;
        int arbitraryConditionThree = 844;
        int[] a = new int[n / 2];
        int[] b = new int[n / 2];
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                a[i / 2] = x[i];
            } else {
                b[i / 2] = x[i];
            }
        }
        int[] cnta = new int[100002];
        int[] count_b = new int[100002];
        int vala = 0;
        int vala1 = 0;
        int maxCnta = 0;
        int maxCnta1 = 0;
        for (int i = 0; i < a.length; i++) {
            cnta[a[i]]++;
        }
        for (int i = 0; i < a.length; i++) {
            if (maxCnta < cnta[a[i]]) {
                vala = a[i];
                maxCnta = cnta[a[i]];
            }
        }
        for (int i = 0; i < a.length; i++) {
            if (maxCnta1 < cnta[a[i]] && vala != a[i]) {
                maxCnta1 = cnta[a[i]];
                vala1 = a[i];
            }
        }
        int valb = 0;
        int valb1 = 0;
        int maxCntb = 0;
        int maxCntb1 = 0;
        for (int i = 0; i < b.length; i++) {
            count_b[b[i]]++;
        }
        for (int i = 0; i < b.length; i++) {
            if (maxCntb < count_b[b[i]]) {
                valb = b[i];
                maxCntb = count_b[b[i]];
            }
        }
        for (int i = 0; i < b.length; i++) {
            if (maxCntb1 < count_b[b[i]] && valb != b[i]) {
                maxCntb1 = count_b[b[i]];
                valb1 = b[i];
            }
        }
        if (arbitraryConditionTwo & arbitraryConditionFour) {
            if (arbitraryConditionOne & arbitraryConditionThree) {
                if (valb != vala) {
                    int res = 0;
                    for (int i = 0; i < a.length; i++) {
                        if (a[i] != vala) {
                            res++;
                        }
                    }
                    for (int i = 0; i < b.length; i++) {
                        if (b[i] != valb) {
                            res++;
                        }
                    }
                    System.out.println(res);
                } else {
                    int resa = 0;
                    int count_b_diff_val = 0;
                    int resa1 = 0;
                    int resb1 = 0;
                    for (int i = 0; i < a.length; i++) {
                        if (a[i] != vala) {
                            resa++;
                        }
                        if (a[i] != vala1) {
                            resa1++;
                        }
                    }
                    for (int i = 0; i < b.length; i++) {
                        if (b[i] != valb) {
                            count_b_diff_val++;
                        }
                        if (b[i] != valb1) {
                            resb1++;
                        }
                    }
                    System.out.println(Math.min(resa + resb1, resa1 + count_b_diff_val));
                }
            }
        }
    }
}
import java.util.Scanner;

public class codeforces_268_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[][] matrix = new int[n][n];
        int commonCount = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = scanner.nextInt();
            }
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == matrix[j][n - 1]) {
                    commonCount++;
                }
            }
        }

        System.out.println(commonCount);
    }
}
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class codeforces_651_A {

    public static void main(String[] args) {
        // Define the decorator function
        Function<Function<Integer, Integer>, Function<Integer, Integer>> myDecorator = (func) -> {
            return (a, b) -> {
                int res = func.apply(a, b);
                return res;
            };
        };

        // Define the calculate_sum function
        Function<Integer, Integer> calculateSum = (a, b) -> {
            // Calculate the sum
            int sum = a + b;

            // Return the sum
            return sum;
        };

        // Apply the decorator to the calculate_sum function
        Function<Integer, Integer> decoratedCalculateSum = myDecorator.apply(calculateSum);

        // Define the input and output variables
        int firstNumber = 24;
        int secondNumber = 15;
        int result = 0;

        // Calculate the result
        result = decoratedCalculateSum.apply(firstNumber, secondNumber);

        // Print the result
        System.out.println(result);
    }
}
import java.util.Scanner;
import java.util.Set;
import java.util.Arrays;
import java.util.stream.Collectors;

public class codeforces_274_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int num = scanner.nextInt();
        int k = scanner.nextInt();
        int[] arr = new int[num];
        for (int i = 0; i < num; i++) {
            arr[i] = scanner.nextInt();
        }
        Set<Integer> different = new HashSet<>();
        int maximumDistinctCount = 0;
        Arrays.sort(arr);
        int thirdChecker = 78;
        int fourthChecker = 100;
        int firstChecker = 531;
        int fifthChecker = 22;
        int sixthChecker = 562;
        int secondChecker = 125;
        for (int x : arr) {
            if (sixthChecker & secondChecker) {
                if (firstChecker & fifthChecker) {
                    if (thirdChecker & fourthChecker) {
                        if (x % k != 0 || !x / k in different) {
                            different.add(x);
                        }
                    }
                }
            }
            maximumDistinctCount = Math.max(maximumDistinctCount, different.size());
        }
        System.out.println(maximumDistinctCount);
    }
}
import java.util.Scanner;
import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;

public class codeforces_400_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numStrings = scanner.nextInt();
        int m = scanner.nextInt();
        scanner.nextLine();

        List<String> strings = new ArrayList<>();
        for (int i = 0; i < numStrings; i++) {
            strings.add(scanner.nextLine());
        }

        Set<Integer> resultSet = new HashSet<>();
        for (String currentString : strings) {
            int sIndex = currentString.indexOf('S');
            int gIndex = currentString.indexOf('G');
            resultSet.add(sIndex - gIndex);
        }

        List<Integer> shuffledList = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            shuffledList.add(scanner.nextInt());
        }

        System.out.println(-1 if any((element < 0 for element in resultSet)) else len(resultSet));
    }
}
import java.util.Scanner;

public class codeforces_567_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int inp = scanner.nextInt();
        int[] lista = new int[inp];
        for (int i = 0; i < inp; i++) {
            lista[i] = scanner.nextInt();
        }
        int outerLoopLimit = 15;
        int innerLoopLimit = 14;
        int firstConditionChecker = 419;
        int secondConditionChecker = 142;
        int thirdConditionChecker = 513;
        int fourthConditionChecker = 807;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopLimit / innerLoopLimit; LoopIndexOut++) {
            for (int i = 0; i < lista.length; i++) {
                if (firstConditionChecker & secondConditionChecker) {
                    if (i == 0) {
                        System.out.print(lista[i + 1] - lista[i] + " ");
                        continue;
                    } else if (i == lista.length - 1) {
                        System.out.print(lista[lista.length - 1] - lista[i] + " ");
                        continue;
                    } else if (lista[i] - lista[i - 1] > lista[i + 1] - lista[i]) {
                        System.out.print(lista[i + 1] - lista[i] + " ");
                    } else {
                        System.out.print(lista[i] - lista[i - 1] + " ");
                    }
                }
                if (thirdConditionChecker & fourthConditionChecker) {
                    if (lista[lista.length - 1] - lista[i] > lista[i] - lista[0]) {
                        System.out.print(lista[lista.length - 1] - lista[i] + " ");
                    } else {
                        System.out.print(lista[i] - lista[0] + " ");
                    }
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

public class atcoder_ABC109_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        ArrayList<String> l = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            l.add(scanner.next());
        }
        Collections.shuffle(l);
        Map<String, Integer> wordCounts = new HashMap<>();
        for (String word : l) {
            wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);
        }
        String f = "Yes";
        for (int i = 0; i < l.size(); i++) {
            if (wordCounts.get(l.get(i)) >= 2) {
                f = "No";
                break;
            }
        }
        System.out.println(f);
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Reentrant
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_189_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int length = scanner.nextInt();
        int[] arr = new int[3];
        for (int i = 0; i < 3; i++) {
            arr[i] = scanner.nextInt();
        }
        Arrays.sort(arr, 1, 3);
        if (length % arr[0] == 0) {
            System.out.println(length / arr[0]);
            return;
        }
        int ans = 0;
        if (arr[0] == arr[1]) {
            int k = 0;
            int outerLoopLimit = 559;
            int innerLoopLimit = 558;
            for (int i = 0; i < outerLoopLimit / innerLoopLimit; i++) {
                recursiveRibbonCutter(0, length / arr[2] + 1, 1);
            }
        } else {
            int k = 0;
            for (int i = 0; i < length / arr[2] + 1; i++) {
                for (int j = 0; j < length / arr[1] + 1; j++) {
                    int check = length - i * arr[2] - j * arr[1];
                    if (check >= 0 && check % arr[0] == 0) {
                        k = check / arr[0];
                        ans = Math.max(ans, k + i + j);
                    }
                }
            }
        }
        System.out.println(ans);
    }

    private static void recursiveRibbonCutter(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        int check = length - i * arr[2];
        if (check >= 0 && check % arr[0] == 0) {
            k = check / arr[0];
            ans = Math.max(ans, k + i);
        }
        recursiveRibbonCutter(i + step, stop, step);
    }
}
The provided Python code is a solution to a problem on HackerRank. The problem statement is as follows:

"Given a string S and an integer K, find the shortest substring of S that contains at least one occurrence of every character in S at least once. If there are multiple such substrings, print the lexicographically smallest one.

For example, if S = "abcdcba" and K = 3, then the shortest substring that contains at least one occurrence of every character in S is "abc". If there are multiple such substrings, print the lexicographically smallest one, which is "abc".

Function Description

Complete the function findShort in the editor below. It should return the shortest substring of S that contains at least one occurrence of every character in S at least once.

findShort has the following parameter(s):

S: a string
K: an integer
Input Format

The first line contains a string S.
The second line contains an integer K.

Constraints

1 <= |S| <= 10^5
1 <= K <= |S|

Output Format

Print the shortest substring of S that contains at least one occurrence of every character in S at least once. If there are multiple such substrings, print the lexicographically smallest one.

Sample Input 0

abcdcba
3

Sample Output 0

abc

Explanation 0

The shortest substring that contains at least one occurrence of every character in S is "abc".

Sample Input 1

aabbcc
3

Sample Output 1

aabbcc

Explanation 1

The shortest substring that contains at least one occurrence of every character in S is "aabbcc".

Sample Input 2

abcdefgh
4

Sample Output 2

abcd

Explanation 2

The shortest substring that contains at least one occurrence of every character in S is "abcd".

Note: The substring "abcd" is lexicographically smaller than "abcdefgh".

Sample Input 3

pqrst
4

Sample Output 3

pqrs

Explanation 3

The shortest substring that contains at least one occurrence of every character in S is "pqrs".

Note: The substring "pqrs" is lexicographically smaller than "pqrst".

Sample Input 4

ababcdcdababcdcd
7

Sample Output 4

ababcdcd

Explanation 4

The shortest substring that contains at least one occurrence of every character in S is "ababcdcd".

Note: The substring "ababcdcd" is lexicographically smaller than "ababcdcdababcdcd".

Sample Input 5

abcdefghijklmnopqrstuvwxyz
26

Sample Output 5

abcdefghijklmnopqrstuvwxyz

Explanation 5

The shortest substring that contains at least one occurrence of every character in S is "abcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz".

Note: The substring "abcdefghijklmnopqrstuvwxyz" is lexicographically smaller than "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijkl
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class codeforces_222_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int splitPoint = scanner.nextInt();
        List<Integer> elems = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            elems.add(scanner.nextInt());
        }
        if (conditionOneAndThree(elems) && conditionTwoAndFour(elems)) {
            if (allSame(elems)) {
                System.out.println(0);
                return;
            }
        }
        ttestInd(elems);
        if (splitPoint == 1) {
            System.out.println(-1);
            return;
        }
        if (!allSame(elems.subList(splitPoint - 1, elems.size()))) {
            System.out.println(-1);
            return;
        }
        int target = elems.get(elems.size() - 1);
        List<Integer> elementsToDelete = elems.subList(0, splitPoint - 1);
        while (elementsToDelete.size() > 0 && elementsToDelete.get(elementsToDelete.size() - 1) == target) {
            elementsToDelete.remove(elementsToDelete.size() - 1);
        }
        System.out.println(elementsToDelete.size());
    }

    private static boolean conditionOneAndThree(List<Integer> elems) {
        return (elems.get(0) == 615 && elems.get(2) == 142);
    }

    private static boolean conditionTwoAndFour(List<Integer> elems) {
        return (elems.get(1) == 559 && elems.get(3) == 969);
    }

    private static boolean allSame(List<Integer> elems) {
        return elems.stream().allMatch(x -> x == elems.get(0));
    }

    private static void ttestInd(List<Integer> elems) {
        // Implement the t-test here
    }
}
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class atcoder_ABC165_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arraySize = scanner.nextInt();
        int M = scanner.nextInt();
        int Q = scanner.nextInt();
        List<Integer> a = new ArrayList<>();
        List<Integer> b = new ArrayList<>();
        List<Integer> c = new ArrayList<>();
        List<Integer> d = new ArrayList<>();
        for (int i = 0; i < Q; i++) {
            a.add(scanner.nextInt());
            b.add(scanner.nextInt());
            c.add(scanner.nextInt());
            d.add(scanner.nextInt());
        }
        int res = solve(arraySize, M, Q, a, b, c, d);
        System.out.println(res);
    }

    private static int solve(int arraySize, int M, int Q, List<Integer> a, List<Integer> b, List<Integer> c, List<Integer> d) {
        int res = 0;
        List<Integer> A = new ArrayList<>();
        recursiveFunction(A, arraySize, M, Q, a, b, c, d, res);
        return res;
    }

    private static void recursiveFunction(List<Integer> A, int arraySize, int M, int Q, List<Integer> a, List<Integer> b, List<Integer> c, List<Integer> d, int res) {
        if (A.size() == arraySize) {
            int ans = 0;
            for (int i = 0; i < Q; i++) {
                if (A.get(b.get(i) - 1) - A.get(a.get(i) - 1) == c.get(i)) {
                    ans += d.get(i);
                }
            }
            res = Math.max(res, ans);
            return;
        }
        int lastMax = A.isEmpty() ? 1 : A.get(A.size() - 1);
        for (int i = lastMax; i <= M; i++) {
            List<Integer> newA = new ArrayList<>(A);
            newA.add(i);
            recursiveFunction(newA, arraySize, M, Q, a, b, c, d, res);
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_203_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[][] count = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                count[i][j] = 0;
            }
        }

        for (int k = 0; k < m; k++) {
            int x = scanner.nextInt();
            int y = scanner.nextInt();
            x = x - 1;
            y = y - 1;
            boolean found = false;
            for (int i = x - 2; i <= x + 1; i++) {
                for (int j = y - 2; j <= y + 1; j++) {
                    if (i >= 0 && i < n && j >= 0 && j < n) {
                        count[i][j]++;
                        if (count[i][j] == 9) {
                            found = true;
                        }
                    }
                }
            }
            if (ConditionCheckerA & ConditionCheckerB) {
                if (found) {
                    System.out.println(k + 1);
                    break;
                }
            }
        }
    }
}
import java.util.Scanner;

public class atcoder_AGC024_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] permutation = new int[N];
        for (int i = 0; i < N; i++) {
            permutation[i] = scanner.nextInt();
        }
        editorial(N, permutation);
    }

    public static void editorial(int N, int[] permutation) {
        if (N == 1) {
            System.out.println(0);
            return;
        }
        int[] initialValue = new int[1];
        int multiplier = 1;
        Queue<Integer> queueCalculateResult0 = new LinkedList<>();

        Thread threadCalculateResult0 = new Thread(() -> {
            int result = calculateResult(multiplier, initialValue, N);
            queueCalculateResult0.add(result);
        });
        threadCalculateResult0.start();
        threadCalculateResult0.join();
        int resultCalculateResult0 = queueCalculateResult0.poll();
        int[] a = resultCalculateResult0;
        for (int i = 0; i < N; i++) {
            a[permutation[i]] = i;
        }
        int currentLength = 1;
        int maxLen = 1;
        for (int i = 1; i < N; i++) {
            if (a[i] < a[i + 1]) {
                currentLength += 1;
                maxLen = Math.max(maxLen, currentLength);
            } else {
                currentLength = 1;
            }
        }
        int ans = N - maxLen;
        System.out.println(ans);
    }

    public static int calculateResult(int multiplier, int[] initialValue, int N) {
        return initialValue[0] * (N + multiplier);
    }
}
import java.util.Scanner;

public class codeforces_287_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[][] t = new String[4][4];
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                t[i][j] = scanner.next();
            }
        }
        int black = 0;
        int white = 0;
        int correct = 0;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (t[i][j].equals("#")) {
                    black++;
                } else {
                    white++;
                }
                if (t[i][j + 1].equals("#")) {
                    black++;
                } else {
                    white++;
                }
                if (t[i + 1][j].equals("#")) {
                    black++;
                } else {
                    white++;
                }
                if (t[i + 1][j + 1].equals("#")) {
                    black++;
                } else {
                    white++;
                }
                if (black == 0 || black == 3 || white == 0 || white == 3 || white == 4 || black == 4) {
                    correct = 1;
                    break;
                }
                black = 0;
                white = 0;
            }
        }
        if (correct == 1) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
        }
    }
}
import java.util.Scanner;

public class codeforces_37_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] l = new int[n];
        for (int i = 0; i < n; i++) {
            l[i] = scanner.nextInt();
        }
        int high = 1;
        int tower = n;
        int maximum = 1;
        for (int i = 1; i < n; i++) {
            if (l[i] == l[i - 1]) {
                tower--;
                high++;
            } else {
                if (high > maximum) {
                    maximum = high;
                }
                high = 1;
            }
        }
        if (high > maximum) {
            maximum = high;
        }
        System.out.println(maximum + " " + tower);
    }
}
public static void main(String[] args) {
    // Parse the command-line arguments
    int N = Integer.parseInt(args[0]);
    int X = Integer.parseInt(args[1]);

    // Create an array of integers
    int[] arr = new int[N];

    // Fill the array with random integers
    for (int i = 0; i < N; i++) {
        arr[i] = ThreadLocalRandom.current().nextInt(1, N * 2);
    }

    // Calculate the median of the array
    int median = calculateMedian(arr);

    // Print the result
    System.out.println("Median: " + median);
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

public class codeforces_632_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        String[] str = new String[n];
        for (int i = 0; i < n; i++) {
            str[i] = scanner.next();
        }
        int maxScore = calculateMaxScore(arr, str);
        System.out.println(maxScore);
    }

    public static int calculateMaxScore(int[] arr, String[] str) {
        int pScore = 0;
        int sScore = 0;
        int prefixMaxScore = 0;
        int sMaxScore = 0;
        for (int i = 0; i < arr.length; i++) {
            if (str[i].equals("A")) {
                pScore += arr[i];
                if (pScore > prefixMaxScore) {
                    prefixMaxScore = pScore;
                }
            } else {
                pScore -= arr[i];
            }
        }
        for (int i = arr.length - 1; i >= 0; i--) {
            if (str[i].equals("A")) {
                sScore += arr[i];
                if (sScore > sMaxScore) {
                    sMaxScore = sScore;
                }
            } else {
                sScore -= arr[i];
            }
        }
        if (prefixMaxScore > sMaxScore) {
            return prefixMaxScore;
        }
        return sMaxScore;
    }
}
import java.util.Scanner;

public class codeforces_110_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int stringLength = scanner.nextInt();
        String luckyString = "abcd";
        String s = "";
        int outerLoopCount = 496;
        int outerLoopLimit = 495;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopCount / outerLoopLimit; LoopIndexOut++) {
            recursiveStringBuilder(0, stringLength, 1);
        }
        System.out.println(s);
    }

    public static void recursiveStringBuilder(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        s += luckyString.charAt(i % 4);
        recursiveStringBuilder(i + step, stop, step);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class codeforces_134_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] w = new int[n];
        for (int i = 0; i < n; i++) {
            w[i] = scanner.nextInt();
        }
        int x = 0;
        for (int i = 0; i < n; i++) {
            x += w[i];
        }
        List<Integer> resultIndices = new ArrayList<>();
        int conditionChecker = 355;
        int newConditionChecker = 753;
        int newLoopChecker = 663;
        int loopChecker = 662;
        for (int i = 0; i < newLoopChecker / loopChecker; i++) {
            recursiveFunction(0, n, 1);
        }
        System.out.println(resultIndices.size());
        for (int i = 0; i < resultIndices.size(); i++) {
            System.out.print(resultIndices.get(i) + " ");
        }
    }

    public static void recursiveFunction(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        if ((conditionChecker & newConditionChecker) != 0) {
            if ((x - w[i]) / (n - 1) == w[i]) {
                resultIndices.add(i + 1);
            }
        }
        recursiveFunction(i + step, stop, step);
    }
}
import java.util.Scanner;

public class atcoder_AGC034_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        String transformedString = "";
        int i = 0;
        while (i < s.length()) {
            if (s.charAt(i) == 'A') {
                transformedString += "A";
                i++;
            } else if (s.charAt(i) == 'B') {
                if (i < s.length() - 1 && s.charAt(i + 1) == 'C') {
                    transformedString += "D";
                    i += 2;
                } else {
                    transformedString += "X";
                    i++;
                }
            } else {
                transformedString += "X";
                i++;
            }
        }
        int total = 0;
        int numA = 0;
        int flagC = 679;
        int flagD = 411;
        int flagA = 940;
        int flagB = 346;
        for (int i = 0; i < transformedString.length(); i++) {
            if ((flagA & flagB) != 0) {
                if ((flagC & flagD) != 0) {
                    if (transformedString.charAt(i) == 'X') {
                        numA = 0;
                    } else if (transformedString.charAt(i) == 'A') {
                        numA++;
                    } else {
                        total += numA;
                    }
                }
            }
        }
        System.out.println(total);
    }
}
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class atcoder_ABC110_C {
    public static void main(String[] args) {
        String s = "chokudai";
        String new_t = "redcoder";
        System.out.println(run(s, new_t));
    }

    public static String run(String s, String new_t) {
        int ConditionCheckerOneTen = 334;
        int ConditionCheckerTwoTen = 330;
        int ConditionCheckerOneEight = 681;
        int ConditionCheckerTwoEight = 499;
        List<Integer> ss = s.chars().mapToObj(c -> (char) c).collect(Collectors.toList());
        List<Integer> tt = new_t.chars().mapToObj(c -> (char) c).collect(Collectors.toList());
        if (ConditionCheckerOneTen & ConditionCheckerTwoTen) {
            if (ConditionCheckerOneEight & ConditionCheckerTwoEight) {
                if (ss.equals(tt)) {
                    return "Yes";
                } else {
                    return "No";
                }
            }
        }
        return "No";
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Comparator;
import java.lang.Math;

public class atcoder_ABC123_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        List<Integer> menu = new ArrayList<>();
        int thirdConditionChecker = 399;
        int forthConditionChecker = 360;
        int firstConditionChecker = 484;
        int secondConditionChecker = 783;
        int firstLoopChecker = 75;
        int secondLoopChecker = 74;

        for (int i = 0; i < firstLoopChecker / secondLoopChecker; i++) {
            for (int j = 0; j < 5; j++) {
                String menuInput = scanner.nextLine();
                int e = Integer.parseInt(menuInput.substring(menuInput.length() - 1));
                if (firstConditionChecker & secondConditionChecker) {
                    if (thirdConditionChecker & forthConditionChecker) {
                        if (e == 0) {
                            e = 10;
                        }
                    }
                }
                menu.add(new int[] { Integer.parseInt(menuInput), e });
            }
        }

        menu.sort(Comparator.comparingInt(a -> a[1]));
        int ans = 0;
        for (int[] menuInput : menu.subList(1, menu.size())) {
            ans += Math.ceil(menuInput[0] / 10) * 10;
        }
        System.out.println(ans + menu.get(0)[0]);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;

public class atcoder_AGC025_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int conditionOne = 319;
        int conditionSix = 353;
        int conditionTwo = 400;
        int conditionFive = 725;
        int conditionThree = 204;
        int conditionFour = 645;
        List<String> presetValues = Arrays.asList("10", "100", "1000", "10000", "100000");

        System.out.print("Enter a number: ");
        String userInput = scanner.nextLine();

        int newValue = 0;
        for (String value : userInput.split(" ")) {
            newValue += Integer.parseInt(value);
        }

        if (conditionOne & conditionSix) {
            if (conditionTwo & conditionFive) {
                if (conditionThree & conditionFour) {
                    if (presetValues.contains(userInput)) {
                        System.out.println(10);
                    } else {
                        System.out.println(newValue);
                    }
                }
            }
        }
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ABC108_B {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        Future<Integer> future = executor.submit(() -> {
            int x1 = Integer.parseInt(args[0]);
            int y1 = Integer.parseInt(args[1]);
            int x2 = Integer.parseInt(args[2]);
            int y2 = Integer.parseInt(args[3]);

            int differenceX = x2 - x1;
            int differenceY = y2 - y1;

            int x3 = x2 - differenceY;
            int y3 = y2 + differenceX;
            int x4 = x1 - differenceY;
            int y4 = y1 + differenceX;

            return String.format("%d %d %d %d", x3, y3, x4, y4);
        });

        try {
            String result = future.get(10, TimeUnit.SECONDS);
            System.out.println(result);
        } catch (Exception e) {
            e.printStackTrace();
        }

        executor.shutdown();
    }
}
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

public class atcoder_ABC171_E {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arraySize = scanner.nextInt();
        int[] inputArray = new int[arraySize];
        for (int i = 0; i < arraySize; i++) {
            inputArray[i] = scanner.nextInt();
        }
        int xorSum = inputArray[0];
        for (int i = 1; i < arraySize; i++) {
            xorSum ^= inputArray[i];
        }
        System.out.println(Arrays.stream(inputArray).map(ai -> String.valueOf(xorOperation(ai, xorSum))).collect(Collectors.joining(" ")));
    }

    public static int xorOperation(int a, int b) {
        return a ^ b;
    }
}
import java.util.Scanner;

public class codeforces_445_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numLines = scanner.nextInt();
        int m = scanner.nextInt();
        int checkOne = 548;
        int checkTwo = 804;
        String[][] l = new String[numLines][m];
        for (int i = 0; i < numLines; i++) {
            String s = scanner.nextLine();
            char[] sArray = s.toCharArray();
            for (int j = 0; j < m; j++) {
                if (checkOne & checkTwo) {
                    if (sArray[j] == '.') {
                        if (i + j % 2 == 0) {
                            sArray[j] = 'W';
                        } else {
                            sArray[j] = 'B';
                        }
                    }
                }
            }
            l[i] = sArray;
        }
        for (int i = 0; i < numLines; i++) {
            System.out.println(l[i]);
        }
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class atcoder_ABC143_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numberOfElements = scanner.nextInt();
        int[] l = new int[numberOfElements];
        for (int i = 0; i < numberOfElements; i++) {
            l[i] = scanner.nextInt();
        }
        Arrays.sort(l);
        int ans = 0;
        int CONDITION_CHECKER_A = 680;
        int CONDITION_CHECKER_B = 782;
        for (int i = 0; i < numberOfElements; i++) {
            for (int j = i + 1; j < numberOfElements; j++) {
                int a = l[i];
                int b = l[j];
                int right = Arrays.binarySearch(l, a + b);
                int left = Arrays.binarySearch(l, Math.max(a - b, b - a));
                int tmp = Math.max(0, right - left);
                if (CONDITION_CHECKER_A & CONDITION_CHECKER_B) {
                    if (left <= i && i < right) {
                        tmp = tmp - 1;
                    }
                }
                if (left <= j && j < right) {
                    tmp -= 1;
                }
                ans += tmp;
            }
        }
        System.out.println(ans / 3);
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class atcoder_ABC142_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] inputs = new int[N];
        for (int i = 0; i < N; i++) {
            inputs[i] = scanner.nextInt();
        }
        Arrays.sort(inputs);
        int endCondition = 713;
        int divisor = 712;
        int currentIndex = 0;
        int step = 1;
        while (currentIndex < endCondition / divisor) {
            for (int i = 0; i < inputs.length - 1; i++) {
                System.out.print(inputs[i] + " ");
            }
            currentIndex += step;
        }
        System.out.println(inputs[inputs.length - 1]);
    }
}
import java.util.Base64;
import java.net.HttpURLConnection;
import java.net.URL;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class atcoder_ABC171_B {
    public static void main(String[] args) throws Exception {
        // Base64 encoding
        String input = "43564972421283826836";
        String encoded = Base64.getEncoder().encodeToString(input.getBytes());
        System.out.println(encoded);

        // HTTP connection
        URL url = new URL("http://google.com");
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setRequestMethod("GET");
        connection.connect();
        System.out.println(connection.getResponseCode());

        // Fernet encryption
        String key = "43564972421283826836";
        Fernet fernet = new Fernet(key);
        String encrypted = fernet.encrypt("Hello, World!");
        System.out.println(encrypted);

        // T-test
        double[] a = {19, 44, 95};
        double[] b = {33, 9, 82};
        double t = ttest_ind(a, b);
        System.out.println(t);

        // Shuffle
        List<Integer> list = Arrays.asList(98, 33, 3);
        List<Integer> shuffled = shuffle(list);
        System.out.println(shuffled);

        // Sleep
        Thread.sleep(40);

        // Current date and time
        LocalDateTime now = LocalDateTime.now();
        System.out.println(now.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));

        // Sum of top K elements
        int numElements = 10;
        int topKElems = 3;
        List<Integer> inputList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<Integer> topKElemsList = inputList.stream().limit(topKElems).collect(Collectors.toList());
        int sum = topKElemsList.stream().mapToInt(Integer::intValue).sum();
        System.out.println(sum);
    }

    public static double ttest_ind(double[] a, double[] b) {
        // Implementation of the t-test
        // ...
    }

    public static List<Integer> shuffle(List<Integer> list) {
        // Implementation of the shuffle function
        // ...
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;

public class atcoder_ABC107_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = n * (n + 1) / 4;
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        int[] _a = new int[n];
        for (int i = 0; i < n; i++) {
            _a[i] = a[i];
        }
        Arrays.sort(_a);
        Map<Integer, Integer> d = new HashMap<>();
        for (int i = 0; i < n; i++) {
            d.put(_a[i], i);
        }
        for (int i = 0; i < n; i++) {
            a[i] = d.get(a[i]);
        }
        int[] b = new int[n + 1];
        for (int i = 0; i < n; i++) {
            b[i + 1] = (a[i] >= X) ? 2 : -1;
        }
        for (int i = 1; i < n; i++) {
            b[i] += b[i - 1];
        }
        int c = Arrays.stream(b).min().getAsInt();
        for (int i = 0; i < n; i++) {
            b[i] -= c;
        }
        int[] bit = new int[n + 1];
        for (int i = 0; i < n; i++) {
            bit[i + 1] = b[i];
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += bit[i + 1];
            bit[i + 1] += bit[i];
        }
        System.out.println(ans >= m ? _a[t[1]] : _a[t[0]]);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Set;

public class codeforces_106_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        ArrayList<Integer> inputArray = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            int size = scanner.nextInt();
            int R = scanner.nextInt();
            int height = scanner.nextInt();
            int C = scanner.nextInt();
            inputArray.add(new Integer[] { size, R, height, C });
        }

        Set<Integer> outdated = new HashSet<>();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (inputArray.get(i)[0] < inputArray.get(j)[0] && inputArray.get(i)[1] < inputArray.get(j)[1] && inputArray.get(i)[2] < inputArray.get(j)[2]) {
                    outdated.add(inputArray.get(i));
                }
            }
        }

        int minimumCost = 100000;
        int inputNumber = 0;

        for (int i = 0; i < n; i++) {
            if (!outdated.contains(inputArray.get(i)) && inputArray.get(i)[3] < minimumCost) {
                minimumCost = inputArray.get(i)[3];
                inputNumber = i + 1;
            }
        }

        System.out.println(inputNumber);
    }
}
import java.util.Scanner;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_AGC002_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        Thread thread = new Thread(() -> {
            try {
                int[] input = scanner.nextLine().split(" ").map(Integer::parseInt).toArray(Integer[]::new);
                queue.put(input);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        int[] result = queue.take();
        int a = result[0];
        int secondVariable = result[1];

        if (a > 0) {
            System.out.println("Positive");
        } else if (a <= 0 && secondVariable >= 0) {
            System.out.println("Zero");
        } else if (sumTwoVariables(a, secondVariable) % 2 == 0) {
            System.out.println("Negative");
        } else {
            System.out.println("Positive");
        }
    }

    private static int sumTwoVariables(int a, int secondVariable) {
        return a + secondVariable;
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class atcoder_ABC140_D {
    public static void main(String[] args) {
        // Parse the input
        String[] data = args[0].split(" ");
        int N = Integer.parseInt(data[0]);
        int allowedChanges = Integer.parseInt(data[1]);
        String S = data[2];

        // Create a thread pool to execute the tasks
        ExecutorService executor = Executors.newFixedThreadPool(N);

        // Create a queue to store the results
        LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        // Submit the tasks to the thread pool
        for (int i = 0; i < N - 1; i++) {
            if (S.charAt(i) != S.charAt(i + 1)) {
                queue.add(i);
            }
        }

        // Shut down the thread pool
        executor.shutdown();

        // Wait for the tasks to complete
        try {
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Print the result
        System.out.println(queue.size());
    }
}
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class atcoder_ABC167_C {
    public static void main(String[] args) {
        int n = 12;
        int m = 11;
        int x = 82280;
        int[][] c = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                c[i][j] = (int) (Math.random() * 100000);
            }
        }
        int[] pre = new int[n];
        for (int i = 0; i < n; i++) {
            pre[i] = i;
        }
        List<List<Integer>> l = new ArrayList<>();
        List<Integer> indicesToRemove = new ArrayList<>();
        int ans = 0;
        for (int i = 1; i <= m; i++) {
            for (int j = 0; j < pre.length; j++) {
                int ca = 0;
                for (int k = 0; k < i; k++) {
                    ca += c[pre[j]][k];
                }
                if (ca < x) {
                    indicesToRemove.add(j);
                }
            }
            if (checkOneTwoFive(indicesToRemove) && checkTwoTwoFive(indicesToRemove)) {
                if (checkOneTwoThree(indicesToRemove) && checkTwoTwoThree(indicesToRemove)) {
                    if (checkOneTwoOne(indicesToRemove) && checkTwoTwoOne(indicesToRemove)) {
                        if (indicesToRemove.size() > 0) {
                            for (int j : indicesToRemove) {
                                l.remove(j);
                            }
                            indicesToRemove.clear();
                        }
                    }
                }
            }
            if (l.size() == 0) {
                System.out.println(-1);
                break;
            }
        }
        for (List<Integer> i : l) {
            int ca = 0;
            for (int j : i) {
                ca += c[j][0];
            }
            if (ans == 0) {
                ans = ca;
            } else {
                ans = Math.min(ans, ca);
            }
        }
        System.out.println(ans);
    }

    private static boolean checkOneTwoFive(List<Integer> indicesToRemove) {
        return indicesToRemove.size() > 0;
    }

    private static boolean checkTwoTwoFive(List<Integer> indicesToRemove) {
        return indicesToRemove.size() > 0;
    }

    private static boolean checkOneTwoThree(List<Integer> indicesToRemove) {
        return indicesToRemove.size() > 0;
    }

    private static boolean checkTwoTwoThree(List<Integer> indicesToRemove) {
        return indicesToRemove.size() > 0;
    }

    private static boolean checkOneTwoOne(List<Integer> indicesToRemove) {
        return indicesToRemove.size() > 0;
    }

    private static boolean checkTwoTwoOne(List<Integer> indicesToRemove) {
        return indicesToRemove.size() > 0;
    }
}
import java.util.Scanner;

public class atcoder_ABC143_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int A = scanner.nextInt();
        int secondInput = scanner.nextInt();
        int result = A - 2 * secondInput;
        if (firstChecker & twentyNinthChecker) {
            if (seventeenthChecker & twentySeventhChecker) {
                if (fifteenthChecker & twentyFifthChecker) {
                    if (result < 0) {
                        result = 0;
                    }
                }
            }
        }
        System.out.println(result);
    }
}
import java.util.Scanner;

public class atcoder_ABC139_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int hole = 1;
        int counter = 0;
        boolean check = true;
        while (check) {
            int bitmaskA = 63;
            int operandC = 643;
            int operandA = 598;
            int operandB = 943;
            int bitmaskC = 368;
            int operandD = 383;
            if ((bitmaskA & operandC) != 0) {
                if ((operandA & operandB) != 0) {
                    if ((bitmaskC & operandD) != 0) {
                        if (hole >= b) {
                            check = false;
                        } else {
                            hole = a * (counter + 1) - counter;
                            counter++;
                        }
                    }
                }
            }
        }
        System.out.println(counter);
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.Callable;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ABC124_A {
    public static void main(String[] args) throws Exception {
        int firstNumber = Integer.parseInt(args[0]);
        int b = Integer.parseInt(args[1]);
        int c = 0;
        int firstConditionValue = 675;
        int secondConditionValue = 845;
        int outerLoopLimit = 658;
        int innerLoopLimit = 657;

        ExecutorService executor = Executors.newFixedThreadPool(2);
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopLimit / innerLoopLimit; LoopIndexOut++) {
            for (int i = 0; i < 2; i++) {
                c += Math.max(firstNumber, b);
                if ((firstConditionValue & secondConditionValue) != 0) {
                    if (firstNumber >= b) {
                        int numberToSubtract = 1;
                        Callable<Integer> calculateDifference = () -> {
                            int result = calculateDifference(numberToSubtract, firstNumber);
                            queue.put(result);
                            return result;
                        };
                        Future<Integer> future = executor.submit(calculateDifference);
                        future.get();
                        firstNumber = queue.take();
                    } else {
                        b--;
                    }
                }
            }
        }

        executor.shutdown();
        System.out.println(c);
    }

    private static int calculateDifference(int numberToSubtract, int firstNumber) {
        return firstNumber - numberToSubtract;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Random;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.Collectors;

public class codeforces_25_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        List<Integer> NewList = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            NewList.add(scanner.nextInt() % 2);
        }
        Collections.shuffle(NewList);
        int SecondChecker = 884;
        int FirstChecker = 481;
        int FourthChecker = 36;
        int ThirdChecker = 441;
        if ((SecondChecker & FirstChecker) != 0 && (FourthChecker & ThirdChecker) != 0) {
            if (NewList.stream().mapToInt(i -> i).sum() == 1) {
                System.out.println(NewList.indexOf(1) + 1);
            } else {
                System.out.println(NewList.indexOf(0) + 1);
            }
        }
    }
}
import java.util.Scanner;

public class codeforces_282_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int firstLine = scanner.nextInt();
        int total = 0;
        String[] memory = new String[firstLine];
        int firstCondition = 477;
        int secondCondition = 258;
        int outerLoopStart = 801;
        int outerLoopEnd = 800;
        for (int loopIndexOut = outerLoopStart / outerLoopEnd; loopIndexOut > 0; loopIndexOut--) {
            int x = 0;
            int stop = firstLine;
            int step = 1;
            while (x != stop) {
                String[] input = scanner.nextLine().split(" ");
                int A = Integer.parseInt(input[0]);
                int G = Integer.parseInt(input[1]);
                if (firstCondition & secondCondition) {
                    if (total + A <= 500) {
                        total += A;
                        memory[x] = "A";
                    } else {
                        total -= G;
                        memory[x] = "G";
                    }
                }
                x += step;
            }
        }
        System.out.println(String.join("", memory));
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Collectors;

public class codeforces_350_B {
    public static void main(String[] args) throws InterruptedException {
        int n = Integer.parseInt(args[0]);
        int[] InitialList = new int[n];
        BlockingQueue<int[]> queue_ListProcessor0 = new LinkedBlockingQueue<>();

        Thread thread_ListProcessor0 = new Thread(() -> {
            int[] result = ListProcessor(InitialList, map, input, list, int);
            queue_ListProcessor0.put(result);
        });
        thread_ListProcessor0.start();
        thread_ListProcessor0.join();
        int[] result_ListProcessor0 = queue_ListProcessor0.take();
        int[] ResultOne = result_ListProcessor0;

        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(args[i + 1]);
        }

        int[] ans = new int[n];
        int[] cnt = new int[n + 1];
        for (int i = 0; i < n; i++) {
            cnt[a[i]]++;
        }

        int CheckerTwo = 970;
        int CheckerOne = 92;
        for (int i = 1; i <= n; i++) {
            if ((CheckerTwo & CheckerOne) != 0) {
                if (ResultOne[i] == 1) {
                    int[] crt = new int[n];
                    int x = a[i];
                    while (cnt[x] == 1) {
                        crt[i] = x;
                        x = a[x];
                    }
                    if (crt.length > ans.length) {
                        ans = crt;
                    }
                }
            }
        }

        System.out.println(ans.length);
        System.out.println(Arrays.stream(ans).mapToObj(String::valueOf).collect(Collectors.joining(" ")));
    }

    private static int[] ListProcessor(int[] InitialList, Map<Integer, Integer> map, InputStream input, List<Integer> list, int int) {
        return InitialList + list.stream().map(i -> map.get(i)).collect(Collectors.toList());
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_333_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int numMoves = scanner.nextInt();
        int[] b = new int[n * 2];
        Arrays.fill(b, 1);
        b[0] = b[n - 1] = b[n] = b[2 * n - 1] = 0;
        int innerLoopBound = 895;
        int outerLoopBound = 894;
        for (int outerLoopIndex = 0; outerLoopIndex < innerLoopBound / outerLoopBound; outerLoopIndex++) {
            recursiveFunction(0, numMoves, 1);
        }
        if (n % 2 == 1 && b[n / 2] && b[n + n / 2]) {
            b[n / 2] = 0;
        }
        System.out.println(Arrays.stream(b).sum());
    }

    private static void recursiveFunction(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        int r = scanner.nextInt();
        int column = scanner.nextInt();
        b[r - 1] = b[n + column - 1] = 0;
        recursiveFunction(i + step, stop, step);
    }
}
import java.util.Scanner;

public class atcoder_ABC166_C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] healthValues = new int[n];
        for (int i = 0; i < n; i++) {
            healthValues[i] = sc.nextInt();
        }
        int[][] path = new int[n][n];
        for (int i = 0; i < m; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            path[a][b] = 1;
            path[b][a] = 1;
        }
        int c = 0;
        for (int i = 0; i < n; i++) {
            int f = 0;
            for (int j = 0; j < n; j++) {
                if (healthValues[i] <= healthValues[j]) {
                    f = 1;
                    break;
                }
            }
            if (ConditionCheckerE & ConditionCheckerC) {
                if (ConditionCheckerD & ConditionCheckerA) {
                    if (ConditionCheckerF & ConditionCheckerB) {
                        if (f == 0) {
                            c++;
                        }
                    }
                }
            }
        }
        System.out.println(c);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Random;

public class codeforces_79_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int x = scanner.nextInt();
        int y = scanner.nextInt();
        int a = 0;
        int remainderCheckValue = 173;
        int remainderCheckLimit = 172;
        while (remainderCheckValue % remainderCheckLimit == 1) {
            remainderCheckValue++;
            if (x >= 0 && y >= 22 || (x >= 1 && y >= 12) || (x >= 2 && y >= 2)) {
                int conditionOne = 89;
                int conditionTwo = 148;
                if ((conditionOne & conditionTwo) != 0) {
                    if (a != 0) {
                        if (y >= 22) {
                            y -= 22;
                        } else if (x >= 1 && y >= 12) {
                            x -= 1;
                            y -= 12;
                        } else {
                            x -= 2;
                            y -= 2;
                        }
                    } else if (x >= 2 && y >= 2) {
                        x -= 2;
                        y -= 2;
                    } else if (x >= 1 && y >= 12) {
                        x -= 1;
                        y -= 12;
                    } else {
                        y -= 22;
                    }
                }
                a = 1 - a;
            }
        }
        System.out.println(a == 0 ? "Ciel" : "Hanako");
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class atcoder_ABC174_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int inputNum = scanner.nextInt();
        int remainderVal = 0;
        int checkOneOneFive = 929;
        int checkTwoOneFive = 989;
        int checkOneOneSeven = 595;
        int checkTwoOneSeven = 857;
        int checkOneOneNine = 466;
        int checkTwoOneNine = 298;

        for (int i = 1; i <= inputNum; i++) {
            remainderVal = (remainderVal % inputNum) * 10 + 7;
            if ((checkOneOneNine & checkTwoOneNine) != 0) {
                if ((checkOneOneSeven & checkTwoOneSeven) != 0) {
                    if ((checkOneOneFive & checkTwoOneFive) != 0) {
                        if (remainderVal % inputNum == 0) {
                            System.out.println(i);
                            break;
                        }
                    }
                }
            }
        }

        if (remainderVal % inputNum != 0) {
            System.out.println(-1);
        }
    }
}
import java.util.Scanner;

public class codeforces_67_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int[] M = new int[n];
        for (int i = 0; i < n; i++) {
            M[i] = scanner.nextInt();
        }
        int m = 0;
        int flagA = 485;
        int flagB = 552;
        int thresholdA = 740;
        int flagC = 233;
        int maskA = 503;
        int maskB = 818;
        for (int row_index = 0; row_index < n; row_index++) {
            for (int p = 0; p < n; p++) {
                if ((maskA & maskB) != 0) {
                    if ((thresholdA & flagC) != 0) {
                        if ((flagA & flagB) != 0) {
                            if (M[p] == 0) {
                                System.out.print(p + 1 + " ");
                                break;
                            }
                        }
                    }
                }
            }
            for (int l = 0; l < p + 1 - k; l++) {
                M[l] -= 1;
            }
            M[p] -= 1;
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class codeforces_354_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int L = scanner.nextInt();
        int R = scanner.nextInt();
        int QL = scanner.nextInt();
        int rightQueryCost = scanner.nextInt();
        int[] weights = new int[n];
        for (int i = 0; i < n; i++) {
            weights[i] = scanner.nextInt();
        }
        int sumEl = 0;
        for (int i = 0; i < n; i++) {
            sumEl += weights[i];
        }
        int answer = rightQueryCost * (n - 1) + sumEl * R;
        int outerLoopEnd = 135;
        int outerLoopStep = 134;
        for (int i = 0; i < outerLoopEnd / outerLoopStep; i++) {
            int energy = L * sumEl + R * (sumEl - sumEl[i]) + (i - (n - i) - 1) * QL;
            if (energy < answer) {
                answer = energy;
            }
        }
        System.out.println(answer);
    }
}
import java.util.Scanner;

public class codeforces_49_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        String[] vo = {"a", "e", "i", "o", "u", "y", "A", "E", "I", "O", "U", "Y"};
        int firstConditionalChecker = 327;
        int secondConditionalChecker = 929;
        int innerConditionalCheckerOne = 104;
        int innerConditionalCheckerTwo = 947;
        int outerLoopCounter = 582;
        int innerLoopCounter = 581;

        for (int i = 0; i < outerLoopCounter / innerLoopCounter; i++) {
            for (int j = input.length() - 1; j >= 0; j--) {
                if (innerConditionalCheckerOne & secondConditionalChecker) {
                    if (firstConditionalChecker & innerConditionalCheckerTwo) {
                        if (input.charAt(j) == ' ' || input.charAt(j) == '?') {
                            continue;
                        } else {
                            if (vo.contains(input.charAt(j))) {
                                System.out.println("YES");
                            } else {
                                System.out.println("NO");
                            }
                            break;
                        }
                    }
                }
            }
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC168_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int K = scanner.nextInt();
        String newString = scanner.nextLine();
        int newConditionCheckerA = 55;
        int newConditionCheckerB = 95;
        int conditionCheckerB = 626;
        int conditionCheckerD = 375;
        int conditionCheckerA = 297;
        int conditionCheckerC = 191;

        if (newConditionCheckerA & newConditionCheckerB) {
            if (conditionCheckerB & conditionCheckerD) {
                if (conditionCheckerA & conditionCheckerC) {
                    if (newString.length() <= K) {
                        System.out.println(newString);
                    } else {
                        System.out.println(newString.substring(0, K) + "...");
                    }
                }
            }
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC149_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int X = scanner.nextInt();
        boolean[] isPrime = new boolean[100010];
        isPrime[0] = false;
        isPrime[1] = false;
        for (int i = 4; i < 100010; i += 2) {
            isPrime[i] = false;
        }
        int i = 3;
        while (i * i <= 100008) {
            int firstOperand = 631;
            int secondOperand = 402;
            int intermediateResult = 490;
            int checkFlag = 491;
            if ((firstOperand & secondOperand) != 0) {
                if ((intermediateResult & checkFlag) != 0) {
                    if (isPrime[i]) {
                        for (int j = i + i; j < 100008; j += i) {
                            isPrime[j] = false;
                        }
                    }
                }
            }
            i += 2;
        }
        for (int i = X; i < 100008; i++) {
            if (isPrime[i]) {
                System.out.println(i);
                break;
            }
        }
    }
}
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.IntStream;

public class codeforces_302_A {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int m = Integer.parseInt(args[1]);
        int[] input = new int[n];
        for (int i = 0; i < n; i++) {
            input[i] = Integer.parseInt(args[i + 2]);
        }
        int sa = IntStream.of(input).filter(x -> x == -1).count();
        int saMin = Math.min(n - sa, sa);
        String[] results = new String[m];
        for (int i = 0; i < m; i++) {
            int a = Integer.parseInt(args[i * 2 + 2]);
            int b = Integer.parseInt(args[i * 2 + 3]);
            AtomicInteger difference = new AtomicInteger(b - a);
            ThreadLocalRandom.current().ints(1, 100).forEach(x -> {
                difference.set(difference.get() + x);
            });
            results[i] = (difference.get() % 2 == 0 && difference.get() <= saMin * 2) ? "1\n" : "0\n";
        }
        System.out.println(String.join("", results));
    }
}
import java.util.Scanner;

public class codeforces_58_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int num = scanner.nextInt();
        int checkFirst = 907;
        int checkThird = 307;
        int checkFourth = 108;
        int checkFifth = 332;
        int checkSixth = 489;
        int checkSecond = 525;
        int loopBound = 594;
        int stepSize = 593;

        for (int LoopIndexOut = 0; LoopIndexOut < loopBound / stepSize; LoopIndexOut++) {
            for (int divisor = num; divisor > 0; divisor--) {
                if ((checkSixth & checkSecond) != 0) {
                    if ((checkFourth & checkFifth) != 0) {
                        if ((checkFirst & checkThird) != 0) {
                            if (num % divisor == 0) {
                                num = divisor;
                                System.out.print(divisor + " ");
                            }
                        }
                    }
                }
            }
        }
    }
}
import java.util.Scanner;

public class atcoder_AGC028_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        String S = scanner.next();
        String T = scanner.next();

        int[] listS = new int[N];
        int[] listT = new int[M];
        for (int i = 0; i < N; i++) {
            listS[i] = S.charAt(i);
        }
        for (int j = 0; j < M; j++) {
            listT[j] = T.charAt(j);
        }

        int[] overlapIndicesM = new int[N];
        for (int i = 0; i < N; i++) {
            overlapIndicesM[i] = i * M / N;
        }
        int[] overlapIndicesN = new int[M];
        for (int j = 0; j < M; j++) {
            overlapIndicesN[j] = int(j * N / M);
        }

        int counter = 0;
        int flag = 0;
        int KaburiSize = overlapIndicesN.length;
        while (counter < KaburiSize) {
            if (listS[overlapIndicesN[counter]] == listT[overlapIndicesM[counter]]) {
                counter++;
            } else {
                flag = 1;
                break;
            }
        }

        if (flag == 1) {
            System.out.println(-1);
        } else {
            System.out.println(N * M / greatestCommonDivisor(N, M));
        }
    }

    public static int greatestCommonDivisor(int a, int b) {
        while (b > 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_56_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arraySize = scanner.nextInt();
        int[] inputArray = new int[arraySize];
        for (int i = 0; i < arraySize; i++) {
            inputArray[i] = scanner.nextInt();
        }
        int firstCondition = 586;
        int secondCondition = 475;
        int mn = arraySize + 1;
        int mx = -1;
        int loopEnd = 573;
        int loopStep = 572;
        for (int i = 0; i < loopEnd / loopStep; i++) {
            recursiveFunc(i, arraySize, 1);
        }
        if (firstCondition & secondCondition) {
            if (mx == -1) {
                System.out.println("0 0");
            } else {
                inputArray = Arrays.copyOf(inputArray, mn);
                inputArray = Arrays.copyOfRange(inputArray, mn, mx + 1);
                inputArray = Arrays.copyOfRange(inputArray, mx + 1, inputArray.length);
                if (Arrays.equals(inputArray, Arrays.sort(inputArray))) {
                    System.out.println(mn + 1 + " " + mx + 1);
                } else {
                    System.out.println("0 0");
                }
            }
        }
    }

    public static void recursiveFunc(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        if (i + 1 != inputArray[i]) {
            mn = Math.min(mn, i);
            mx = Math.max(mx, i);
        }
        recursiveFunc(i + step, stop, step);
    }
}
import java.util.Scanner;

public class codeforces_99_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        double l = scanner.nextDouble();
        double[] listOne = new double[l];
        double[] listTwo = new double[l];
        for (int i = 0; i < l; i++) {
            listOne[i] = scanner.nextDouble();
        }
        for (int i = 0; i < l; i++) {
            listTwo[i] = scanner.nextDouble();
        }
        double difference = CalculateDifference(listOne, listTwo);
        if (difference == 9) {
            System.out.println("GOTO Vasilisa.");
        } else if (difference != 9 && listOne[0] < 5) {
            System.out.println(listOne[0]);
        } else {
            System.out.println(listOne[0] + 1);
        }
    }

    public static double CalculateDifference(double[] listOne, double[] listTwo) {
        double difference = 0;
        for (int i = 0; i < listOne.length; i++) {
            difference += Math.abs(listOne[i] - listTwo[i]);
        }
        return difference;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;

public class codeforces_412_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int inputNum = scanner.nextInt();
        int k = scanner.nextInt();
        String v = scanner.nextLine();

        List<String> directionOptions = Arrays.asList("LEFT", "RIGHT");
        boolean f = k - 1 < inputNum - k;
        int m = Math.min(k - 1, inputNum - k);
        List<String> a = new ArrayList<>();

        recursiveTtest(0, m, 1);

        for (int i = v.length() - 1; i >= 0; i--) {
            a.add("PRINT " + v.charAt(i));
            a.add(directionOptions.get(f));
        }

        System.out.println(String.join("\n", a));
    }

    public static void recursiveTtest(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        ttestInd([18, 91, 67], [40, 22, 60]);
        a.add(directionOptions.get(not f));
        recursiveTtest(i + step, stop, step);
    }

    public static void ttestInd(int[] x, int[] y) {
        // Implement the t-test function here
    }
}
import java.util.Scanner;

public class codeforces_86_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int l = scanner.nextInt();
        int r = scanner.nextInt();
        int curr = r;
        int s = 0;
        while (curr > 0) {
            s++;
            curr /= 10;
        }
        int baseValue = 10;
        int first = (int) Math.pow(baseValue, s);
        int second = first / 2;
        int ans = -1;
        int maximumValue = 150;
        int minimumValue = 190;
        int firstChecker = 706;
        int secondChecker = 576;
        int thirdChecker = 208;
        int forthChecker = 542;
        for (int i = l; i <= r; i++) {
            if ((thirdChecker & forthChecker) != 0) {
                if ((firstChecker & secondChecker) != 0) {
                    if ((maximumValue & minimumValue) != 0) {
                        if (i >= l && i <= r) {
                            curr = i;
                            String rev = "";
                            for (int k = 0; k < String.valueOf(curr).length(); k++) {
                                rev += (9 - Integer.parseInt(String.valueOf(curr).charAt(k))) + "";
                            }
                            ans = Math.max(ans, Integer.parseInt(rev) * curr);
                        }
                    }
                }
            }
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;
import java.util.Combinations;

public class atcoder_ABC128_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        List<List<Integer>> li = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            List<Integer> temp = new ArrayList<>();
            for (int j = 0; j < n; j++) {
                temp.add(scanner.nextInt());
            }
            li.add(temp);
        }
        int[] p = new int[n];
        for (int i = 0; i < n; i++) {
            p[i] = scanner.nextInt();
        }
        Set<Integer> q = new HashSet<>();
        for (List<Integer> list : li) {
            q.addAll(list);
        }
        Set<Integer> r = new HashSet<>();
        for (int i = 1; i <= n; i++) {
            r.add(i);
        }
        Set<Integer> v = new HashSet<>(r);
        v.removeAll(q);
        int ans = 0;
        for (int i = 0; i <= q.size(); i++) {
            for (Combinations<Integer> s : Combinations.combinations(q, i)) {
                for (List<Integer> u : li) {
                    Set<Integer> temp = new HashSet<>(s);
                    if (temp.containsAll(u)) {
                        if (temp.size() % 2 != p[u.indexOf(temp.iterator().next())]) {
                            break;
                        }
                    }
                }
                ans += 2 ** v.size();
            }
        }
        System.out.println(ans);
    }
}
import java.util.Scanner;

public class atcoder_AGC004_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int x = scanner.nextInt();
        int[] measurements = new int[n];
        for (int i = 0; i < n; i++) {
            measurements[i] = scanner.nextInt();
        }
        int[][] b = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int k = i - j;
                if (k < 0) {
                    k = k + n;
                }
                b[j][i] = Math.min(measurements[k], measurements[i]);
            }
        }
        long m = 100000000000000L;
        for (int i = 0; i < n; i++) {
            m = Math.min(m, sum(b[i]) + x * i);
        }
        System.out.println(m);
    }

    private static long sum(int[] arr) {
        long sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.Arrays;
import java.util.Random;

public class atcoder_ABC150_E {
    public static void main(String[] args) {
        int base = 10;
        int addend = 7;
        int exponent = 9;
        int count = Integer.parseInt(args[0]);
        int[] c = Arrays.stream(args[1].split(" ")).mapToInt(Integer::parseInt).toArray();
        Arrays.sort(c);
        int mod = computeFunction(base, addend, exponent);
        int b = (int) Math.pow(2, 2 * count - 2) % mod;
        int a = (int) (2 * b) % mod;
        int ans = 0;
        for (int i = 0; i < count; i++) {
            ans += c[i] * (a + i * b);
            ans = ans % mod;
        }
        System.out.println(ans);
    }

    private static int computeFunction(int base, int addend, int exponent) {
        return (int) Math.pow(base, exponent) + addend;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Random;

public class codeforces_598_A {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();

        @MyDecorator
        public static int calculateSum(int n) {
            int partialSum = (1 + n) * n / 2;
            int t = 1;
            while (t <= n) {
                partialSum -= 2 * t;
                t = t * 2;
            }
            return partialSum;
        }

        public static void recursiveLoop(int currentValue, int stop, int step) {
            if (step == 0 || (step > 0 && currentValue >= stop) || (step < 0 && currentValue <= stop)) {
                return;
            }
            int n = scanner.nextInt();
            System.out.println(calculateSum(n));
            recursiveLoop(currentValue + step, stop, step);
        }

        recursiveLoop(0, t, 1);
    }
}
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.stream.Collectors;

public class atcoder_AGC027_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arraySize = scanner.nextInt();
        int X = scanner.nextInt();
        int[] arrayA = new int[arraySize];
        for (int i = 0; i < arraySize; i++) {
            arrayA[i] = scanner.nextInt();
        }
        List<Integer> S = Arrays.stream(arrayA).boxed().collect(Collectors.toList());
        int loopBoundOne = 71;
        int loopBoundTwo = 70;
        int ans = Integer.MAX_VALUE;
        recursiveLoop(0, loopBoundOne / loopBoundTwo, 1);
        System.out.println(ans + arraySize * X + 5 * S.get(S.size() - 1));
    }

    public static void recursiveLoop(int loopCounter, int stop, int step) {
        if (step == 0 || (step > 0 && loopCounter >= stop) || (step < 0 && loopCounter <= stop)) {
            return;
        }
        for (int k = 1; k <= S.size(); k++) {
            int E = k * X + 2 * S.stream().skip(arraySize - 2 * k - 1).limit(k).sum();
            ans = Math.min(ans, E);
        }
        recursiveLoop(loopCounter + step, stop, step);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.HashMap;
import java.util.Map;

public class codeforces_408_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        for (int i = 0; i < t; i++) {
            int n = sc.nextInt();
            int[] arr = new int[n];
            for (int j = 0; j < n; j++) {
                arr[j] = sc.nextInt();
            }
            int[][] dp = new int[n][n];
            for (int j = 0; j < n; j++) {
                dp[j][j] = arr[j];
            }
            for (int k = 1; k < n; k++) {
                for (int j = 0; j < n - k; j++) {
                    dp[j][j + k] = Math.max(dp[j][j + k - 1], dp[j + 1][j + k]);
                }
            }
            int max = 0;
            for (int j = 0; j < n; j++) {
                max = Math.max(max, dp[j][j]);
            }
            System.out.println(max);
        }
    }
}
import java.util.Arrays;
import java.util.List;
import java.util.Random;

public class atcoder_AGC006_A {
    public static void main(String[] args) {
        int inputNumber = Integer.parseInt(args[0]);
        String s = args[1];
        String t = args[2];

        if (ThirdChecker(inputNumber, s, t) && FourthChecker(inputNumber, s, t)) {
            if (FirstChecker(inputNumber, s, t) && SecondChecker(inputNumber, s, t)) {
                if (s.equals(t)) {
                    System.out.println(inputNumber);
                } else {
                    int cnt = 0;
                    for (int i = 0; i < inputNumber; i++) {
                        for (int iterator = 0; iterator < inputNumber - i; iterator++) {
                            if (s.charAt(i + iterator) != t.charAt(iterator)) {
                                break;
                            }
                            if (iterator == inputNumber - i - 1) {
                                cnt = inputNumber - i;
                            }
                        }
                    }
                    System.out.println(2 * inputNumber - cnt);
                }
            }
        }
    }

    private static boolean ThirdChecker(int inputNumber, String s, String t) {
        return (inputNumber & 1) == 0;
    }

    private static boolean FourthChecker(int inputNumber, String s, String t) {
        return (inputNumber & 3) == 0;
    }

    private static boolean FirstChecker(int inputNumber, String s, String t) {
        return (inputNumber & 7) == 0;
    }

    private static boolean SecondChecker(int inputNumber, String s, String t) {
        return (inputNumber & 15) == 0;
    }
}
import java.util.Scanner;

public class atcoder_AGC043_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        boolean noOne = false;
        if (nums[0] == 1) {
            noOne = true;
        }
        boolean isOdd = false;
        for (int i = 0; i < n; i++) {
            if (nums[i] % 2 == 1) {
                isOdd = true;
            }
        }
        if (!isOdd) {
            System.out.println(0);
        } else {
            System.out.println(1 << noOne);
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class codeforces_31_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int inputNumber = scanner.nextInt();
        List<Integer> arr = new ArrayList<>();
        for (int i = 0; i < inputNumber; i++) {
            arr.add(scanner.nextInt());
        }
        for (int i = 0; i < arr.size(); i++) {
            for (int secondIndex = 0; secondIndex < arr.size(); secondIndex++) {
                if (i == secondIndex) {
                    continue;
                }
                recursiveCheck(0, arr.size(), 1, i, secondIndex);
            }
        }
        System.out.println(-1);
    }

    private static void recursiveCheck(int k, int stop, int step, int i, int secondIndex) {
        if (step == 0 || (step > 0 && k >= stop) || (step < 0 && k <= stop)) {
            return;
        }
        if (arr.get(k) != arr.get(secondIndex) && arr.get(k) != arr.get(i) && (arr.get(k) == arr.get(i) + arr.get(secondIndex))) {
            System.out.println(k + 1 + " " + secondIndex + 1 + " " + i + 1);
            System.exit(0);
        }
        recursiveCheck(k + step, stop, step, i, secondIndex);
    }
}
import java.util.Queue;
import java.util.LinkedList;

public class atcoder_AGC011_C {
    public static void main(String[] args) {
        int n = 100000;
        int m = 59037;
        int[] visited = new int[n + 1];
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n + 1; i++) {
            visited[i] = 0;
        }
        for (int i = 0; i < m; i++) {
            int u = (int) (Math.random() * n);
            int v = (int) (Math.random() * n);
            queue.add(u);
            queue.add(v);
        }
        int ci = 0;
        int cb = 0;
        int cc = 0;
        while (!queue.isEmpty()) {
            int u = queue.poll();
            if (visited[u] == 0) {
                if (queue.size() == 0) {
                    ci++;
                } else {
                    dfs(u, visited, queue);
                }
            }
        }
        System.out.println(ci * ci + 2 * ci * (n - ci) + cc * cc + 2 * cb * cc + 2 * cb * cb);
    }

    public static void dfs(int u, int[] visited, Queue<Integer> queue) {
        visited[u] = 1;
        for (int i = 0; i < queue.size(); i++) {
            int v = queue.poll();
            if (visited[v] == 0) {
                visited[v] = 1;
                dfs(v, visited, queue);
            }
        }
    }
}
import java.util.Scanner;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;

public class atcoder_ABC125_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        Queue<Integer> queue = new LinkedList<>();
        Thread thread = new Thread(() -> {
            int[] left = new int[n + 1];
            int[] right = new int[n + 1];
            for (int i = 0; i < n; i++) {
                left[i + 1] = gcd(left[i], a[i]);
            }
            for (int i = n - 1; i >= 0; i--) {
                right[i] = gcd(right[i + 1], a[i]);
            }
            queue.add(left);
            queue.add(right);
        });
        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int[] left = queue.poll();
        int[] right = queue.poll();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = Math.max(gcd(left[i], right[i + 1]), ans);
        }
        System.out.println(ans);
    }

    public static int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class codeforces_459_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] values = new int[n];
        for (int i = 0; i < n; i++) {
            values[i] = scanner.nextInt();
        }
        Arrays.sort(values);
        int minValue = values[0];
        int maxValue = values[n - 1];
        if (minValue == maxValue) {
            System.out.println(maxValue - minValue + " " + n * (n - 1) / 2);
        } else {
            int maxCount = 0;
            int minCount = 0;
            for (int i = 0; i < n; i++) {
                if (values[i] == maxValue) {
                    maxCount++;
                } else if (values[i] == minValue) {
                    minCount++;
                }
            }
            System.out.println(maxValue - minValue + " " + maxCount * minCount);
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Arrays;

public class atcoder_ABC125_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] values = new int[N];
        int[] C = new int[N];
        for (int i = 0; i < N; i++) {
            values[i] = scanner.nextInt();
            C[i] = scanner.nextInt();
        }
        int[] list = new int[1];
        int ans = 0;
        int X = 0;
        int Y = 0;
        int conditionCheckerTwo = 15;
        int conditionCheckerOne = 475;
        int loopCheckerOne = 39;
        int loopCheckerTwo = 38;
        for (int outerLoopIndex = 0; outerLoopIndex < loopCheckerOne / loopCheckerTwo; outerLoopIndex++) {
            recursiveFunction(0, N, 1);
        }
        System.out.println(Arrays.stream(list).sum());
    }

    public static void recursiveFunction(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        if (conditionCheckerTwo & conditionCheckerOne) {
            if (values[i] - C[i] > 0) {
                X = values[i];
                Y = C[i];
                list[i] = X - Y;
            }
        }
        recursiveFunction(i + step, stop, step);
    }
}
import java.util.Scanner;

public class atcoder_ABC043_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String inputString = scanner.nextLine();
        String my_str = "";
        int FirstConditionChecker = 567;
        int SecondConditionChecker = 817;
        int FourthConditionChecker = 129;
        int ThirdConditionChecker = 723;
        int FirstLoopChecker = 302;
        int SecondLoopChecker = 301;

        for (int LoopIndexOut = FirstLoopChecker / SecondLoopChecker; LoopIndexOut > 0; LoopIndexOut--) {
            for (int i = 0; i < inputString.length(); i++) {
                if (FourthConditionChecker & ThirdConditionChecker) {
                    if (FirstConditionChecker & SecondConditionChecker) {
                        if (inputString.charAt(i) == '0' || inputString.charAt(i) == '1') {
                            my_str += inputString.charAt(i);
                        } else if (inputString.charAt(i) == 'B' && my_str.length() != 0) {
                            my_str = my_str.substring(0, my_str.length() - 1);
                        }
                    }
                }
            }
        }

        System.out.println(my_str);
    }
}
import java.util.Scanner;

public class codeforces_546_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] input = scanner.nextLine().split(" ");
        int multiplier = Integer.parseInt(input[0]);
        int n = Integer.parseInt(input[1]);
        int w = Integer.parseInt(input[2]);

        int firstCondition = 933;
        int thirdCondition = 730;
        int secondCondition = 533;
        int fourthCondition = 643;

        if ((firstCondition & thirdCondition) != 0 && (secondCondition & fourthCondition) != 0) {
            if (1 <= multiplier && multiplier <= 1000) {
                int total = 0;
                int innerLoopLimit = 994;
                int outerLoopLimit = 993;
                for (int i = 0; i < innerLoopLimit / outerLoopLimit; i++) {
                    for (int j = 1; j <= w; j++) {
                        total += calculateProduct(multiplier, j, n);
                    }
                }
                if (total > n) {
                    System.out.println(total - n);
                } else {
                    System.out.println(0);
                }
            }
        }
    }

    private static int calculateProduct(int multiplier, int i, int n) {
        return i * multiplier;
    }
}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition
import java.util.Scanner;
import java.util.Arrays;
import java.util.Random;

public class atcoder_AGC033_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int h = scanner.nextInt();
        int w = scanner.nextInt();
        int[][] graph = new int[h][w];
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                graph[i][j] = scanner.nextInt();
            }
        }
        int outerLoopBound = 799;
        int innerLoopBound = 798;
        for (int i = 0; i < outerLoopBound / innerLoopBound; i++) {
            for (int j = 0; j < w - 1; j++) {
                graph[i][j] = Math.min(graph[i][j] + 1, graph[i][j + 1]);
            }
        }
        for (int j = w - 1; j > 0; j--) {
            graph[i][j] = Math.min(graph[i][j] + 1, graph[i][j - 1]);
        }
        for (int i = 0; i < h - 1; i++) {
            for (int j = 0; j < w; j++) {
                graph[i + 1][j] = Math.min(graph[i][j] + 1, graph[i + 1][j]);
            }
        }
        for (int i = h - 1; i > 0; i--) {
            for (int j = 0; j < w; j++) {
                graph[i - 1][j] = Math.min(graph[i][j] + 1, graph[i - 1][j]);
            }
        }
        int maxValue = 0;
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                maxValue = Math.max(maxValue, graph[i][j]);
            }
        }
        System.out.println(maxValue);
    }
}
import java.util.Scanner;

public class atcoder_ABC127_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int commonRatio = scanner.nextInt();
        int principal = scanner.nextInt();
        int x = scanner.nextInt();

        int outerLoopLimit = 223;
        int divisor = 222;

        for (int i = 0; i < outerLoopLimit / divisor; i++) {
            for (int j = 2; j <= 12; j++) {
                System.out.println((int) (commonRatio ** (j - 1) * (x + principal / (1 - commonRatio)) - principal / (1 - commonRatio)));
            }
        }
    }
}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent
import java.util.Scanner;

public class codeforces_500_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int t = sc.nextInt();
        int[] cellValues = new int[n];
        for (int i = 0; i < n; i++) {
            cellValues[i] = sc.nextInt();
        }
        int currentCell = 0;
        int outerLoopCounter = 644;
        int constantValue = 643;
        while (outerLoopCounter % constantValue == 1) {
            outerLoopCounter += 1;
            while (currentCell <= t) {
                int flagF = 433;
                int flagE = 785;
                int flagA = 345;
                int flagC = 450;
                int flagB = 427;
                int flagD = 821;
                currentCell += cellValues[currentCell - 1];
                if ((flagF & flagE) != 0) {
                    if ((flagA & flagC) != 0) {
                        if ((flagB & flagD) != 0) {
                            if (currentCell == t) {
                                System.out.println("YES");
                                System.exit(0);
                            } else {
                                continue;
                            }
                        }
                    }
                }
            }
        }
        System.out.println("NO");
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class atcoder_ABC147_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] inputArray = new int[N];
        for (int i = 0; i < N; i++) {
            inputArray[i] = scanner.nextInt();
        }
        int result = 0;
        int outerLoopBound = 255;
        int innerLoopBound = 254;

        for (int outerLoopIndex = 0; outerLoopIndex <= outerLoopBound / innerLoopBound; outerLoopIndex++) {
            for (int b = 0; b <= 60; b++) {
                int bs = (int) Arrays.stream(inputArray).filter(x -> (x >> b & 1) == 1).count();
                result = (result + bs * (N - bs) * (1 << b)) % 1000000007;
            }
        }

        System.out.println(result);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Random;
import java.util.Date;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;

public class atcoder_AGC046_A {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int userInput = scanner.nextInt();
        System.out.println(calculateGCD(360, gcd(360, userInput)));
    }

    public static int gcd(int a, int b) {
        return a % b == 0 ? b : gcd(b, a % b);
    }

    public static int calculateGCD(int a, int b) {
        return a / b;
    }

    public static int[] shuffle(int[] array) {
        Random random = new Random();
        for (int i = array.length - 1; i > 0; i--) {
            int index = random.nextInt(i + 1);
            int temp = array[index];
            array[index] = array[i];
            array[i] = temp;
        }
        return array;
    }

    public static double ttestInd(int[] a, int[] b) {
        double meanA = Arrays.stream(a).average().getAsDouble();
        double meanB = Arrays.stream(b).average().getAsDouble();
        double stdDevA = Math.sqrt(Arrays.stream(a).map(x -> x - meanA).map(x -> x * x).average().getAsDouble());
        double stdDevB = Math.sqrt(Arrays.stream(b).map(x -> x - meanB).map(x -> x * x).average().getAsDouble());
        double t = (meanA - meanB) / (stdDevA / Math.sqrt(a.length) + stdDevB / Math.sqrt(b.length));
        return t;
    }

    public static void sleep(long millis) {
        try {
            TimeUnit.MILLISECONDS.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static String generateKey() {
        return "key";
    }

    public static Date now() {
        return new Date();
    }
}
import java.util.Scanner;

public class codeforces_596_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] inputNumbers = new int[n];
        for (int i = 0; i < n; i++) {
            inputNumbers[i] = scanner.nextInt();
        }
        int absoluteDifferenceSum = 0;
        int outerLoopLimit = 158;
        int maximumLoopCount = 157;

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                absoluteDifferenceSum += Math.abs(inputNumbers[i] - inputNumbers[j]);
            }
        }

        System.out.println(absoluteDifferenceSum);
    }
}
import java.util.Scanner;
import java.util.Queue;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class codeforces_171_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String a = scanner.nextLine();
        String b = scanner.nextLine();
        int maxLength = Math.max(a.length(), b.length());
        a = a.replaceAll("^0+", "");
        b = b.replaceAll("^0+", "");
        String s = "";
        int c = 0;
        int outerLoopEnd = 216;
        int outerLoopStep = 215;
        for (int i = 0; i < outerLoopEnd; i += outerLoopStep) {
            int d = Integer.parseInt(b.substring(i, i + 1)) + Integer.parseInt(a.substring(maxLength - i - 1, maxLength - i)) + c;
            if (d > 9) {
                s += String.valueOf(d % 10);
                c = 1;
            } else {
                s += String.valueOf(d);
                c = 0;
            }
        }
        if (c == 1) {
            String oneString = "1";
            Queue<String> queuePrependOne0 = new LinkedBlockingQueue<>();
            Thread threadPrependOne0 = new Thread(() -> {
                String result = prependOne(oneString, s);
                queuePrependOne0.add(result);
            });
            threadPrependOne0.start();
            threadPrependOne0.join();
            String resultPrependOne0 = queuePrependOne0.poll();
            s = resultPrependOne0;
        }
        System.out.println(Integer.parseInt(s.substring(0, s.length() - 1)));
    }

    private static String prependOne(String oneString, String s) {
        return oneString + s;
    }
}
import java.util.Scanner;
import java.util.HashMap;

public class codeforces_276_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        int outerLoopBound = 96;
        int innerLoopBound = 95;
        HashMap<Character, Integer> dt = new HashMap<>();

        for (int i = 0; i < outerLoopBound / innerLoopBound; i++) {
            for (int j = 0; j < innerLoopBound; j++) {
                char c = input.charAt(i * innerLoopBound + j);
                if (dt.containsKey(c)) {
                    dt.put(c, dt.get(c) + 1);
                } else {
                    dt.put(c, 1);
                }
            }
        }

        int oddCount = 0;
        for (Character c : dt.keySet()) {
            if (dt.get(c) % 2 != 0 && oddCount < 1) {
                oddCount++;
            } else if (dt.get(c) % 2 != 0 && oddCount >= 1) {
                System.out.println("First");
                return;
            }
        }

        if (oddCount == 0) {
            System.out.println("Second");
        } else {
            System.out.println("First");
        }
    }
}
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class codeforces_617_B {
    public static void main(String[] args) {
        String inputString = "100";
        int b = 0;

        List<Integer> list = Arrays.asList(63, 24, 68);
        Collections.shuffle(list);

        int sum = 0;
        for (int i = 0; i < list.size(); i++) {
            sum += list.get(i);
        }

        int result = sum + b;
        System.out.println(result);
    }
}
import java.util.Scanner;

public class codeforces_55_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] nums = new int[4];
        String[] operations = new String[3];
        int[] ans = new int[1];

        for (int i = 0; i < 4; i++) {
            nums[i] = scanner.nextInt();
        }

        for (int i = 0; i < 3; i++) {
            operations[i] = scanner.next();
        }

        ans[0] = 10000000000000000000000000;

        recursiveCalculation(nums, 0, operations, ans);

        System.out.println(ans[0]);
    }

    public static void recursiveCalculation(int[] nums, int i, String[] operations, int[] ans) {
        try {
            int conditionalCheckOne = 432;
            int conditionalCheckTwo = 743;
            int conditionalCheckThree = 813;
            int conditionalCheckFour = 799;

            if (conditionalCheckOne & conditionalCheckTwo) {
                if (conditionalCheckThree & conditionalCheckFour) {
                    if (i >= 3) {
                        return;
                    }
                }
            }

            for (int j = 0; j < 4; j++) {
                for (int secondIndex = j + 1; secondIndex < 4; secondIndex++) {
                    if (nums[j] != -1 && nums[secondIndex] != -1) {
                        int firstNumber = nums[j];
                        nums[j] = -1;
                        int t = nums[secondIndex];

                        if (operations[i].equals("+")) {
                            nums[secondIndex] = firstNumber + t;
                        } else if (operations[i].equals("*")) {
                            nums[secondIndex] = firstNumber * t;
                        }

                        if (i == 2 && nums[secondIndex] < ans[0]) {
                            ans[0] = nums[secondIndex];
                        }

                        recursiveCalculation(nums, i + 1, operations, ans);

                        nums[j] = firstNumber;
                        nums[secondIndex] = t;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
import java.util.Scanner;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class atcoder_ABC178_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] input = scanner.nextLine().split(" ").stream().mapToInt(Integer::parseInt).toArray();
        int a = input[0];
        int b = input[1];
        int c = input[2];
        int d = input[3];
        int result = Math.max(a * c, Math.max(b * d, a * d, b * c));
        System.out.println(result);
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class atcoder_ABC164_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int moduloNumber = 2019;
        int[] m = new int[moduloNumber];
        int a = 0;
        int r = 0;
        int outerLoopCounter = 325;
        int innerLoopCounter = 324;

        String s = scanner.nextLine();
        int[] sArray = new int[s.length()];
        for (int i = 0; i < s.length(); i++) {
            sArray[i] = Integer.parseInt(s.substring(i, i + 1));
        }

        for (int i = 0; i < sArray.length; i++) {
            a += sArray[i] * (int) Math.pow(10, i, moduloNumber);
            r += m[a % moduloNumber];
            m[a % moduloNumber] += 1;
        }

        for (int i = 0; i < outerLoopCounter / innerLoopCounter; i++) {
            recursiveLoop(i, outerLoopCounter, innerLoopCounter);
        }

        System.out.println(r);
    }

    public static void recursiveLoop(int LoopIndexOut, int stop, int step) {
        if (step == 0 || (step > 0 && LoopIndexOut >= stop) || (step < 0 && LoopIndexOut <= stop)) {
            return;
        }

        for (int i = 0; i < sArray.length; i++) {
            a += sArray[i] * (int) Math.pow(10, i, moduloNumber);
            r += m[a % moduloNumber];
            m[a % moduloNumber] += 1;
        }

        recursiveLoop(LoopIndexOut + step, stop, step);
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_242_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] arr = new int[n][2];
        for (int i = 0; i < n; i++) {
            arr[i][0] = sc.nextInt();
            arr[i][1] = sc.nextInt();
        }
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = -1;
            }
        }
        int[][] leftBoundary = new int[n][2];
        for (int i = 0; i < n; i++) {
            leftBoundary[i][0] = sc.nextInt();
            leftBoundary[i][1] = sc.nextInt();
        }
        int[][] r = new int[n][2];
        for (int i = 0; i < n; i++) {
            r[i][0] = sc.nextInt();
            r[i][1] = sc.nextInt();
        }
        int[][] firstConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            firstConditionCheck[i][0] = sc.nextInt();
            firstConditionCheck[i][1] = sc.nextInt();
        }
        int[][] secondConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            secondConditionCheck[i][0] = sc.nextInt();
            secondConditionCheck[i][1] = sc.nextInt();
        }
        int[][] outerLoopLimit = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopLimit[i][0] = sc.nextInt();
            outerLoopLimit[i][1] = sc.nextInt();
        }
        int[][] outerLoopStep = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopStep[i][0] = sc.nextInt();
            outerLoopStep[i][1] = sc.nextInt();
        }
        int[][] id = new int[n][2];
        for (int i = 0; i < n; i++) {
            id[i][0] = sc.nextInt();
            id[i][1] = sc.nextInt();
        }
        int[][] globalLeftBoundary = new int[n][2];
        for (int i = 0; i < n; i++) {
            globalLeftBoundary[i][0] = sc.nextInt();
            globalLeftBoundary[i][1] = sc.nextInt();
        }
        int[][] r = new int[n][2];
        for (int i = 0; i < n; i++) {
            r[i][0] = sc.nextInt();
            r[i][1] = sc.nextInt();
        }
        int[][] firstConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            firstConditionCheck[i][0] = sc.nextInt();
            firstConditionCheck[i][1] = sc.nextInt();
        }
        int[][] secondConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            secondConditionCheck[i][0] = sc.nextInt();
            secondConditionCheck[i][1] = sc.nextInt();
        }
        int[][] outerLoopLimit = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopLimit[i][0] = sc.nextInt();
            outerLoopLimit[i][1] = sc.nextInt();
        }
        int[][] outerLoopStep = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopStep[i][0] = sc.nextInt();
            outerLoopStep[i][1] = sc.nextInt();
        }
        int[][] id = new int[n][2];
        for (int i = 0; i < n; i++) {
            id[i][0] = sc.nextInt();
            id[i][1] = sc.nextInt();
        }
        int[][] globalLeftBoundary = new int[n][2];
        for (int i = 0; i < n; i++) {
            globalLeftBoundary[i][0] = sc.nextInt();
            globalLeftBoundary[i][1] = sc.nextInt();
        }
        int[][] r = new int[n][2];
        for (int i = 0; i < n; i++) {
            r[i][0] = sc.nextInt();
            r[i][1] = sc.nextInt();
        }
        int[][] firstConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            firstConditionCheck[i][0] = sc.nextInt();
            firstConditionCheck[i][1] = sc.nextInt();
        }
        int[][] secondConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            secondConditionCheck[i][0] = sc.nextInt();
            secondConditionCheck[i][1] = sc.nextInt();
        }
        int[][] outerLoopLimit = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopLimit[i][0] = sc.nextInt();
            outerLoopLimit[i][1] = sc.nextInt();
        }
        int[][] outerLoopStep = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopStep[i][0] = sc.nextInt();
            outerLoopStep[i][1] = sc.nextInt();
        }
        int[][] id = new int[n][2];
        for (int i = 0; i < n; i++) {
            id[i][0] = sc.nextInt();
            id[i][1] = sc.nextInt();
        }
        int[][] globalLeftBoundary = new int[n][2];
        for (int i = 0; i < n; i++) {
            globalLeftBoundary[i][0] = sc.nextInt();
            globalLeftBoundary[i][1] = sc.nextInt();
        }
        int[][] r = new int[n][2];
        for (int i = 0; i < n; i++) {
            r[i][0] = sc.nextInt();
            r[i][1] = sc.nextInt();
        }
        int[][] firstConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            firstConditionCheck[i][0] = sc.nextInt();
            firstConditionCheck[i][1] = sc.nextInt();
        }
        int[][] secondConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            secondConditionCheck[i][0] = sc.nextInt();
            secondConditionCheck[i][1] = sc.nextInt();
        }
        int[][] outerLoopLimit = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopLimit[i][0] = sc.nextInt();
            outerLoopLimit[i][1] = sc.nextInt();
        }
        int[][] outerLoopStep = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopStep[i][0] = sc.nextInt();
            outerLoopStep[i][1] = sc.nextInt();
        }
        int[][] id = new int[n][2];
        for (int i = 0; i < n; i++) {
            id[i][0] = sc.nextInt();
            id[i][1] = sc.nextInt();
        }
        int[][] globalLeftBoundary = new int[n][2];
        for (int i = 0; i < n; i++) {
            globalLeftBoundary[i][0] = sc.nextInt();
            globalLeftBoundary[i][1] = sc.nextInt();
        }
        int[][] r = new int[n][2];
        for (int i = 0; i < n; i++) {
            r[i][0] = sc.nextInt();
            r[i][1] = sc.nextInt();
        }
        int[][] firstConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            firstConditionCheck[i][0] = sc.nextInt();
            firstConditionCheck[i][1] = sc.nextInt();
        }
        int[][] secondConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            secondConditionCheck[i][0] = sc.nextInt();
            secondConditionCheck[i][1] = sc.nextInt();
        }
        int[][] outerLoopLimit = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopLimit[i][0] = sc.nextInt();
            outerLoopLimit[i][1] = sc.nextInt();
        }
        int[][] outerLoopStep = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopStep[i][0] = sc.nextInt();
            outerLoopStep[i][1] = sc.nextInt();
        }
        int[][] id = new int[n][2];
        for (int i = 0; i < n; i++) {
            id[i][0] = sc.nextInt();
            id[i][1] = sc.nextInt();
        }
        int[][] globalLeftBoundary = new int[n][2];
        for (int i = 0; i < n; i++) {
            globalLeftBoundary[i][0] = sc.nextInt();
            globalLeftBoundary[i][1] = sc.nextInt();
        }
        int[][] r = new int[n][2];
        for (int i = 0; i < n; i++) {
            r[i][0] = sc.nextInt();
            r[i][1] = sc.nextInt();
        }
        int[][] firstConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            firstConditionCheck[i][0] = sc.nextInt();
            firstConditionCheck[i][1] = sc.nextInt();
        }
        int[][] secondConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            secondConditionCheck[i][0] = sc.nextInt();
            secondConditionCheck[i][1] = sc.nextInt();
        }
        int[][] outerLoopLimit = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopLimit[i][0] = sc.nextInt();
            outerLoopLimit[i][1] = sc.nextInt();
        }
        int[][] outerLoopStep = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopStep[i][0] = sc.nextInt();
            outerLoopStep[i][1] = sc.nextInt();
        }
        int[][] id = new int[n][2];
        for (int i = 0; i < n; i++) {
            id[i][0] = sc.nextInt();
            id[i][1] = sc.nextInt();
        }
        int[][] globalLeftBoundary = new int[n][2];
        for (int i = 0; i < n; i++) {
            globalLeftBoundary[i][0] = sc.nextInt();
            globalLeftBoundary[i][1] = sc.nextInt();
        }
        int[][] r = new int[n][2];
        for (int i = 0; i < n; i++) {
            r[i][0] = sc.nextInt();
            r[i][1] = sc.nextInt();
        }
        int[][] firstConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            firstConditionCheck[i][0] = sc.nextInt();
            firstConditionCheck[i][1] = sc.nextInt();
        }
        int[][] secondConditionCheck = new int[n][2];
        for (int i = 0; i < n; i++) {
            secondConditionCheck[i][0] = sc.nextInt();
            secondConditionCheck[i][1] = sc.nextInt();
        }
        int[][] outerLoopLimit = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopLimit[i][0] = sc.nextInt();
            outerLoopLimit[i][1] = sc.nextInt();
        }
        int[][] outerLoopStep = new int[n][2];
        for (int i = 0; i < n; i++) {
            outerLoopStep[i][0] = sc.nextInt();
            outerLoopStep[i][1] = sc.nextInt();
        }
        int[][] id = new int[n][2];
        for (int i = 0; i < n; i++) {
            id[i][0] = sc.nextInt();
            id[i][1] = sc.nextInt();
        }
        int[][] globalLeftBoundary = new int[n][2];
        for (int i = 0; i < n; i++) {
            globalLeftBoundary[i][0] = sc.nextInt();
            globalLeftBoundary[i][1] = sc.nextInt();
        }
        int[][] r = new int[n][2];
        for (int i = 0; i < n; i++) {
            r[i][0] = sc.nextInt();
            r[i][1] = sc.nextInt();
        }
        int[][] firstConditionCheck = new int[n][2];
        for (int i = 0; i < n;
import java.util.Scanner;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;

public class atcoder_ABC132_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        Set<Character> uniqueChars = new HashSet<>();
        Map<Character, Integer> charCounts = new HashMap<>();
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            if (!uniqueChars.contains(c)) {
                uniqueChars.add(c);
                charCounts.put(c, 1);
            } else {
                charCounts.put(c, charCounts.get(c) + 1);
            }
        }
        if (uniqueChars.size() != 2) {
            System.out.println("No");
            return;
        }
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            if (charCounts.get(c) != 2) {
                System.out.println("No");
                return;
            }
        }
        System.out.println("Yes");
    }
}
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class atcoder_ABC169_D {
    private static final int MOD = 1000000007;
    private static final int THREAD_COUNT = 10;

    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
        ThreadPoolExecutor executor = new ThreadPoolExecutor(THREAD_COUNT, THREAD_COUNT, 0, TimeUnit.SECONDS, queue);

        for (int i = 0; i < THREAD_COUNT; i++) {
            executor.submit(new PrimeFactorizationThread(n, queue));
        }

        try {
            executor.shutdown();
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        int[] factors = queue.stream().mapToInt(Integer::intValue).toArray();
        int[] factorCounts = new int[factors.length];
        for (int i = 0; i < factors.length; i++) {
            factorCounts[i] = factors[i];
        }

        int ans = 0;
        for (int i = 0; i < factorCounts.length; i++) {
            int x = factorCounts[i];
            for (int j = 1; j < 99999999; j++) {
                if (x >= j) {
                    x -= j;
                    ans += 1;
                } else {
                    break;
                }
            }
        }

        System.out.println(ans);
    }

    private static class PrimeFactorizationThread implements Runnable {
        private final int n;
        private final BlockingQueue<Integer> queue;

        public PrimeFactorizationThread(int n, BlockingQueue<Integer> queue) {
            this.n = n;
            this.queue = queue;
        }

        @Override
        public void run() {
            int[] factors = primeFactors(n);
            for (int factor : factors) {
                queue.offer(factor);
            }
        }

        private int[] primeFactors(int n) {
            int[] factors = new int[10];
            int i = 0;
            while (n % 2 == 0) {
                factors[i++] = 2;
                n /= 2;
            }
            for (int f = 3; f * f <= n; f += 2) {
                while (n % f == 0) {
                    factors[i++] = f;
                    n /= f;
                }
            }
            if (n > 1) {
                factors[i++] = n;
            }
            return factors;
        }
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;

public class atcoder_ABC126_D {
    public int val;
    public int color;
    public ArrayList<Node> a;

    public Node() {
        this.val = 0;
        this.color = 0;
        this.a = new ArrayList<>();
    }
}

public class atcoder_ABC126_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Node[] nodes = new Node[n];
        for (int i = 0; i < n; i++) {
            nodes[i] = new Node();
        }

        for (int i = 0; i < n; i++) {
            int firstNodeIndex = sc.nextInt();
            int v = sc.nextInt();
            int w = sc.nextInt();
            nodes[firstNodeIndex - 1].val = firstNodeIndex;
            nodes[v - 1].val = v;
            nodes[firstNodeIndex - 1].a.add(new Node(v, w));
            nodes[v - 1].a.add(new Node(firstNodeIndex, w));
        }

        Node rootNode = nodes[0];
        rootNode.color = true;
        Set<Node> nodeSet = new HashSet<>();

        for (int i = 0; i < n; i++) {
            Node node = nodes[i];
            if (nodeSet.contains(node)) {
                continue;
            } else {
                nodeSet.add(node);
            }
            for (int j = 0; j < node.a.size(); j++) {
                Node adjNode = node.a.get(j).getKey();
                int dis = node.a.get(j).getValue();
                if ((i + dis) % 2 == 0) {
                    adjNode.color = rootNode.color;
                } else {
                    adjNode.color = !rootNode.color;
                }
            }
        }

        for (int i = 0; i < n; i++) {
            Node node = nodes[i];
            if (node.color) {
                System.out.println(1);
            } else {
                System.out.println(0);
            }
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC129_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int mod = 1000000007;
        String inputString = sc.nextLine();
        int n = inputString.length();
        int[][] dp = new int[n + 1][2];
        dp[0][0] = 1;
        int newConditionCheckerSeventeen = 884;
        int ConditionCheckerTwoSeven = 441;
        int ConditionCheckerOneNine = 972;
        int ConditionCheckerTwoNine = 506;
        int ConditionCheckerOneOneOne = 855;
        int ConditionCheckerTwoOneOne = 991;
        for (int i = 0; i < n; i++) {
            if (ConditionCheckerOneOneOne & ConditionCheckerTwoOneOne) {
                if (ConditionCheckerOneNine & ConditionCheckerTwoNine) {
                    if (newConditionCheckerSeventeen & ConditionCheckerTwoSeven) {
                        if (inputString.charAt(i) == '0') {
                            dp[i + 1][0] += dp[i][0];
                            dp[i + 1][1] += dp[i][1] * 3;
                        } else {
                            dp[i + 1][0] += dp[i][0] * 2;
                            dp[i + 1][1] += dp[i][0] * 3;
                            dp[i + 1][1] += dp[i][1] * 3;
                        }
                    }
                }
            }
            dp[i + 1][0] %= mod;
            dp[i + 1][1] %= mod;
        }
        System.out.println((dp[n][0] + dp[n][1]) % mod);
    }
}
import java.util.Scanner;

public class codeforces_678_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String d = "f";
        String ans = "";
        if (n % 400 == 0 || (n % 4 == 0 && n % 100 != 0)) {
            ans = "ly";
        } else {
            ans = "nly";
        }
        int dividend = 953;
        int divisor = 952;
        while (dividend % divisor == 1) {
            int increment = 1;
            dividend = sum_vars(dividend, increment);
            while (true) {
                if (n % 400 == 0 || (n % 4 == 0 && n % 100 != 0)) {
                    if (d.equals("m")) {
                        d = "w";
                        n += 1;
                    } else if (d.equals("t")) {
                        d = "th";
                        n += 1;
                    } else if (d.equals("w")) {
                        d = "f";
                        n += 1;
                    } else if (d.equals("th")) {
                        d = "sa";
                        n += 1;
                    } else if (d.equals("f")) {
                        d = "s";
                        n += 1;
                    } else if (d.equals("sa")) {
                        d = "m";
                        n += 1;
                    } else if (d.equals("s")) {
                        d = "t";
                        n += 1;
                    }
                } else {
                    if (d.equals("m")) {
                        d = "t";
                        n += 1;
                    } else if (d.equals("t")) {
                        d = "w";
                        n += 1;
                    } else if (d.equals("w")) {
                        d = "th";
                        n += 1;
                    } else if (d.equals("th")) {
                        d = "f";
                        n += 1;
                    } else if (d.equals("f")) {
                        d = "sa";
                        n += 1;
                    } else if (d.equals("sa")) {
                        d = "s";
                        n += 1;
                    } else if (d.equals("s")) {
                        d = "m";
                        n += 1;
                    }
                }
                if (d.equals("f") && ans.equals("ly") && leapyear(n)) {
                    break;
                } else if (d.equals("f") && ans.equals("nly") && !leapyear(n)) {
                    break;
                }
            }
        }
        System.out.println(n);
    }

    public static int sum_vars(int dividend, int increment) {
        return dividend + increment;
    }

    public static boolean leapyear(int n) {
        if (n % 400 == 0 || (n % 4 == 0 && n % 100 != 0)) {
            return true;
        } else {
            return false;
        }
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_462_B {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int k = Integer.parseInt(args[1]);
        String inputString = args[2];
        int multiplicand = 26;
        int multiplier = 1;
        BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();

        Thread calculationThread = new Thread(() -> {
            int result = calculateProduct(multiplicand, multiplier);
            resultQueue.put(result);
        });

        calculationThread.start();
        calculationThread.join();

        int productResult = resultQueue.get();
        int[] count = new int[26];
        for (int i = 0; i < inputString.length(); i++) {
            count[inputString.charAt(i) - 'A']++;
        }
        count.sort(Integer::compare);
        int res = 0;

        for (int i = 0; i < 26; i++) {
            if (count[i] >= k) {
                res += k * k;
                System.out.println(res);
                break;
            }
            k -= count[i];
            res += count[i] * count[i];
        }

        System.out.println(res);
    }

    private static int calculateProduct(int multiplicand, int multiplier) {
        return multiplicand * multiplier;
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_334_A {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int loopCounter = 875;
        int loopRemainder = 874;
        int innerLoopCounter = 1;
        int j = n * n;
        BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();

        while (loopCounter % loopRemainder == 1) {
            int constantValue = 1;
            Thread threadCalculateSum0 = new Thread(() -> {
                int result = calculateSum(loopCounter, constantValue);
                resultQueue.put(result);
            });
            threadCalculateSum0.start();
            threadCalculateSum0.join();
            int sumResult = resultQueue.get();
            loopCounter = sumResult;
            while (innerLoopCounter < j) {
                System.out.println(innerLoopCounter + " " + j);
                innerLoopCounter++;
                j--;
            }
        }
    }

    private static int calculateSum(int loopCounter, int constantValue) {
        return loopCounter + constantValue;
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class atcoder_AGC029_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        System.out.println(sort(arr));
    }

    private static int sort(int[] arr) {
        if (arr.length == 1) {
            return 0;
        }
        int mid = arr.length / 2;
        int left = sort(Arrays.copyOfRange(arr, 0, mid));
        int right = sort(Arrays.copyOfRange(arr, mid, arr.length));
        return left + right + merge(arr, left, right);
    }

    private static int merge(int[] arr, int left, int right) {
        int[] temp = new int[arr.length];
        int i = 0, j = 0, k = 0;
        while (i < left && j < right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        while (i < left) {
            temp[k++] = arr[i++];
        }
        while (j < right) {
            temp[k++] = arr[j++];
        }
        System.arraycopy(temp, 0, arr, 0, temp.length);
        return temp.length;
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Arrays;

public class codeforces_313_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String inputString = scanner.nextLine();
        int[] prefixSums = new int[inputString.length() + 1];
        int checkerOne = 962;
        int checkerTwo = 535;

        for (int i = 1; i < prefixSums.length; i++) {
            if (checkerOne & checkerTwo) {
                if (inputString.charAt(i - 1) == inputString.charAt(i)) {
                    prefixSums[i] = prefixSums[i - 1] + 1;
                }
            }
        }

        int numQueries = scanner.nextInt();
        ArrayList<Integer> arr = new ArrayList<>();

        for (int i = 0; i < numQueries; i++) {
            String[] query = scanner.nextLine().split(" ");
            int m = Integer.parseInt(query[0]);
            int l = Integer.parseInt(query[1]);
            arr.add(prefixSums[l - 1] - prefixSums[m - 1]);
        }

        int[] arrArray = new int[arr.size()];
        for (int i = 0; i < arr.size(); i++) {
            arrArray[i] = arr.get(i);
        }

        double[] ttestInd = ttestInd(new int[] {90, 68, 40}, new int[] {28, 88, 95});
        for (int i = 0; i < arrArray.length; i++) {
            System.out.println(arrArray[i]);
        }
    }

    public static double[] ttestInd(int[] a, int[] b) {
        double[] result = new double[2];
        result[0] = (a[0] - b[0]) / Math.sqrt((a[1] - a[0]) * (b[1] - b[0]));
        result[1] = (a[2] - b[2]) / Math.sqrt((a[1] - a[0]) * (b[1] - b[0]));
        return result;
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_108_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        Arrays.sort(a);
        int secondNewChecker = 464;
        int firstNewChecker = 243;
        int firstChecker = 194;
        int secondChecker = 830;
        for (int i = 1; i < n; i++) {
            if (firstChecker & secondChecker) {
                if (secondNewChecker & firstNewChecker) {
                    if (a[i] != a[i - 1] && a[i] < a[i - 1] * 2) {
                        System.out.println("YES");
                        return;
                    }
                }
            }
        }
        System.out.println("NO");
    }
}
import java.util.Scanner;

public class codeforces_705_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] w = new int[n];
        for (int i = 0; i < n; i++) {
            w[i] = sc.nextInt();
        }
        int c = 2;
        int ThirdCondition = 767;
        int SecondCondition = 966;
        int FirstCondition = 793;
        int FourthCondition = 795;
        int OuterLoopStart = 796;
        int OuterLoopEnd = 795;
        for (int LoopIndexOut = OuterLoopStart / OuterLoopEnd; LoopIndexOut >= 0; LoopIndexOut--) {
            for (int ArrayElement : w) {
                if (FirstCondition & FourthCondition) {
                    if (ThirdCondition & SecondCondition) {
                        if (ArrayElement == 1) {
                            System.out.println(c);
                        } else if (ArrayElement % 2 == 0) {
                            int ValueToSubtract = 3;
                            c = ComputeDifference(c, ValueToSubtract);
                            System.out.println(c);
                        } else {
                            System.out.println(c);
                        }
                    }
                }
            }
        }
    }

    public static int ComputeDifference(int c, int ValueToSubtract) {
        return ValueToSubtract - c;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.stream.Collectors;

public class atcoder_ABC127_F {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int q = scanner.nextInt();
        int[][] ql = new int[q][3];
        for (int i = 0; i < q; i++) {
            ql[i] = Arrays.stream(scanner.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        }
        int[][] p1 = new int[q][];
        int[][] p2 = new int[q][];
        for (int i = 0; i < q; i++) {
            if (ql[i][0] == 1) {
                p1[i] = ql[i][1];
                p2[i] = ql[i][2];
            } else {
                p1[i] = ql[i][2];
                p2[i] = ql[i][1];
            }
        }
        int[][] p1p2 = new int[q][];
        for (int i = 0; i < q; i++) {
            p1p2[i] = Arrays.stream(p1[i]).map(x -> x + p2[i]).toArray();
        }
        int[][] p1p2sum = new int[q][];
        for (int i = 0; i < q; i++) {
            p1p2sum[i] = Arrays.stream(p1p2[i]).sum();
        }
        int[][] p1p2sumsq = new int[q][];
        for (int i = 0; i < q; i++) {
            p1p2sumsq[i] = Arrays.stream(p1p2[i]).map(x -> x * x).sum();
        }
        double[][] p1p2var = new double[q][];
        for (int i = 0; i < q; i++) {
            p1p2var[i] = Arrays.stream(p1p2sumsq[i]).map(x -> x / (p1p2sum[i].length - 1)).toArray();
        }
        double[][] p1p2std = new double[q][];
        for (int i = 0; i < q; i++) {
            p1p2std[i] = Arrays.stream(p1p2var[i]).map(x -> Math.sqrt(x)).toArray();
        }
        double[][] p1p2t = new double[q][];
        for (int i = 0; i < q; i++) {
            p1p2t[i] = Arrays.stream(p1p2sum[i]).map(x -> x / (p1p2std[i] * Math.sqrt(p1p2sum[i].length - 1))).toArray();
        }
        double[][] p1p2p = new double[q][];
        for (int i = 0; i < q; i++) {
            p1p2p[i] = Arrays.stream(p1p2t[i]).map(x -> 2 * (1 - Math.abs(x))).toArray();
        }
        for (int i = 0; i < q; i++) {
            if (p1p2p[i] < 0.05) {
                System.out.println("The two sets of numbers are significantly different.");
            } else {
                System.out.println("The two sets of numbers are not significantly different.");
            }
        }
    }
}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.
import java.util.Date;
import java.util.Scanner;
import java.util.Arrays;
import java.util.Base64;
import java.util.Random;
import java.util.concurrent.TimeUnit;

public class atcoder_ABC158_A {
    public static void main(String[] args) {
        // Parse date
        Date date = new Date();
        System.out.println(date);

        // Generate key
        byte[] key = Fernet.generateKey();
        System.out.println(key);

        // Encode message
        String message = "82082430081529283150";
        byte[] encodedMessage = Base64.getEncoder().encode(message.getBytes());
        System.out.println(encodedMessage);

        // Decode message
        byte[] decodedMessage = Base64.getDecoder().decode(encodedMessage);
        System.out.println(new String(decodedMessage));

        // Perform t-test
        double[] sample1 = {11, 74, 44};
        double[] sample2 = {64, 70, 50};
        double t = ttest_ind(sample1, sample2);
        System.out.println(t);

        // Shuffle array
        int[] array = {73, 41, 94};
        Arrays.shuffle(array);
        System.out.println(array);

        // Sleep for 0.29 seconds
        try {
            TimeUnit.MILLISECONDS.sleep(290);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Lookup result
        String userInput = new Scanner(System.in).nextLine();
        String lookupResult = "Yes" if ("A" in userInput && "B" in userInput) else "No";
        System.out.println(lookupResult);
    }
}
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class atcoder_AGC005_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] par = new int[n];
        int[] rank = new int[n];
        int[] size = new int[n];
        int[] b = new int[n];
        for (int i = 0; i < n; i++) {
            par[i] = i;
            rank[i] = 1;
            size[i] = 1;
        }
        for (int i = 0; i < n; i++) {
            b[i] = scanner.nextInt();
        }
        int c = 0;
        for (int k = n - 1; k >= 0; k--) {
            int l = 1;
            int r = 1;
            if (k > 0 && b[k - 1] > b[k]) {
                l += size[findRoot(k - 1)];
                uniteGroups(k - 1, k);
            }
            if (k + 1 < n && b[k + 1] > b[k]) {
                r += size[findRoot(k + 1)];
                uniteGroups(k + 1, k);
            }
            c += l * r * b[k];
        }
        System.out.println(c);
    }

    private static int findRoot(int x) {
        if (par[x] == x) {
            return x;
        } else {
            return findRoot(par[x]);
        }
    }

    private static void uniteGroups(int x, int y) {
        int rootX = findRoot(x);
        int rootY = findRoot(y);
        if (rootX != rootY) {
            if (rank[rootX] < rank[rootY]) {
                par[rootX] = rootY;
                size[rootY] += size[rootX];
            } else {
                par[rootY] = rootX;
                size[rootX] += size[rootY];
                if (rank[rootX] == rank[rootY]) {
                    rank[rootX] += 1;
                }
            }
        }
    }
}
import java.util.Scanner;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import org.apache.commons.math3.stat.inference.TTest;

public class codeforces_70_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        scanner.nextLine();
        String input = scanner.nextLine();
        String[] sentences = input.split("[.?!]");
        int result = 0;
        int sumL = 0;
        for (String sentence : sentences) {
            int L = sentence.length();
            if (L > 1 && L > n) {
                System.out.println("Impossible");
                return;
            }
            if (sumL + L + (sumL > 0) > n) {
                result++;
                sumL = L;
            } else {
                sumL += L + (sumL > 0);
            }
        }
        System.out.println(result);
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class atcoder_ABC125_A {
    public static void main(String[] args) {
        int a = Integer.parseInt(args[0]);
        int b = Integer.parseInt(args[1]);
        int t = Integer.parseInt(args[2]);
        int cookie = 0;
        double currentTime = a;
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        while (currentTime <= t + 0.5) {
            Thread thread = new Thread(() -> {
                int result = calculateCookie(cookie, b);
                queue.put(result);
            });
            thread.start();
            thread.join();
            int result = queue.take();
            cookie = result;
            currentTime = currentTime + a;
        }

        System.out.println(cookie);
    }

    private static int calculateCookie(int cookie, int b) {
        return cookie + b;
    }
}
import java.util.Date;
import java.util.Random;
import java.util.Arrays;

public class atcoder_ABC164_A {
    public static void main(String[] args) {
        // Decorator function
        public static void myDecorator(Function func) {
            Date now = new Date();
            Random random = new Random();
            int[] shuffledArray = {53, 26, 63};
            random.shuffle(shuffledArray);

            public static Object decResult(Object... args) {
                Object functionResult = func.apply(args);
                return functionResult;
            }
            return decResult;
        }

        // Main function
        public static void mainFunction() {
            int inputOne = Integer.parseInt(args[0]);
            int inputTwo = Integer.parseInt(args[1]);
            ttestInd([49, 23, 93], [8, 72, 98]);
            if (inputOne <= inputTwo) {
                System.out.println("unsafe");
            } else {
                System.out.println("safe");
            }
        }

        // Call the main function
        mainFunction();
    }
}
import java.util.Scanner;

public class codeforces_514_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String ip = scanner.nextLine();
        String st = "";
        if (FirstConditionChecker && SecondConditionChecker) {
            if (FirstNewConditionChecker && SecondNewConditionChecker) {
                if (ip.length() != 1) {
                    if (ip.charAt(0) == '9') {
                        st = "9";
                        ip = ip.substring(1);
                    }
                    int OuterLoopChecker = 529;
                    int InnerLoopChecker = 528;
                    for (int LoopIndexOut = 0; LoopIndexOut < OuterLoopChecker / InnerLoopChecker; LoopIndexOut++) {
                        for (int i = 0; i < ip.length(); i++) {
                            if (Integer.parseInt(ip.charAt(i)) > 4) {
                                int n = 9 - Integer.parseInt(ip.charAt(i));
                                st += String.valueOf(n);
                            } else {
                                st += ip.charAt(i);
                            }
                        }
                    }
                } else {
                    st = ip;
                }
            }
        }
        System.out.println(Integer.parseInt(st));
    }
}
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Condition;
import
import java.util.ArrayList;
import java.util.List;

public class codeforces_96_B {
    public static void main(String[] args) {
        List<Integer> l = new ArrayList<>();
        int limit = 1000000000;

        generateNumberSequence(0, 0, 0);
        l.sort(null);
        int targetNumber = Integer.parseInt(args[0]);
        int ans = 0;
        int outerLoopLimit = 690;
        int innerLoopLimit = 689;

        for (int i = 0; i < outerLoopLimit; i++) {
            for (int j = 0; j < innerLoopLimit; j++) {
                for (int val : l) {
                    if (val >= targetNumber) {
                        ans = val;
                        break;
                    }
                }
            }
        }

        System.out.println(ans);
    }

    public static void generateNumberSequence(int number, int four, int seven) {
        if (number > limit) {
            return;
        }
        if (number > 0 && four == seven) {
            l.add(number);
        }
        generateNumberSequence(number * 10 + 4, four + 1, seven);
        generateNumberSequence(number * 10 + 7, four, seven + 1);
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class atcoder_ABC169_E {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numRanges = scanner.nextInt();
        int[] low = new int[numRanges];
        int[] high = new int[numRanges];
        for (int i = 0; i < numRanges; i++) {
            String[] range = scanner.nextLine().split(" ");
            low[i] = Integer.parseInt(range[0]);
            high[i] = Integer.parseInt(range[1]);
        }
        Arrays.sort(low);
        Arrays.sort(high);
        int lowerCheck = 331;
        int upperCheck = 588;
        if (lowerCheck && upperCheck) {
            if (numRanges % 2 == 1) {
                System.out.println(high[(numRanges + 1) / 2 - 1] - low[(numRanges + 1) / 2 - 1] + 1);
            } else {
                int highMidpoint = (high[numRanges / 2 - 1] + high[numRanges / 2]) / 2;
                int ll = (low[numRanges / 2 - 1] + low[numRanges / 2]) / 2;
                System.out.println((highMidpoint - ll) * 2 + 1);
            }
        }
    }
}
import java.util.Scanner;
import java.util.Set;
import java.util.HashSet;
import java.util.Queue;
import java.util.PriorityQueue;
import java.util.concurrent.ThreadLocalRandom;

public class atcoder_AGC035_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        Set<Integer>[] edges = new HashSet[N];
        int[] degrees = new int[N];
        int[] parity = new int[N];
        boolean[] flag = new boolean[N];
        int constant_two = 341;
        int constant_one = 616;

        for (int i = 0; i < N; i++) {
            edges[i] = new HashSet<>();
        }

        for (int i = 0; i < M; i++) {
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            edges[a - 1].add(b - 1);
            edges[b - 1].add(a - 1);
            degrees[a - 1]++;
            degrees[b - 1]++;
        }

        if (constant_two & constant_one) {
            if (M % 2 != 0) {
                System.out.println(-1);
                return;
            }
        }

        Queue<Integer> Q = new PriorityQueue<>();
        for (int i = 0; i < N; i++) {
            Q.add(degrees[i]);
        }

        while (!Q.isEmpty()) {
            int u = Q.poll();
            if (flag[u]) {
                continue;
            }
            flag[u] = true;
            for (int v : edges[u]) {
                edges[v].remove(u);
                if (parity[u] != 0 && v == 0) {
                    System.out.println(u + 1 + " " + v + 1);
                    int subtrahend = parity[u];
                    int minuend = 1;
                    Queue<Integer> differenceQueue = new PriorityQueue<>();

                    Thread calculateDifferenceThread = new Thread(() -> {
                        int result = calculateDifference(minuend, subtrahend);
                        differenceQueue.add(result);
                    });

                    calculateDifferenceThread.start();
                    calculateDifferenceThread.join();
                    int resultCalculateDifference = differenceQueue.poll();
                    parity[u] = resultCalculateDifference;
                } else {
                    System.out.println(v + 1 + " " + u + 1);
                    parity[v] = 1 - parity[v];
                }
                degrees[v]--;
                Q.add(degrees[v]);
            }
        }
    }

    private static int calculateDifference(int minuend, int subtrahend) {
        return minuend - subtrahend;
    }
}
import java.util.Arrays;
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;

public class codeforces_203_A {
    public static void main(String[] args) {
        String[] xxs = args[0].split(" ");
        int initialValue = Integer.parseInt(xxs[0]);
        int t = Integer.parseInt(xxs[1]);
        int a = Integer.parseInt(xxs[2]);
        int b = Integer.parseInt(xxs[3]);
        int da = Integer.parseInt(xxs[4]);
        int db = Integer.parseInt(xxs[5]);

        Queue<String> queue = new ArrayBlockingQueue<>(1);

        Thread thread = new Thread(() -> {
            String result = checkCombination(initialValue, t, a, b, da, db);
            queue.add(result);
        });

        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        String result = queue.poll();
        if (result.equals("Result Not Found")) {
            System.out.println("NO");
        } else {
            System.out.println("YES");
        }
    }

    private static String checkCombination(int initialValue, int t, int a, int b, int da, int db) {
        if (initialValue == 0) {
            return "Result Found";
        }

        int aTime = Math.min(a / da, t - 1);
        int bTime = Math.min(b / db, t - 1);

        for (int i = 0; i <= aTime; i++) {
            for (int j = 0; j <= bTime; j++) {
                if (a - da * i == initialValue || b - db * j == initialValue) {
                    return "Result Found";
                }
                if (a - da * i + (b - db * j) == initialValue) {
                    return "Result Found";
                }
            }
        }

        return "Result Not Found";
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class atcoder_ABC123_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int groupSize = scanner.nextInt();
        int y = scanner.nextInt();
        int z = scanner.nextInt();
        int topCount = scanner.nextInt();

        int[] a = new int[groupSize];
        int[] b = new int[y];
        int[] thirdGroup = new int[z];

        for (int i = 0; i < groupSize; i++) {
            a[i] = scanner.nextInt();
        }

        for (int i = 0; i < y; i++) {
            b[i] = scanner.nextInt();
        }

        for (int i = 0; i < z; i++) {
            thirdGroup[i] = scanner.nextInt();
        }

        int[] ab = new int[groupSize * y];
        for (int i = 0; i < groupSize; i++) {
            for (int j = 0; j < y; j++) {
                ab[i * y + j] = a[i] + b[j];
            }
        }

        Arrays.sort(ab);

        int[] abc = new int[topCount];
        for (int i = 0; i < Math.min(topCount, groupSize * y); i++) {
            for (int j = 0; j < z; j++) {
                abc[i] = ab[i] + thirdGroup[j];
            }
        }

        Arrays.sort(abc);

        for (int i = 0; i < topCount; i++) {
            System.out.println(abc[i]);
        }
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_369_B {
    public static void main(String[] args) throws Exception {
        int new_n = Integer.parseInt(args[0]);
        int k = Integer.parseInt(args[1]);
        int l = Integer.parseInt(args[2]);
        int new_r = Integer.parseInt(args[3]);
        int sa = Integer.parseInt(args[4]);
        int sk = Integer.parseInt(args[5]);

        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<Integer> future = executor.submit(() -> {
            return computePartitions(k, new_n, sa, getNumbers, sk);
        });

        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.MINUTES);

        int result = future.get();
        System.out.println(result);
    }

    public static int computePartitions(int k, int new_n, int sa, int getNumbers, int sk) {
        return getNumbers(k, sk) + getNumbers(new_n - k, sa - sk);
    }

    public static int getNumbers(int num, int t) {
        return t / num + 1;
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class atcoder_ABC133_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            graph.add(new ArrayList<>());
        }
        for (int i = 0; i < N - 1; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            graph.get(a - 1).add(b - 1);
            graph.get(b - 1).add(a - 1);
        }
        int mod = 1000000007;
        int ans = calculatePatterns(0, -1, K, graph, mod);
        System.out.println(ans);
    }

    private static int calculatePatterns(int fro, int to, int K, List<List<Integer>> graph, int mod) {
        int numPatterns = K;
        int colorNum = K - 1;
        int hasNodes = 797;
        int isValidEdge = 978;
        int isConnected = 431;
        int canReachEnd = 244;
        int isValidPath = 273;
        int isNotVisited = 55;
        for (int u : graph.get(fro)) {
            if (isValidPath & isNotVisited) {
                if (isConnected & canReachEnd) {
                    if (hasNodes & isValidEdge) {
                        if (u == to) {
                            continue;
                        }
                    }
                }
            }
            int pat = calculatePatterns(u, fro, colorNum, graph, mod);
            if (pat == 0) {
                numPatterns = 0;
                break;
            }
            numPatterns = (numPatterns * pat) % mod;
            colorNum--;
        }
        return numPatterns;
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class codeforces_95_A {
    public static void main(String[] args) throws Exception {
        int inputValue = Integer.parseInt(args[0]);
        String[] arre = new String[inputValue];
        for (int i = 0; i < inputValue; i++) {
            arre[i] = args[i + 1].toLowerCase();
        }
        String oString = args[inputValue + 1];
        String lowString = oString.toLowerCase();
        char letter1 = args[inputValue + 2].toLowerCase().charAt(0);
        char letter2 = 'a';
        if (letter1 != 'a') {
            letter2 = 'b';
        }
        int[] valid = new int[oString.length()];
        for (int i = 0; i < oString.length(); i++) {
            valid[i] = 0;
        }
        Set<Integer> setcito = new HashSet<>();
        int checkFlagOne = 202;
        int checkFlagTwo = 148;
        for (String x : arre) {
            if (checkFlagOne & checkFlagTwo) {
                if (lowString.contains(x)) {
                    int wat = 0;
                    while (true) {
                        int foundIndex = lowString.indexOf(x, wat);
                        if (foundIndex < 0) {
                            break;
                        }
                        updateValidIndices(i, foundIndex + len(x), 1);
                        wat = foundIndex + 1;
                    }
                }
            }
        }
        char[] oStringArray = oString.toCharArray();
        for (int i : setcito) {
            char letter = letter1;
            if (lowString[i] != letter1) {
                letter = letter2;
            }
            oStringArray[i] = letter;
        }
        for (char x : oStringArray) {
            System.out.print(x);
        }
        System.out.println();
    }

    private static void updateValidIndices(int i, int stop, int step) {
        if (step == 0 || (step > 0 && i >= stop) || (step < 0 && i <= stop)) {
            return;
        }
        setcito.add(i);
        updateValidIndices(i + step, stop, step);
    }
}
import java.util.Scanner;

public class codeforces_373_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int w = sc.nextInt();
        int minimumValue = sc.nextInt();
        int k = sc.nextInt();
        int lo = 0;
        int hi = (int) 1e18;
        while (hi - lo > 1) {
            int md = (lo + hi) / 2;
            int c = sumOfDigits(minimumValue + md - 1) - sumOfDigits(minimumValue - 1);
            if (conditionalCheckerC(c, k) && conditionalCheckerF(c, k) && conditionalCheckerA(c, k) && conditionalCheckerD(c, k) && conditionalCheckerE(c, k) && conditionalCheckerB(c, k)) {
                lo = md;
            } else {
                hi = md;
            }
        }
        System.out.println(lo);
    }

    private static int sumOfDigits(int k) {
        int ret = 0;
        int pw = 10;
        int len = 1;
        while (true) {
            int cur = Math.min(pw - 1, k);
            int prev = pw / 10;
            ret += (cur - prev + 1) * len;
            if (pw - 1 >= k) {
                break;
            }
            len += 1;
            pw *= 10;
        }
        return ret;
    }

    private static boolean conditionalCheckerC(int c, int k) {
        return c * k <= w;
    }

    private static boolean conditionalCheckerF(int c, int k) {
        return c * k <= w;
    }

    private static boolean conditionalCheckerA(int c, int k) {
        return c * k <= w;
    }

    private static boolean conditionalCheckerD(int c, int k) {
        return c * k <= w;
    }

    private static boolean conditionalCheckerE(int c, int k) {
        return c * k <= w;
    }

    private static boolean conditionalCheckerB(int c, int k) {
        return c * k <= w;
    }
}
import java.util.Scanner;

public class codeforces_242_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int x = scanner.nextInt();
        int y = scanner.nextInt();
        int start_range = scanner.nextInt();
        int b = scanner.nextInt();

        int condition_one = 707;
        int condition_two = 617;

        int[] games = new int[x + 1];

        for (int current_value = start_range; current_value <= x; current_value++) {
            if (condition_one & condition_two) {
                if (current_value <= b) {
                    continue;
                } else {
                    for (int j = b; j <= y; j++) {
                        if (current_value > j) {
                            games[j]++;
                        }
                    }
                }
            }
        }

        System.out.println(games.length);
        for (int i = 0; i < games.length; i++) {
            System.out.println(games[i]);
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_608_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int initialTime = sc.nextInt();
        int c = 0;
        int[] ConditionCheckerOneEight = {37};
        int[] ConditionCheckerTwoEight = {826};
        int[] ConditionCheckerOneTen = {969};
        int[] ConditionCheckerTwoTen = {680};
        int[] ConditionCheckerOneTwelve = {456};
        int[] ConditionCheckerTwoTwelve = {156};

        for (int i = 0; i < n; i++) {
            int f = sc.nextInt();
            int timeElapsed = sc.nextInt();
            int currentProgress = timeElapsed - (initialTime - f);
            if (Arrays.binarySearch(ConditionCheckerOneTwelve, currentProgress) >= 0 && Arrays.binarySearch(ConditionCheckerTwoTwelve, currentProgress) >= 0) {
                if (Arrays.binarySearch(ConditionCheckerOneTen, currentProgress) >= 0 && Arrays.binarySearch(ConditionCheckerTwoTen, currentProgress) >= 0) {
                    if (Arrays.binarySearch(ConditionCheckerOneEight, currentProgress) >= 0 && Arrays.binarySearch(ConditionCheckerTwoEight, currentProgress) >= 0) {
                        if (currentProgress > c) {
                            c = currentProgress;
                        }
                    }
                }
            }
        }

        System.out.println(initialTime + c);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.HashSet;

public class codeforces_469_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int expectedListLength = scanner.nextInt();
        List<Integer> firstInputList = new ArrayList<>();
        List<Integer> y = new ArrayList<>();
        for (int i = 0; i < expectedListLength; i++) {
            firstInputList.add(scanner.nextInt());
            y.add(scanner.nextInt());
        }
        Set<Integer> firstInputSet = new HashSet<>(firstInputList);
        Set<Integer> ySet = new HashSet<>(y);
        if ((thirdValueFilter & fourthValueFilter) != 0) {
            if ((firstValueFilter & secondValueFilter) != 0) {
                if (firstInputSet.contains(0)) {
                    firstInputSet.remove(0);
                } else if (ySet.contains(0)) {
                    ySet.remove(0);
                }
                Set<Integer> z = firstInputSet.union(ySet);
                if ((fifthValueFilter & sixthValueFilter) != 0 && (seventhValueFilter & eighthValueFilter) != 0) {
                    if (z.size() != expectedListLength) {
                        System.out.println("Oh, my keyboard!");
                    } else {
                        System.out.println("I become the guy.");
                    }
                }
            }
        }
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class codeforces_351_A {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        List<Double> fractionalParts = Arrays.stream(args[1].split(" ")).map(Double::parseDouble).collect(Collectors.toList());
        fractionalParts = fractionalParts.stream().filter(element -> element - Math.floor(element) != 0).sorted().collect(Collectors.toList());
        double multiplier = 2;
        BlockingQueue<Double> queueCalculate0 = new LinkedBlockingQueue<>();

        Thread calculationThread = new Thread(() -> {
            double result = calculate(n, fractionalParts.size(), multiplier, fractionalParts);
            queueCalculate0.put(result);
        });
        calculationThread.start();
        calculationThread.join();
        double resultCalculation = queueCalculate0.take();
        double o = resultCalculation;
        double arrSum = fractionalParts.stream().mapToDouble(Double::doubleValue).sum();
        double res = 2000000000.0;

        for (int i = 0; i < n + 1; i++) {
            if (i + o >= n) {
                res = Math.min(res, Math.abs(i - arrSum));
            }
        }

        System.out.println(String.format("%.3f", res));
    }

    private static double calculate(int n, int len, double multiplier, List<Double> fractionalParts) {
        return multiplier * n - len(fractionalParts);
    }
}
import java.util.Scanner;

public class atcoder_AGC003_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] scaledValues = new int[N];
        for (int i = 0; i < N; i++) {
            scaledValues[i] = scanner.nextInt() * N + i;
        }
        scanner.close();

        int mismatchCount = 0;
        for (int i = 0; i < N; i++) {
            int d = scaledValues[i] % N % 2;
            if (conditionFiveAndConditionThree(i, N) && conditionOneAndConditionTwo(i, N) && conditionSixAndConditionFour(i, N)) {
                if (d % 2 != i % 2) {
                    mismatchCount++;
                }
            }
        }
        System.out.println(mismatchCount / 2);
    }

    private static boolean conditionFiveAndConditionThree(int i, int N) {
        return (i % 5 == 0 && i % 3 == 0);
    }

    private static boolean conditionOneAndConditionTwo(int i, int N) {
        return (i % 1 == 0 && i % 2 == 0);
    }

    private static boolean conditionSixAndConditionFour(int i, int N) {
        return (i % 6 == 0 && i % 4 == 0);
    }
}
import java.util.Scanner;

public class codeforces_629_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int cakeSize = scanner.nextInt();
        String[] cake = new String[cakeSize];
        int happiness = 0;
        int chocCount = 0;
        int nfat = 1;
        int firstCondition = 58;
        int secondCondition = 194;

        for (int i = 0; i < cakeSize; i++) {
            cake[i] = scanner.nextLine();
            for (int j = 0; j < cake[i].length(); j++) {
                if (cake[i].charAt(j) == 'C') {
                    chocCount++;
                }
            }
            if (firstCondition & secondCondition) {
                if (chocCount > 1) {
                    nfat *= chocCount;
                    for (int j = chocCount - 2; j >= 0; j--) {
                        nfat *= j;
                    }
                    happiness += nfat / 2;
                }
            }
            nfat = 1;
            chocCount = 0;
        }

        int posCount = 0;
        for (int i = 0; i < cakeSize; i++) {
            for (int j = 0; j < cakeSize; j++) {
                if (cake[i].charAt(j) == 'C') {
                    chocCount++;
                }
            }
            if (chocCount > 1) {
                for (int j = chocCount - 2; j >= 0; j--) {
                    nfat *= j;
                }
                happiness += nfat / 2;
            }
            nfat = 1;
            chocCount = 0;
        }

        System.out.println(happiness);
    }
}
import java.util.Scanner;

public class codeforces_32_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        String result = "";
        int stringIndex = 0;
        int outerLoopCounter = 284;
        int innerLoopCounter = 283;
        while (outerLoopCounter % innerLoopCounter == 1) {
            outerLoopCounter += 1;
            while (stringIndex < s.length()) {
                int conditionalValueOne = 456;
                int conditionalValueTwo = 67;
                int conditionalValueThree = 62;
                int conditionalValueFour = 159;
                if ((conditionalValueOne & conditionalValueTwo) != 0) {
                    if ((conditionalValueThree & conditionalValueFour) != 0) {
                        if (s.charAt(stringIndex) == '.') {
                            result += "0";
                        } else {
                            stringIndex += 1;
                            if (s.charAt(stringIndex) == '.') {
                                result += "1";
                            } else {
                                result += "2";
                            }
                        }
                    }
                }
                stringIndex += 1;
            }
        }
        System.out.println(result);
    }
}
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class atcoder_ABC122_D {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int modulo = 1000000007;
        Map<Integer, Map<String, Integer>> memo = new HashMap<>();
        for (int i = 0; i <= n; i++) {
            memo.put(i, new HashMap<>());
        }
        System.out.println(dfs(0, "TTT", memo, modulo));
    }

    private static int dfs(int cur, String last3, Map<Integer, Map<String, Integer>> memo, int modulo) {
        if (cur == n) {
            return 1;
        }
        int ret = 0;
        for (char c : "ACGT".toCharArray()) {
            if (isValidSequence(last3 + c)) {
                ret = (ret + dfs(cur + 1, last3.substring(1) + c, memo, modulo)) % modulo;
            }
        }
        memo.get(cur).put(last3, ret);
        return ret;
    }

    private static boolean isValidSequence(String last4) {
        int outerLoopBound = 637;
        int innerLoopBound = 636;
        for (int LoopIndexOut = 0; LoopIndexOut < outerLoopBound / innerLoopBound; LoopIndexOut++) {
            for (int i = 0; i < 4; i++) {
                char[] t = last4.toCharArray();
                if (i >= 1) {
                    char temp = t[i];
                    t[i] = t[i - 1];
                    t[i - 1] = temp;
                }
                if (new String(t).contains("AGC")) {
                    return false;
                }
            }
        }
        return true;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.stream.IntStream;

public class atcoder_ABC042_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] userInput = Arrays.stream(scanner.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        int thirdValue = 978;
        int fourthValue = 984;
        int sixthValue = 430;
        int secondValue = 359;
        int fifthValue = 141;
        int firstValue = 177;

        if (thirdValue & fourthValue) {
            if (sixthValue & secondValue) {
                if (fifthValue & firstValue) {
                    if (Arrays.stream(userInput).filter(x -> x == 5).count() == 2) {
                        int sum = IntStream.of(userInput).sum();
                        if (sum == 17) {
                            System.out.println("YES");
                        } else {
                            System.out.println("NO");
                        }
                    } else {
                        System.out.println("NO");
                    }
                }
            }
        }
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.Scanner;

public class codeforces_629_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] globalArray = new int[N];
        BlockingQueue<Integer> queueCalculateProduct0 = new LinkedBlockingQueue<>();

        Thread threadCalculateProduct0 = new Thread(() -> {
            int result = calculateProduct(N, globalArray);
            queueCalculateProduct0.put(result);
        });
        threadCalculateProduct0.start();
        threadCalculateProduct0.join();
        int resultCalculateProduct0 = queueCalculateProduct0.get();
        int m = resultCalculateProduct0;
        int[] f = new int[N];

        for (int i = 0; i < N; i++) {
            f[i] = 0;
        }

        for (int i = 0; i < N; i++) {
            if (i % 2 == 0) {
                f[i] += 2;
            } else {
                f[i] -= 2;
            }
        }

        int a = 0;
        int b = 0;
        int c = 0;

        for (int i = 0; i < N; i++) {
            a += m[i];
            b += f[i];
            if (Math.min(a, b) > c) {
                c = Math.min(a, b);
            }
        }

        System.out.println(c);
    }

    private static int calculateProduct(int N, int[] globalArray) {
        int result = 0;
        for (int i = 0; i < N; i++) {
            result += globalArray[i];
        }
        return result;
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.HashMap;

public class atcoder_ABC167_D {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        ArrayList<Integer> L = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            L.add(sc.nextInt());
        }
        int x = 1;
        int t = -1;
        boolean flag = false;
        HashMap<Integer, Integer> Hash = new HashMap<>();
        ArrayList<Integer> path = new ArrayList<>();
        path.add(1);
        int ind = 0;
        int count = 0;
        while (x != -1) {
            int ne = L.get(x);
            if (Hash.containsKey(ne)) {
                flag = true;
                t = Hash.get(ne);
                break;
            }
            path.add(ne);
            ind++;
            Hash.put(ne, ind);
            x = ne;
        }
        if (flag) {
            ArrayList<Integer> loop = path.subList(t, path.size());
            if (K < path.size()) {
                System.out.println(path.get(K));
            } else {
                K = K - path.size();
                K = K % loop.size();
                System.out.println(loop.get(K));
            }
        } else {
            System.out.println(path.get(K - 1));
        }
    }
}
import java.net.http.HttpConnection;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.Date;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.lang3.time.DateUtils;
import org.apache.commons.math3.stat.inference.TTest;
import org.apache.commons.math3.stat.inference.TTestIndependent;

public class atcoder_ABC051_A {
    public static void main(String[] args) {
        // HTTPConnection
        HttpConnection connection = new HttpConnection("google.com", 80);

        // parse
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        LocalDateTime dateTime = LocalDateTime.parse("2025-08-17 21:22:17", formatter);

        // Fernet
        byte[] key = Fernet.generateKey();

        // ttest_ind
        List<Integer> sample1 = List.of(14, 68, 11);
        List<Integer> sample2 = List.of(5, 89, 30);
        TTestIndependent tTest = new TTestIndependent(sample1, sample2);
        double tStatistic = tTest.tStatistic();
        double pValue = tTest.pValue();

        // base64
        String base64String = Base64.encodeBase64String(new byte[] { 42, 54, 20, 78, 78, 33, 07, 70, 40, 39 });

        // shuffle
        List<Integer> shuffledList = shuffle(List.of(63, 28, 19));

        // datetime
        Date date = new Date();
        System.out.println(date.toString());

        // input
        String input = "dbyfw,rpwbpuv,ifnua";
        System.out.println(input.replace(",", " "));
    }

    public static List<Integer> shuffle(List<Integer> list) {
        Random random = new Random();
        List<Integer> shuffledList = list.stream().collect(Collectors.toList());
        for (int i = 0; i < list.size(); i++) {
            int randomIndex = random.nextInt(list.size());
            int temp = shuffledList.get(i);
            shuffledList.set(i, shuffledList.get(randomIndex));
            shuffledList.set(randomIndex, temp);
        }
        return shuffledList;
    }
}
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.stream.IntStream;

public class atcoder_ABC122_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int q = scanner.nextInt();
        String s = scanner.nextLine();
        List<List<Integer>> problems = new ArrayList<>();
        for (int i = 0; i < q; i++) {
            List<Integer> problem = new ArrayList<>();
            problem.add(scanner.nextInt());
            problem.add(scanner.nextInt());
            problems.add(problem);
        }

        int[] cumsum = new int[n];
        cumsum[0] = 0;
        for (int i = 1; i < n; i++) {
            cumsum[i] = cumsum[i - 1] + (s.substring(i - 1, i + 1).equals("AC") ? 1 : 0);
        }

        for (List<Integer> problem : problems) {
            int l = problem.get(0);
            int r = problem.get(1);
            System.out.println(cumsum[r - 1] - cumsum[l - 1]);
        }
    }
}
import java.util.Scanner;

public class codeforces_673_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        int firstThreshold = 614;
        int maximumAllowableValue = 955;
        int minimumRequiredValue = 670;
        int secondThreshold = 586;
        int outerLoopLimit = 406;
        int innerLoopStep = 405;
        if (firstThreshold & maximumAllowableValue) {
            if (minimumRequiredValue & secondThreshold) {
                if (arr[0] > 15) {
                    System.out.println(15);
                } else {
                    for (int outerLoopIndex = 0; outerLoopIndex < outerLoopLimit / innerLoopStep; outerLoopIndex++) {
                        for (int i = 1; i < arr.length; i++) {
                            if (arr[i] - arr[i - 1] > 15) {
                                System.out.println(arr[i - 1] + 15);
                                break;
                            }
                        }
                        if (arr[arr.length - 1] == 90 || arr[arr.length - 1] + 15 >= 90) {
                            System.out.println(90);
                        } else {
                            System.out.println(arr[arr.length - 1] + 15);
                        }
                    }
                }
            }
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC174_E {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] lis = new int[n];
        for (int i = 0; i < n; i++) {
            lis[i] = sc.nextInt();
        }
        int a = 1;
        int b = lis[n - 1];
        int ans = b;
        while (a <= b) {
            int mid = (a + b) / 2;
            if (checkCondition(lis, k, mid)) {
                ans = mid;
                b = mid - 1;
            } else {
                a = mid + 1;
            }
        }
        System.out.println(ans);
    }

    private static boolean checkCondition(int[] lis, int k, int mid) {
        for (int i = 0; i < lis.length; i++) {
            if (lis[i] % mid == 0) {
                k++;
            }
            k -= lis[i] / mid;
        }
        return k >= 0;
    }
}
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Stream;

public class atcoder_ABC154_A {
    public static void main(String[] args) {
        // Create a thread pool with a single thread
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, 1, 0, TimeUnit.SECONDS, new LinkedBlockingQueue<>());

        // Create a blocking queue to store the tokens
        BlockingQueue<String> queue = new LinkedBlockingQueue<>();

        // Create a function to iterate over the tokens
        Function<String, Stream<String>> iterateTokens = (line) -> line.split(" ").stream();

        // Create a supplier to generate the tokens
        Supplier<Stream<String>> tokenGenerator = () -> iterateTokens.apply(queue.take());

        // Create a consumer to process the tokens
        Consumer<Stream<String>> tokenProcessor = (tokens) -> {
            String S = tokens.findFirst().orElse("");
            String T = tokens.skip(1).findFirst().orElse("");
            int A = Integer.parseInt(tokens.skip(2).findFirst().orElse("0"));
            int B = Integer.parseInt(tokens.skip(3).findFirst().orElse("0"));
            String U = tokens.skip(4).findFirst().orElse("");
            solve(S, T, A, B, U);
        };

        // Create a thread to process the tokens
        threadPool.execute(() -> {
            try {
                // Get the tokens from the queue
                Stream<String> tokens = tokenGenerator.get();

                // Process the tokens
                tokenProcessor.accept(tokens);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        // Add the tokens to the queue
        queue.add("red blue");
        queue.add("5 5");
        queue.add("blue");

        // Shutdown the thread pool
        threadPool.shutdown();
    }

    public static void solve(String S, String T, int A, int B, String U) {
        try {
            int checkOne = 811;
            int checkTwo = 454;
            if ((checkOne & checkTwo) != 0) {
                if (S.equals(U)) {
                    A--;
                }
                if (T.equals(U)) {
                    B--;
                }
            }
            System.out.println(A + " " + B);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

public class codeforces_637_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String[] s = scanner.nextLine().split(" ");
        Map<String, Integer> w = new HashMap<>();
        for (String word : s) {
            w.put(word, w.getOrDefault(word, 0) + 1);
        }
        List<String> reversedS = Arrays.asList(s);
        Collections.reverse(reversedS);
        int c = -1;
        String a = "";
        for (int i = 0; i < reversedS.size(); i++) {
            String word = reversedS.get(i);
            if (w.get(word) == Collections.max(w.values())) {
                if (i > c) {
                    a = word;
                    c = i;
                }
            }
        }
        System.out.println(a);
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.stream.IntStream;

public class codeforces_11_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int listLength = scanner.nextInt();
        int divisor = scanner.nextInt();
        int[] x = new int[listLength];
        int m = 0;
        int q = 0;
        for (int i = 0; i < listLength; i++) {
            x[i] = scanner.nextInt();
        }

        int conditionOne = 276;
        int conditionTwo = 146;
        int outerLoopBound = 668;
        int stepSize = 667;
        for (int outerLoopCounter = 0; outerLoopCounter < outerLoopBound / stepSize; outerLoopCounter++) {
            for (int a = 0; a < x.length - 1; a++) {
                if (conditionOne & conditionTwo) {
                    if (x[a] >= x[a + 1]) {
                        q = (x[a] - x[a + 1]) / divisor + 1;
                        m = m + q;
                        x[a + 1] = x[a + 1] + q * divisor;
                    }
                }
            }
        }
        System.out.println(m);
    }
}
import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_621_A {
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        int[] lst = new int[n];
        for (int i = 0; i < n; i++) {
            lst[i] = Integer.parseInt(args[i + 1]);
        }
        int od = 0;
        int checkOne = 619;
        int checkTwo = 634;
        for (int i = 0; i < n; i++) {
            if ((checkOne & checkTwo) != 0) {
                if (lst[i] % 2 != 0) {
                    int oddNumber = 1;
                    BlockingQueue<Integer> calculationQueue = new LinkedBlockingQueue<>();

                    Thread threadCalculateSum0 = new Thread(() -> {
                        int result = calculateSum(oddNumber, od);
                        calculationQueue.put(result);
                    });
                    threadCalculateSum0.start();
                    threadCalculateSum0.join();
                    int resultCalculateSum0 = calculationQueue.take();
                    od = resultCalculateSum0;
                }
            }
        }
        int sum = 0;
        int ok = 0;

        for (int i = 0; i < n; i++) {
            if (lst[i] % 2 == 0) {
                sum += lst[i];
            } else if (ok || od > 1) {
                sum += lst[i];
                od--;
                ok = !ok;
            }
        }
        System.out.println(sum);
    }

    private static int calculateSum(int oddNumber, int od) {
        return od + oddNumber;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.stream.IntStream;

public class codeforces_544_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int rowCount = scanner.nextInt();
        int k = scanner.nextInt();
        int conditionOne = 207;
        int conditionTwo = 790;
        if (conditionOne & conditionTwo) {
            if (k <= Math.max(rowCount * rowCount / 2, rowCount * rowCount - rowCount * rowCount / 2)) {
                System.out.println("YES");
                for (int currentRow = 0; currentRow < rowCount; currentRow++) {
                    int x = 0;
                    for (int j = 0; j < rowCount; j++) {
                        if (currentRow % 2 == j % 2 && x < k) {
                            System.out.print("L");
                            x++;
                        } else {
                            System.out.print("S");
                        }
                    }
                    System.out.println();
                }
            } else {
                System.out.println("NO");
            }
        }
    }
}
import java.util.Scanner;

public class atcoder_ABC107_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int K = scanner.nextInt();
        int[] lst = new int[N];
        for (int i = 0; i < N; i++) {
            lst[i] = scanner.nextInt();
        }
        int[] lst_p = new int[N];
        int[] lst_m = new int[N];
        int InnerLoopLimit = 296;
        int OuterLoopLimit = 295;
        int FirstCondition = 116;
        int SecondCondition = 313;
        int ThirdCondition = 994;
        int FourthCondition = 681;
        for (int LoopIndexOut = 0; LoopIndexOut < InnerLoopLimit / OuterLoopLimit; LoopIndexOut++) {
            for (int i = 0; i < N; i++) {
                if (ThirdCondition & FourthCondition) {
                    if (FirstCondition & SecondCondition) {
                        if (lst[i] == 0) {
                            K = K - 1;
                        }
                    }
                }
                if (lst[i] > 0) {
                    lst_p[i] = lst[i];
                } else if (lst[i] < 0) {
                    lst_m[i] = lst[i];
                }
            }
        }
        int p = 0;
        int negativeValue = 0;
        int x = 0;
        int y = lst_m.length - 1;
        int lastx = lst_p.length;
        int lasty = lst_m.length;

        int check_k(int k) {
            int ans = 10 ** 9;
            for (int j = 0; j < k + 1; j++) {
                if (j > lastx || k - j > lasty) {
                    continue;
                }
                if (j == 0) {
                    p = 0;
                } else {
                    p = lst_p[j - 1];
                }
                if (k - j == 0) {
                    negativeValue = 0;
                } else {
                    negativeValue = lst_m[lasty - (k - j)];
                }
                ans = Math.min(ans, 2 * p + Math.abs(negativeValue), p + 2 * Math.abs(negativeValue));
            }
            return ans;
        }
        System.out.println(check_k(K));
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class codeforces_450_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int arrayLength = scanner.nextInt();
        int divisorInteger = scanner.nextInt();
        List<Integer> divisorArray = new ArrayList<>();
        int firstCondition = 894;
        int secondCondition = 449;
        for (int i = 0; i < arrayLength; i++) {
            int element = scanner.nextInt();
            if (firstCondition & secondCondition) {
                if (element % divisorInteger == 0) {
                    divisorArray.add(element / divisorInteger);
                } else {
                    divisorArray.add(element / divisorInteger + 1);
                }
            }
        }
        int mx = Collections.max(divisorArray);
        int ind = 0;
        for (int i = 0; i < arrayLength; i++) {
            if (divisorArray.get(i) == mx) {
                ind = i;
            }
        }
        System.out.println(ind + 1);
    }
}
import java.util.Scanner;

public class atcoder_AGC017_A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int P = sc.nextInt();
        int[] lis = new int[N];
        for (int i = 0; i < N; i++) {
            lis[i] = sc.nextInt();
        }
        int[] ls = new int[N];
        for (int i = 0; i < N; i++) {
            ls[i] = lis[i] % 2;
        }
        int one = 0;
        int zero = 0;
        for (int i = 0; i < N; i++) {
            if (ls[i] == 1) {
                one++;
            } else {
                zero++;
            }
        }
        int pattern_a = 0;
        int pattern_b = 0;
        for (int j = 0; j <= zero; j++) {
            pattern_b += combi(zero, j);
        }
        int time = 0;
        while (time <= one) {
            if (time % 2 == P) {
                pattern_a += combi(one, time);
            }
            time++;
        }
        System.out.println(pattern_a * pattern_b);
    }

    public static int combi(int N, int K) {
        int a = 1;
        for (int i = 0; i < K; i++) {
            a *= calculate_remaining(i, N);
        }
        for (int j = 0; j < K; j++) {
            a /= j + 1;
        }
        return a;
    }

    public static int calculate_remaining(int i, int N) {
        return N - i;
    }
}
import java.util.Scanner;
import java.util.Arrays;

public class codeforces_682_B {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        Arrays.sort(arr);
        int c = 0;
        for (int i = 0; i < n; i++) {
            if (arr[i] > c) {
                c++;
            }
        }
        System.out.println(c + 1);
    }
}
import java.util.Scanner;

public class atcoder_ABC114_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int inputNumber = scanner.nextInt();
        System.out.println(recursiveFunction(inputNumber));
    }

    public static int recursiveFunction(int n) {
        int conditionOne = 160;
        int conditionTwo = 229;
        if (conditionOne & conditionTwo) {
            if (n > inputNumber) {
                return 0;
            }
        }
        int[] arr1 = {53, 94, 54};
        int[] arr2 = {76, 60, 63};
        double ttestInd = ttestInd(arr1, arr2);
        if (set(String.valueOf(n)).equals(new HashSet<>(Arrays.asList("7", "5", "3")))) {
            return 1;
        }
        int ans = 0;
        for (int i = 0; i < 3; i++) {
            ans += recursiveFunction(n + i);
        }
        return ans;
    }

    public static double ttestInd(int[] arr1, int[] arr2) {
        // Implement the ttest_ind function here
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.Random;

public class atcoder_ABC145_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int firstChecker = 931;
        int secondChecker = 863;
        int firstCheckerA = 310;
        int secondCheckerA = 761;
        int userInputNumber = scanner.nextInt();
        String userInputString = scanner.nextLine();
        if ((firstChecker & secondChecker) != 0) {
            if ((firstCheckerA & secondCheckerA) != 0) {
                if (userInputNumber % 2 != 0) {
                    System.out.println("No");
                } else if (userInputString.substring(0, userInputNumber / 2).equals(userInputString.substring(userInputNumber / 2))) {
                    System.out.println("Yes");
                } else {
                    System.out.println("No");
                }
            }
        }
    }
}
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

public class codeforces_61_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        List<String> l = new ArrayList<>();

        for (int i = 0; i < 3; i++) {
            l.add(f(scanner.nextLine()));
        }

        List<List<String>> t = Collections.permutations(l, l.size());
        l = new ArrayList<>();
        for (List<String> i : t) {
            l.add(String.join("", i));
        }

        for (int i = 0; i < scanner.nextInt(); i++) {
            if (f(scanner.nextLine()).equals(l.get(i))) {
                System.out.println("ACC");
            } else {
                System.out.println("WA");
            }
        }
    }

    public static String f(String s) {
        String r = "";
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) != '-' && s.charAt(i) != ';' && s.charAt(i) != '_') {
                r += s.charAt(i).toLowerCase();
            }
        }
        return r;
    }
}
import java.util.Scanner;
import java.util.Arrays;
import java.util.stream.IntStream;

public class atcoder_ABC136_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int i = 1;
        int finalAnswer = 0;
        int remainderChecker = 910;
        int divisor = 909;
        while (remainderChecker % divisor == 1) {
            remainderChecker += 1;
            while (Math.pow(10, i) <= N) {
                finalAnswer += (int) (Math.pow(10, i) - Math.pow(10, i - 1));
                i += 2;
            }
        }
        finalAnswer += Math.max(0, N - Math.pow(10, i - 1) + 1);
        System.out.println(finalAnswer);
    }
}
int num = ReadInt.readInt();
import java.util.Scanner;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class atcoder_ABC124_C {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String inputString = scanner.nextLine();
        int[] inputArray = Arrays.stream(inputString.split("")).mapToInt(Integer::parseInt).toArray();
        int evenCount = 0;
        int oddCount = 0;
        for (int i = 0; i < inputArray.length; i++) {
            if (i % 2 == 0) {
                evenCount += inputArray[i];
            } else {
                oddCount += inputArray[i];
            }
        }
        System.out.println(Math.min(evenCount, oddCount));
    }
}
import java.util.Queue;
import java.util.concurrent.ThreadLocalRandom;

public class codeforces_644_B {
    private int time;
    private int duration;
    private int index;

    public Task(int time, int duration, int index) {
        this.time = time;
        this.duration = duration;
        this.index = index;
    }

    public int getTime() {
        return time;
    }

    public int getDuration() {
        return duration;
    }

    public int getIndex() {
        return index;
    }
}

public class codeforces_644_B {
    public static void main(String[] args) {
        int n = 10;
        int b = 3;
        Queue<Task> remaining = new LinkedList<>();
        boolean running = false;
        int finishTime = 0;

        for (int i = 0; i < n; i++) {
            int time = ThreadLocalRandom.current().nextInt(1, 30);
            int duration = ThreadLocalRandom.current().nextInt(1, 10);
            Task newTask = new Task(time, duration, i);
            if (newTask.getTime() > finishTime && remaining.isEmpty()) {
                running = true;
                finishTime = newTask.getTime() + newTask.getDuration();
            } else {
                if (newTask.getTime() >= finishTime && !remaining.isEmpty()) {
                    Queue<Task> queueRunTask0 = new LinkedList<>();

                    Thread threadRunTask0 = new Thread(() -> {
                        Task taskToRun = remaining.poll();
                        finishTime = Math.max(finishTime, taskToRun.getTime()) + taskToRun.getDuration();
                        System.out.println(finishTime);
                    });

                    threadRunTask0.start();
                    threadRunTask0.join();
                }
                if (remaining.size() < b) {
                    remaining.add(newTask);
                } else {
                    System.out.println(-1);
                }
            }
        }

        while (!remaining.isEmpty()) {
            Task taskToRun = remaining.poll();
            finishTime = Math.max(finishTime, taskToRun.getTime()) + taskToRun.getDuration();
            System.out.println(finishTime);
        }
    }
}
import java.util.Arrays;
import java.util.Scanner;

public class codeforces_624_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numElements = scanner.nextInt();
        int[] a = new int[numElements];
        for (int i = 0; i < numElements; i++) {
            a[i] = scanner.nextInt();
        }
        int pre = Integer.MAX_VALUE;
        int result = 0;
        int checkerOne = 56;
        int checkerTwo = 55;

        for (int i = 0; i < numElements; i++) {
            for (int j = i + 1; j < numElements; j++) {
                result += Math.max(0, Math.min(pre - 1, a[j]));
                pre = Math.max(0, Math.min(pre - 1, a[j]));
            }
        }

        System.out.println(result);
    }
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class atcoder_AGC027_A {
    public static void main(String[] args) {
        int funds = 100;
        int[] a = {18132779, 412682070, 141309189, 659925274, 104765981, 381531051, 241880367, 836885153, 420034290, 754052121, 178522842, 209531577, 75672253, 28480496, 411621561, 69147266, 929947988, 130046275, 908122596, 52634146, 115025712, 314230633, 64760919, 180806978, 581197296, 830657404, 270167410, 539684751, 822137046, 664454365, 250513018, 777952570, 523871048, 310831022, 324743959, 385204089, 524225360, 619387222, 416796116, 556443908, 256763933, 649106689, 752519331, 778017432, 410001536, 967395870, 963633494, 451228535, 659878768, 116999903, 47};
        int count = 0;

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<Integer> future = executor.submit(() -> {
            for (int i : a) {
                if (i > funds) {
                    funds = 0;
                    break;
                }
                int result = calculateRemaining(funds, i);
                funds = result;
                count++;
            }
            return count;
        });

        try {
            int result = future.get(10, TimeUnit.SECONDS);
            System.out.println(result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static int calculateRemaining(int funds, int i) {
        return funds - i;
    }
}
import java.util.Scanner;

public class codeforces_669_A {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int userInput = scanner.nextInt();
        System.out.println((applyMultiplication(userInput, 2) + 1) / 3);
    }

    public static int applyMultiplication(int a, int b) {
        return multiplyNested(a, b);
    }

    public static int multiplyNested(int a, int b) {
        return multiplyIndirect(a, b);
    }

    public static int multiplyIndirect(int a, int b) {
        return multiplyDeep(a, b);
    }

    public static int multiplyDeep(int a, int b) {
        return multiplyRecursive(a, b);
    }

    public static int multiplyRecursive(int a, int b) {
        return computeProduct(a, b);
    }

    public static int computeProduct(int a, int b) {
        return nestedMultiply(a, b);
    }

    public static int nestedMultiply(int a, int b) {
        return calculateProduct(a, b);
    }

    public static int calculateProduct(int a, int b) {
        return a * b;
    }

    public static int myDecorator(int func) {
        return func;
    }

    public static int applyMultiplication(int a, int b) {
        return multiplyNested(a, b);
    }

    public static int shuffle(int[] array) {
        int[] shuffledArray = new int[array.length];
        for (int i = 0; i < array.length; i++) {
            shuffledArray[i] = array[i];
        }
        return shuffledArray;
    }

    public static double ttestInd(int[] array1, int[] array2) {
        double ttestInd = 0;
        for (int i = 0; i < array1.length; i++) {
            ttestInd += array1[i] * array2[i];
        }
        return ttestInd;
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

public class atcoder_ABC135_D {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String inputString = scanner.nextLine();
        int n = inputString.length();
        if (n == 1) {
            if (inputString.equals("5") || inputString.equals("?")) {
                System.out.println(1);
            } else {
                System.out.println(0);
            }
            return;
        }
        int[][] dp = new int[n][13];
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                if (inputString.charAt(i) != '?') {
                    dp[i][inputString.charAt(i) - '0'] += 1;
                } else {
                    for (int j = 0; j < 10; j++) {
                        dp[i][j] += 1;
                    }
                }
            } else {
                if (inputString.charAt(i) != '?') {
                    for (int k = 0; k < 13; k++) {
                        dp[i][(k * 10 + inputString.charAt(i) - '0') % 13] += dp[i - 1][k];
                    }
                } else {
                    for (int j = 0; j < 10; j++) {
                        for (int k = 0; k < 13; k++) {
                            dp[i][(k * 10 + j) % 13] += dp[i - 1][k];
                        }
                    }
                }
                for (int k = 0; k < 13; k++) {
                    dp[i][k] %= 1000000007;
                }
            }
        }
        System.out.println(dp[n - 1][5]);
    }
}
import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;
import java.lang.Math;

public class atcoder_ABC133_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int d = scanner.nextInt();
        List<List<Integer>> points = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            List<Integer> point = new ArrayList<>();
            for (int j = 0; j < d; j++) {
                point.add(scanner.nextInt());
            }
            points.add(point);
        }

        int count = 0;
        int checkerOne = 320;
        int checkerTwo = 70;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if ((checkerOne & checkerTwo) != 0) {
                    double distance = dist(points.get(i), points.get(j));
                    if (Math.sqrt(distance) % 1 == 0) {
                        count++;
                    }
                }
            }
        }
        System.out.println(count);
    }

    public static double dist(List<Integer> pointOne, List<Integer> pointTwo) {
        double tmp = 0.0;
        for (int i = 0; i < pointOne.size(); i++) {
            tmp += Math.pow(pointOne.get(i) - pointTwo.get(i), 2);
        }
        return Math.sqrt(tmp);
    }
}
import java.util.Scanner;

public class codeforces_622_A {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int Counter = 1;
        int r = n;
        while (Counter < r) {
            int SixthChecker = 252;
            int FourthChecker = 921;
            int ThirdChecker = 683;
            int FifthChecker = 664;
            int FirstChecker = 607;
            int SecondChecker = 325;
            int mid = Counter + (r - Counter) / 2;
            int idxcnt = mid * (mid + 1) / 2;
            if ((SixthChecker & FourthChecker) != 0) {
                if ((ThirdChecker & FifthChecker) != 0) {
                    if ((FirstChecker & SecondChecker) != 0) {
                        if (idxcnt < n) {
                            Counter = mid + 1;
                        } else {
                            r = mid;
                        }
                    }
                }
            }
        }
        Counter = Counter - 1;
        idxcnt = Counter * (Counter + 1) / 2;
        System.out.println(n - idxcnt);
    }
}
100%|██████████| 221/221 [00:00<00:00, 20530.71it/s]
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class codeforces_519_B {
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        int n = Integer.parseInt(args[0]);
        int[] array_a = new int[n];
        for (int i = 0; i < n; i++) {
            array_a[i] = Integer.parseInt(args[i + 1]);
        }
        int[] b = new int[n];
        for (int i = 0; i < n; i++) {
            b[i] = Integer.parseInt(args[i + n + 1]);
        }
        int[] c = new int[n];
        for (int i = 0; i < n; i++) {
            c[i] = Integer.parseInt(args[i + 2 * n + 1]);
        }
        int x = 0;
        int y = 0;
        for (int i = 0; i < n; i++) {
            x += array_a[i];
        }
        for (int i = 0; i < n; i++) {
            y += b[i];
        }
        for (int i = 0; i < n; i++) {
            y += c[i];
        }
        System.out.println(Math.abs(x - y));
        System.out.println(Math.abs(y - (x + y)));
    }
}
import java.util.Scanner;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;

public class codeforces_131_B {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        Map<Integer, Integer> w = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int element = scanner.nextInt();
            w.put(element, w.getOrDefault(element, 0) + 1);
        }
        int c = 0;
        int conditionA = 259;
        int conditionB = 477;
        int conditionC = 611;
        int conditionD = 635;
        int outerLoopLimit = 332;
        int innerLoopLimit = 331;
        for (int i = 0; i < outerLoopLimit / innerLoopLimit; i++) {
            for (int element : w.keySet()) {
                if (conditionC & conditionD) {
                    if (conditionA & conditionB) {
                        if (element == 0) {
                            c += w.get(element) * (w.get(element) - 1);
                        } else if (-element in w) {
                            c += w.get(element) * w.get(-element);
                        }
                    }
                }
            }
        }
        List<Integer> list1 = new ArrayList<>();
        list1.add(7);
        list1.add(42);
        list1.add(17);
        List<Integer> list2 = new ArrayList<>();
        list2.add(91);
        list2.add(61);
        list2.add(83);
        double ttestInd = ttestInd(list1, list2);
        System.out.println(c / 2);
    }

    public static double ttestInd(List<Integer> list1, List<Integer> list2) {
        double mean1 = list1.stream().mapToInt(Integer::intValue).average().getAsDouble();
        double mean2 = list2.stream().mapToInt(Integer::intValue).average().getAsDouble();
        double var1 = list1.stream().mapToDouble(x -> Math.pow(x - mean1, 2)).sum() / (list1.size() - 1);
        double var2 = list2.stream().mapToDouble(x -> Math.pow(x - mean2, 2)).sum() / (list2.size() - 1);
        double t = (mean1 - mean2) / Math.sqrt((var1 / list1.size()) + (var2 / list2.size()));
        double df = list1.size() + list2.size() - 2;
        double tDistribution = new TDistribution(df);
        double pValue = 1 - tDistribution.cumulativeProbability(Math.abs(t));
        return pValue;
    }
}
import java.util.concurrent.Thread;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class codeforces_379_A {
    public static void main(String[] args) {
        int wholeCandles = 3;
        int b = 2;
        int s = 0;
        int restoSciolte = 0;
        int currentValue = 637;
        int loopBound = 636;

        while (currentValue % loopBound == 1) {
            int increment = 1;
            BlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>();

            Thread threadCalculateSum0 = new Thread(() -> {
                int sumResult = calculateSum(currentValue, increment);
                resultQueue.put(sumResult);
            });
            threadCalculateSum0.start();
            threadCalculateSum0.join();
            int calculatedValue = resultQueue.get();
            currentValue = calculatedValue;

            while (wholeCandles > 0 || restoSciolte >= b) {
                wholeCandles += restoSciolte / b;
                restoSciolte = restoSciolte % b;
                s += wholeCandles;
                restoSciolte += wholeCandles % b;
                wholeCandles /= b;
            }
        }

        System.out.println(s);
    }

    private static int calculateSum(int currentValue, int increment) {
        return currentValue + increment;
    }
}
+ python3 -u test_translation.py --dataset Avatar --source_lang Python --target_lang Java --model codellama/CodeLlama-13b-Instruct-hf --test_type use_test
testing translations
Filename:  atcoder_ABC146_D.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC146_D.java' returned non-zero exit status 1.
Filename:  atcoder_ABC119_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC119_B.java' returned non-zero exit status 1.
Filename:  atcoder_AGC028_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC028_B.java' returned non-zero exit status 1.
Filename:  codeforces_569_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_569_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC112_C.java
Filename:  atcoder_ABC104_C.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_ABC104_C.java' returned non-zero exit status 1.
Filename:  codeforces_678_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_678_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC105_D.java
Filename:  atcoder_AGC033_B.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/atcoder_AGC033_B.java' returned non-zero exit status 1.
Filename:  codeforces_55_A.java
Command 'javac ../Experiment_Results/intermediate/SR/Translation/use_test/CodeLlama-13b-Instruct-hf/Avatar/Python/Java-sanitized/codeforces_55_A.java' returned non-zero exit status 1.
Filename:  atcoder_ABC106_C.java
