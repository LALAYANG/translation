import java.util.Scanner ; public class atcoder_ARC102_C { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System.in ) ; int K = sc.nextInt ( ) ; int N = sc.nextInt ( ) ; long [ ] ans = new long [ 2 * K + 1 ] ; long mod = 998244353 ; long [ ] g1 = new long [ 20 ] ; long [ ] g2 = new long [ 20 ] ; long [ ] inverse = new long [ 20 ] ; g1 [ 1 ] = 1 ; g1 [ 0 ] = 1 ; g2 [ 1 ] = 1 ; g2 [ 0 ] = 1 ; inverse [ 1 ] = 1 ; inverse [ 0 ] = 1 ; for ( int i = 2 ; i < 20 ; i ++ ) { g1 [ i ] = ( g1 [ i - 1 ] * i ) % mod ; inverse [ i ] = ( - inverse [ mod % i ] * ( mod / i ) ) % mod ; g2 [ i ] = ( g2 [ i - 1 ] * inverse [ i - 1 ] ) % mod ; } long comb ( long n , long r , long mod ) { if ( r < 0 ||r > n ) return 0 ; r = Math.min ( r , n - r ) ; return ( g1 [ n ] * g2 [ r ] % mod * g2 [ n - r ] % mod ) ; } long kumiawase ( long p , long q ) { return comb ( p + q - 1 , q - 1 , mod ) ; } long solve ( long n ) { assert n <= K + 1 ; long ans = 0 ; long kumi = ( n - 1 ) / 2 ; for ( long p = 1 ; p <= kumi + 1 ; p ++ ) { if ( p > N ) break ; ans += ( long ) Math.pow ( 2 , p ) * comb ( kumi , p , mod ) * kumiawase ( N - p , p + ( K - kumi * 2 - ( n % 2 == 0 ? 1 : 0 ) ) ) ; if ( n % 2 == 0 && N - p - 1 >= 0 ) { ans += ( long ) Math.pow ( 2 , p ) * comb ( kumi , p , mod ) * kumiawase ( N - p - 1 , p + ( K - kumi * 2 - ( n % 2 == 0 ? 1 : 0 ) ) ) ; } } return ans ; } for ( int i = 2 ; i <= 2 * K + 1 ; i ++ ) { if ( i <= K + 1 ) { ans [ i ] = solve ( i ) % 998244353 ; System.out.println ( ans [ i ] ) ; } else { System.out.println ( ans [ 2 * K + 1 - i ] ) ; } } } }